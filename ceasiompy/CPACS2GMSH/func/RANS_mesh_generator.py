"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Use .brep files parts of an airplane to generate a fused airplane in GMSH with
the OCC kernel. Then Spherical farfield is created around the airplane and the
resulting domain is meshed using gmsh

Python version: >=3.8

| Author: Guido Vallifuoco
| Creation: 2024-02-01

TODO:

    - It may be good to move all the function and some of the code in generategmsh()
    that are related to disk actuator to another python script and import it here

    - Add mesh sizing for each aircraft part and as consequence add marker

    - Integrate other parts during fragmentation

    - Use run software function instead subprocess.call

"""


# =================================================================================================
#   IMPORTS
# =================================================================================================

import os
import subprocess
from pathlib import Path
import numpy as np

import gmsh
from ceasiompy.CPACS2GMSH.func.generategmsh import (
    # duplicate_disk_actuator_surfaces,
    # control_disk_actuator_normal,
    # get_entities_from_volume,
    ModelPart,
    add_disk_actuator,
    fuselage_size,
    process_gmsh_log,
)
from ceasiompy.utils.ceasiomlogger import get_logger

# from ceasiompy.utils.commonnames import (
#     ACTUATOR_DISK_OUTLET_SUFFIX,
#     ENGINE_EXHAUST_SUFFIX,
#     ENGINE_INTAKE_SUFFIX,
#     GMSH_ENGINE_CONFIG_NAME,
# )
from ceasiompy.utils.ceasiompyutils import get_part_type

# from ceasiompy.utils.commonxpath import GMSH_MESH_SIZE_WINGS_XPATH
from ceasiompy.utils.configfiles import ConfigFile

log = get_logger()


# =================================================================================================
#   FUNCTIONS
# =================================================================================================


def generate_2d_mesh_for_pentagrow(
    cpacs,
    cpacs_path,
    brep_dir,
    results_dir,
    open_gmsh,
    min_mesh_factor,
    max_mesh_factor,
    symmetry=False,
):
    """
    Function to generate a mesh from brep files forming an airplane
    Function 'generate_gmsh' is a subfunction of CPACS2GMSH which return a
    mesh file useful for pentagrow.
    The airplane is fused with the different brep files : fuselage, wings and
    other parts are identified and fused together in order to obtain a watertight volume.
    Args:
    ----------
    cpacs : CPACS
        CPACS object
    brep_dir : Path
        Path to the directory containing the brep files
    results_dir : Path
        Path to the directory containing the result (mesh) files
    open_gmsh : bool
        Open gmsh GUI after the mesh generation if set to true
    symmetry : bool
        If set to true, the mesh will be generated with symmetry wrt the x,z plane
    mesh_size_fuselage : float
        Size of the fuselage mesh
    mesh_size_wings : float
        Size of the wing mesh
    mesh_size_engines : float
        Size of the engine mesh
    mesh_size_propellers : float
        Size of the propeller mesh
    advance_mesh : bool
        If set to true, the mesh will be generated with advanced meshing options
    refine_factor : float
        refine factor for the mesh le and te edge
    refine_truncated : bool
        If set to true, the refinement can change to match the truncated te thickness
    auto_refine : bool
        If set to true, the mesh will be checked for quality
    testing_gmsh : bool
        If set to true, the gmsh sessions will not be clear and killed at the end of
        the function, this allow to test the gmsh feature after the call of generate_gmsh()
    ...
    Returns:
    ----------
    mesh_file : Path
        Path to the mesh file generated by gmsh


    """
    # Determine if rotor are present in the aircraft model
    rotor_model = False
    if Path(brep_dir, "config_rotors.cfg").exists():
        rotor_model = True

    if rotor_model:
        log.info("Adding disk actuator")
        config_file = ConfigFile(Path(brep_dir, "config_rotors.cfg"))
        add_disk_actuator(brep_dir, config_file)

    # Retrieve all brep
    brep_files = list(brep_dir.glob("*.brep"))
    brep_files.sort()

    # initialize gmsh
    gmsh.initialize()

    gmsh.option.setNumber("General.Terminal", 0)
    gmsh.option.setNumber("General.Verbosity", 5)
    gmsh.option.setNumber("Geometry.ToleranceBoolean", 1e-6)

    log.info(f"Importing files from {brep_dir}")

    def bounding_box_distance(bbox1, bbox2):
        dist_x = max(bbox1[0] - bbox2[3], bbox2[0] - bbox1[3], 0)
        dist_y = max(bbox1[1] - bbox2[4], bbox2[1] - bbox1[4], 0)
        dist_z = max(bbox1[2] - bbox2[5], bbox2[2] - bbox1[5], 0)
        return np.sqrt(dist_x**2 + dist_y**2 + dist_z**2)

    parts_parent_dimtag = []
    bounding_boxes = {}
    brep_file_names = []

    aircraft_parts = []
    parts_parent_dimtag = []

    for brep_file in brep_files:
        part_entities = gmsh.model.occ.importShapes(str(brep_file), highestDimOnly=False)
        gmsh.model.occ.synchronize()

        xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.occ.getBoundingBox(
            part_entities[0][0], part_entities[0][1]
        )

        bounding_boxes[brep_file.name] = (xmin, ymin, zmin, xmax, ymax, zmax)
        brep_file_names.append(brep_file.name)
        parts_parent_dimtag.append(part_entities[0])

        # Create the aircraft part object
        part_obj = ModelPart(uid=brep_file.stem)
        part_obj.part_type = get_part_type(cpacs.tixi, part_obj.uid)

        # Add to the list of aircraft parts
        aircraft_parts.append(part_obj)

        gmsh.model.occ.synchronize()

        log.info(f"Part : {part_obj.uid} imported")

    while len(parts_parent_dimtag) > 1:
        fused = False
        min_distance = float("inf")
        best_pair = None

        for i in range(len(parts_parent_dimtag)):
            bbox1 = bounding_boxes[brep_file_names[i]]
            for j in range(i + 1, len(parts_parent_dimtag)):
                if j >= len(brep_file_names):
                    log.error(f"Index {j} is out of range for brep_file_names")
                    continue
                bbox2 = bounding_boxes[brep_file_names[j]]
                distance = bounding_box_distance(bbox1, bbox2)
                if distance < min_distance:
                    min_distance = distance
                    best_pair = (i, j)

        if best_pair is None:
            log.error("No valid pairs found for fusion.")
            break

        i, j = best_pair
        try:
            fused_entities, mapping = gmsh.model.occ.fuse(
                [parts_parent_dimtag[i]], [parts_parent_dimtag[j]]
            )
            gmsh.model.occ.synchronize()

            new_fused = fused_entities[0]
            new_bbox = gmsh.model.occ.getBoundingBox(new_fused[0], new_fused[1])

            parts_parent_dimtag = [new_fused] + [
                parts_parent_dimtag[k]
                for k in range(len(parts_parent_dimtag))
                if k != i and k != j
            ]
            brep_file_names = ["fused"] + [
                brep_file_names[k] for k in range(len(brep_file_names)) if k != i and k != j
            ]
            bounding_boxes["fused"] = new_bbox

            fused = True
            log.info(
                f"Fused entities {i} and {j} with distance {min_distance}. Remaining entities: {len(parts_parent_dimtag)}"
            )
        except Exception as e:
            log.error(f"Fusion failed for entities {i} and {j}: {e}")

        if not fused:
            log.info("No more entities could be fused.")
            break

    fuselage_maxlen, _ = fuselage_size(cpacs_path)
    log.info("Fusion process ended")

    # maybe can be removed
    model_bb = gmsh.model.getBoundingBox(-1, -1)
    model_dimensions = [
        abs(model_bb[0] - model_bb[3]),
        abs(model_bb[1] - model_bb[4]),
        abs(model_bb[2] - model_bb[5]),
    ]
    model_center = [
        model_bb[0] + model_dimensions[0] / 4,
        0,  # the y coordinate is set to zero because sometimes (when act disk
        # actuator is present) the coordinate of the model is not exact
        model_bb[2] + model_dimensions[2] / 4,
    ]

    aircraft = ModelPart("aircraft")

    for part in aircraft_parts:
        aircraft.points.extend(part.points)
        aircraft.lines.extend(part.lines)
        aircraft.surfaces.extend(part.surfaces)
        aircraft.volume.extend(part.volume)
        aircraft.points_tags.extend(part.points_tags)
        aircraft.lines_tags.extend(part.lines_tags)
        aircraft.surfaces_tags.extend(part.surfaces_tags)
        aircraft.volume_tag.extend(part.volume_tag)

        log.info(
            f"Part: {part.uid}, Points: {part.points}, Lines: {part.lines}, surfaces: {part.surfaces}, Type: {part.part_type}"
        )

        # Set surface BC for each part of the aircraft
        # if part.part_type == "engine":
        # define_engine_bc(part, brep_dir)
        # else:
        # surfaces_group = gmsh.model.addPhysicalGroup(2, part.surfaces_tags)
        # if part.part_type == "rotor":
        # gmsh.model.setPhysicalName(
        # 2, surfaces_group, f"{part.uid}{ACTUATOR_DISK_INLET_SUFFIX}"
        # )
        # else:
        # gmsh.model.setPhysicalName(2, surfaces_group, f"{part.uid}")
        # part.physical_groups.append(surfaces_group)
        surfaces_group = gmsh.model.addPhysicalGroup(2, part.surfaces_tags)
        gmsh.model.setPhysicalName(2, surfaces_group, f"{part.uid}")
        part.physical_groups.append(surfaces_group)

    # Mesh generation
    log.info("Start of gmsh 2D surface meshing process")
    # log.info(f"aircraft part {aircraft_parts}")
    # log.info(f"part {part}")

    for part in aircraft_parts:
        if part.part_type == "fuselage":
            part.mesh_size = 0.1
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
            # gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)
        elif part.part_type in ["wing", "pylon"]:
            part.mesh_size = 0.01
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
            # gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)
        elif part.part_type == "engine":
            part.mesh_size = 0.1
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
        #     # gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)
        elif part.part_type == "rotor":
            part.mesh_size = 0.1
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
        #     # gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)

    gmsh.option.setNumber("Mesh.MeshSizeMin", 0.01)
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)

    gmsh.option.setNumber("Mesh.Algorithm", 6)
    gmsh.option.setNumber("Mesh.LcIntegrationPrecision", 1e-6)

    gmsh.model.occ.synchronize()
    gmsh.logger.start()

    gmsh.model.mesh.generate(1)
    gmsh.model.mesh.generate(2)

    if open_gmsh:
        log.info("Result of 2D surface mesh")
        log.info("GMSH GUI is open, close it to continue...")
        gmsh.fltk.run()

    gmsh.model.occ.synchronize()

    gmsh_path = Path(results_dir, "mesh_2d.stl")
    gmsh.write(str(gmsh_path))

    process_gmsh_log(gmsh.logger.get())

    return gmsh_path, fuselage_maxlen, model_center


def pentagrow_3d_mesh(
    result_dir,
    fuselage_maxlen,
    farfield_factor,
    n_layer,
    h_first_layer,
    max_layer_thickness,
    growth_factor,
    growth_ratio,
    feature_angle,
    model_center,
) -> None:
    # create the config file for pentagrow
    config_penta_path = Path(result_dir, "config.cfg")
    # Variables
    InputFormat = "stl"
    NLayers = n_layer
    FeatureAngle = feature_angle
    InitialHeight = h_first_layer * (10**-5)
    MaxGrowthRatio = growth_ratio
    MaxLayerThickness = max_layer_thickness / 10
    FarfieldRadius = fuselage_maxlen * farfield_factor * 100
    OutputFormat = "su2"
    HolePosition = model_center
    TetgenOptions = "-pq1.3VY"
    TetGrowthFactor = growth_factor
    HeightIterations = 8
    NormalIterations = 8
    MaxCritIterations = 128
    LaplaceIterations = 8

    # writing to file
    file = open(config_penta_path, "w")
    file.write(f"InputFormat = {InputFormat}\n")
    file.write(f"NLayers = {NLayers}\n")
    file.write(f"FeatureAngle = {FeatureAngle}\n")
    file.write(f"InitialHeight = {InitialHeight}\n")
    file.write(f"MaxGrowthRatio = {MaxGrowthRatio}\n")
    file.write(f"MaxLayerThickness = {MaxLayerThickness}\n")
    file.write(f"FarfieldRadius = {FarfieldRadius}\n")
    file.write(f"OutputFormat = {OutputFormat}\n")
    file.write(f"HolePosition = {HolePosition}\n")
    file.write(f"TetgenOptions = {TetgenOptions}\n")
    file.write(f"TetGrowthFactor = {TetGrowthFactor}\n")
    file.write(f"HeightIterations = {HeightIterations}\n")
    file.write(f"NormalIterations = {NormalIterations}\n")
    file.write(f"MaxCritIterations = {MaxCritIterations}\n")
    file.write(f"LaplaceIterations = {LaplaceIterations}\n")

    os.chdir("Results/GMSH")

    if os.path.exists("mesh_2d.stl"):
        log.info("mesh_2d.stl exists")
    else:
        log.warning("mesh_2d.stl does not exist")

    if os.path.exists("config.cfg"):
        log.info("config.cfg exists")
    else:
        log.warning("config.cfg does not exist")

    current_dir = os.getcwd()
    os.chdir(current_dir)

    # command = "pentagrow mesh_2d.stl config.cfg"
    command = ["pentagrow", "mesh_2d.stl", "config.cfg"]
    # Specify the file path
    file_path = "command.txt"

    command_str = " ".join(command)

    with open(file_path, "w") as file:
        file.write(command_str)

    subprocess.call(command, cwd=current_dir, start_new_session=False)

    mesh_path = Path(result_dir, "hybrid.su2")
    log.info(f"Mesh path:{mesh_path}")

    return mesh_path
