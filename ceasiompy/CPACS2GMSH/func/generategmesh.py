"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Use .brep files parts of an airplane to generate a fused airplane in GMSH with
the OCC kernel. Then Spherical farfield is created around the airplane and the
resulting domain is meshed using gmsh

Python version: >=3.8

| Author: Tony Govoni
| Creation: 2022-03-22
| Modified by: Giacomo Benedetti, Guido Vallifuoco
| Last modification: 2024-02-01

TODO:

    - It may be good to move all the function and some of the code in generategmsh()
    that are related to disk actuator to another python script and import it here

    - It may be better to propose more options for the mesh size of the different
    part (pylon,engine,rotor)

    - Add a boolean to deactivate the refinement factor according to the thickness of the
    truncated te of the wings. This options often create very small meshes and is not
    always required.

"""


# =================================================================================================
#   IMPORTS
# =================================================================================================

from pathlib import Path
from ceasiompy.CPACS2GMSH.func.gmsh_utils import MESH_COLORS
from ceasiompy.utils.commonnames import (
    ACTUATOR_DISK_INLET_SUFFIX,
    ACTUATOR_DISK_OUTLET_SUFFIX,
    ENGINE_EXHAUST_SUFFIX,
    ENGINE_INTAKE_SUFFIX,
    GMSH_ENGINE_CONFIG_NAME,
)
from ceasiompy.utils.commonxpath import GMSH_MESH_SIZE_FUSELAGE_XPATH, GMSH_MESH_SIZE_WINGS_XPATH
from ceasiompy.utils.configfiles import ConfigFile
import gmsh
import numpy as np
import os
from typing import List
import subprocess
from ceasiompy.CPACS2GMSH.func.advancemeshing import (
    refine_wing_section,
    set_domain_mesh,
    refine_small_surfaces,
    min_fields,
)
from ceasiompy.CPACS2GMSH.func.wingclassification import classify_wing

from ceasiompy.utils.ceasiomlogger import get_logger
from ceasiompy.utils.ceasiompyutils import get_part_type, run_software

from cpacspy.cpacsfunctions import create_branch

from ceasiompy.CPACS2GMSH.func.mesh_sizing import fuselage_size, wings_size


log = get_logger()


# =================================================================================================
#   CLASSES
# =================================================================================================


class ModelPart:
    """
    A class to represent part of the aircraft or other part of the gmsh model
    in order to classify its entities and dimension tags
    ...

    Attributes
    ----------
    uid : str
        name of the part which correspond to its .brep file name for aircraft parts
        or a simple name describing the part function in the model

    """

    def __init__(self, uid):
        self.uid = uid
        self.part_type = ""

        # dimtag
        self.points = []
        self.lines = []
        self.surfaces = []
        self.volume = []
        # tag only
        self.points_tags = []
        self.lines_tags = []
        self.surfaces_tags = []
        self.volume_tag = []
        # children
        self.children_dimtag = set()
        # Physical groups
        self.physical_groups = []

    def associate_child_to_parent(self, child_dimtag):
        """
        Function to associate a child to a parent.
        all the entities belonging to a child (volume generated by the fragment operation)
        are associated to their parent part (volume before the fragment operation)

        Args:
        ----------
        child_dimtag : tuple (dim,tag)
            dimtag of the child volume
        """

        # Detect 2D or 3D child
        if child_dimtag[0] == 3:
            # Associate a 3D the child to the parent
            child_volume = [child_dimtag]

            child_surfaces, child_lines, child_points = get_entities_from_volume(child_volume)

            # Get the dimtags (3D only)
            child_volume_tag = [dimtag[1] for dimtag in child_volume]
            # Store in parent parts for latter use (3D only)
            self.volume.extend(child_volume)
            self.volume_tag.extend(child_volume_tag)

        # 2D child and parent
        elif child_dimtag[0] == 2:
            child_surfaces = [child_dimtag]
            child_lines = list(
                gmsh.model.getBoundary(
                    child_surfaces, combined=True, oriented=False, recursive=False
                )
            )
            child_lines.sort()

            child_points = list(
                gmsh.model.getBoundary(
                    child_surfaces, combined=True, oriented=False, recursive=True
                )
            )
            child_points.sort()

        elif child_dimtag[0] != 2 and child_dimtag[0] != 3:
            raise ValueError("Dimension of the child is not 2 or 3")

        # Get the dimtags
        child_surfaces_tags = [dimtag[1] for dimtag in child_surfaces]
        child_lines_tags = [dimtag[1] for dimtag in child_lines]
        child_points_tags = [dimtag[1] for dimtag in child_points]

        # Store in parent parts for latter use
        self.points.extend(child_points)
        self.lines.extend(child_lines)
        self.surfaces.extend(child_surfaces)
        self.points_tags.extend(child_points_tags)
        self.lines_tags.extend(child_lines_tags)
        self.surfaces_tags.extend(child_surfaces_tags)

    def clean_inside_entities(self, final_domain):
        """
        Function to clean inside entities of the part.
        Inside entities are entities that are not part of the final domain.

        Args:
        ----------
        final_domain : ModelPart
            final_domain part
        """
        if self.part_type == "rotor":
            # Detect all the entities in the domain with gmsh functions
            self.surfaces = sorted(
                list(set(self.surfaces).intersection(set(gmsh.model.getEntities(dim=2))))
            )
            self.lines = sorted(
                list(set(self.lines).intersection(set(gmsh.model.getEntities(dim=1))))
            )
            self.points = sorted(
                list(set(self.points).intersection(set(gmsh.model.getEntities(dim=0))))
            )

            # Update the dimtags
            self.surfaces_tags = [dimtag[1] for dimtag in self.surfaces]
            self.lines_tags = [dimtag[1] for dimtag in self.lines]
            self.points_tags = [dimtag[1] for dimtag in self.points]
            return
        # if not rotor part
        # Detect only shared entities with the final domain
        self.surfaces = sorted(list(set(self.surfaces).intersection(set(final_domain.surfaces))))
        self.lines = sorted(list(set(self.lines).intersection(set(final_domain.lines))))
        self.points = sorted(list(set(self.points).intersection(set(final_domain.points))))

        # Update the dimtags
        self.surfaces_tags = sorted([dimtag[1] for dimtag in self.surfaces])
        self.lines_tags = sorted([dimtag[1] for dimtag in self.lines])
        self.points_tags = sorted([dimtag[1] for dimtag in self.points])


# =================================================================================================
#   FUNCTIONS
# =================================================================================================


def get_entities_from_volume(volume_dimtag):
    """
    Function to get the entities belonging to a volume.
    Surfaces and lines are found with the gmsh.model.getBoundary() function.
    Points are found with the gmsh.model.getEntities() function using recursive set to True.
    This choice seems the most efficient and robust at the state of development of Gmsh

    Args:
    ----------
    volume_dimtag : list
        a list containing the dimtag of the volume [(dim,tag)]
        which is a standard input format for other gmsh function
    ...

    Returns:
    ----------
    surfaces_dimtags : list(tuple)
        a list of tuples containing the dimtag of the surfaces
    lines_dimtags : list(tuple)
        a list of tuples containing the dimtag of the lines
    points_dimtags : list(tuple)
        a list of tuples containing the dimtag of the points
    """

    surfaces_dimtags = gmsh.model.getBoundary(
        volume_dimtag, combined=True, oriented=False, recursive=False
    )

    lines_dimtags = list(
        set().union(
            *[
                gmsh.model.getBoundary([surface], combined=True, oriented=False, recursive=False)
                for surface in surfaces_dimtags
            ]
        )
    )
    lines_dimtags.sort()

    points_dimtags = list(
        set().union(
            *[
                gmsh.model.getBoundary([surface], combined=True, oriented=False, recursive=True)
                for surface in surfaces_dimtags
            ]
        )
    )
    points_dimtags.sort()

    return surfaces_dimtags, lines_dimtags, points_dimtags


def define_engine_bc(engine_part, brep_dir):
    """
    Function to define the boundary conditions for the engine part.
    The engine is defined as a volume and the boundary conditions intake exhaust
    are set to be fixed.

    Args:
    ----------
    engine_part : ModelPart
        engine part of the aircraft to set the bc on
    brep_dir : Path
        path to the brep files of the aircraft that also contains the engine config file

    """

    # Check if the engine is double or simple flux and
    # the engine normal and distance between the intake and exhaust

    config_file_path = Path(brep_dir, GMSH_ENGINE_CONFIG_NAME)
    config_file = ConfigFile(config_file_path)

    doubleflux = bool(int(config_file[f"{engine_part.uid}_DOUBLE_FLUX"]))
    engine_normal = [0, 0, 0]
    engine_normal[0] = float(config_file[f"{engine_part.uid}_NORMAL_X"])
    engine_normal[1] = float(config_file[f"{engine_part.uid}_NORMAL_Y"])
    engine_normal[2] = float(config_file[f"{engine_part.uid}_NORMAL_Z"])
    scaling_x = float(config_file[f"{engine_part.uid}_SCALING_X"])

    # Determine which surfaces are possible engine intake and exhaust by their normal orientation
    possible_intake = []
    possible_exhaust = []
    # and which surface tag will be excluded from the engine surfaces
    int_exh_surf_tag = []

    # Loop all the engine surfaces to seek for potential right placed surfaces
    for dimtag in engine_part.surfaces:
        surface_center = gmsh.model.occ.getCenterOfMass(*dimtag)
        parametric_coord = gmsh.model.getParametrization(*dimtag, list(surface_center))

        # GMSH normal is defined exiting the volume
        # note here that the volume is the fluid, so the inside of the engine is the outside
        # of the volume, so intake normal is opposite to engine normal
        normal = gmsh.model.getNormal(dimtag[1], parametric_coord)
        absolute_same = np.isclose(
            np.absolute(engine_normal), np.absolute(normal), atol=1e-04, equal_nan=False
        )
        same = np.isclose(engine_normal, normal, atol=1e-04, equal_nan=False)

        if absolute_same.all():
            if same.all():
                possible_exhaust.append(dimtag)
            else:
                possible_intake.append(dimtag)

    intake_x = float(config_file[f"{engine_part.uid}_fanCowl_INTAKE_X"])
    exhaust_x = float(config_file[f"{engine_part.uid}_fanCowl_EXHAUST_X"])
    engine_distance = (exhaust_x - intake_x) * scaling_x

    # Determine which surfaces are possible engine intake and exhaust by their
    # respective distance is the same as the one when the engine was converted
    for intake in possible_intake:
        for exhaust in possible_exhaust:
            pos_intake = gmsh.model.occ.getCenterOfMass(*intake)
            pos_exhaust = gmsh.model.occ.getCenterOfMass(*exhaust)
            distance = np.linalg.norm(np.subtract(pos_intake, pos_exhaust))

            if np.isclose(distance, engine_distance, atol=1e-04, equal_nan=False):
                engine_part.intake_tag = [intake[1]]
                engine_part.exhaust_fan_tag = [exhaust[1]]
                int_exh_surf_tag.extend(engine_part.intake_tag)
                int_exh_surf_tag.extend(engine_part.exhaust_fan_tag)
                break

    if doubleflux:
        intake_x = float(config_file[f"{engine_part.uid}_fanCowl_INTAKE_X"])
        exhaust_core_x = float(config_file[f"{engine_part.uid}_coreCowl_EXHAUST_X"])
        core_distance = (exhaust_core_x - intake_x) * scaling_x

        # Determine which exhaust goes with the intake by their respective distance
        for intake in possible_intake:
            for exhaust in possible_exhaust:
                pos_intake = gmsh.model.occ.getCenterOfMass(*intake)
                pos_exhaust = gmsh.model.occ.getCenterOfMass(*exhaust)
                distance = np.linalg.norm(np.subtract(pos_intake, pos_exhaust))
                if np.isclose(distance, core_distance, atol=1e-04, equal_nan=False):
                    engine_part.exhaust_core_tag = [exhaust[1]]
                    int_exh_surf_tag.extend(engine_part.exhaust_core_tag)
                    break

    # Set the boundary conditions
    # Engine_normal_surface
    engine_part.other_surfaces_tags = list(
        set(engine_part.surfaces_tags).difference(set(int_exh_surf_tag))
    )
    surfaces_group = gmsh.model.addPhysicalGroup(2, engine_part.other_surfaces_tags)
    gmsh.model.setPhysicalName(2, surfaces_group, f"{engine_part.uid}")

    # Intake
    intake_fan_group = gmsh.model.addPhysicalGroup(2, engine_part.intake_tag)
    gmsh.model.setPhysicalName(2, intake_fan_group, f"{engine_part.uid}_fan{ENGINE_INTAKE_SUFFIX}")

    # Exhaust
    exhaust_fan_group = gmsh.model.addPhysicalGroup(2, engine_part.exhaust_fan_tag)
    gmsh.model.setPhysicalName(
        2, exhaust_fan_group, f"{engine_part.uid}_fan{ENGINE_EXHAUST_SUFFIX}"
    )
    if doubleflux:
        exhaust_core_group = gmsh.model.addPhysicalGroup(2, engine_part.exhaust_core_tag)
        gmsh.model.setPhysicalName(
            2, exhaust_core_group, f"{engine_part.uid}_core{ENGINE_EXHAUST_SUFFIX}"
        )


def process_gmsh_log(gmsh_log):
    """
    Function to process the gmsh log file.
    It is used to retrieve the mesh quality
    and the time needed to mesh the model
    ...

    Args:
    ----------
    gmsh_log : list(str)
        list of gmsh log events
    """

    # Find last logs about mesh quality
    quality_log = [log for log in gmsh_log if "< quality <" in log]
    final_quality_log = quality_log[-10:]

    log.info("Final mesh quality :")
    for log_line in final_quality_log:
        log.info(log_line)

    total_time = 0
    time_log = [log for log in gmsh_log if "CPU" in log]
    for message in time_log:
        total_time += float(message.split("CPU")[1].split("s")[0])

    log.info(f"Total meshing time : {round(total_time, 2)}s")


def add_disk_actuator(brep_dir, config_file):
    """
    Function to create a 2D disk in a given location to represent a rotor as a
    disk actuator
    ...

    Args:
    ----------
    brep_dir : Path
        path to the brep files of the aircraft that also contains the rotor config file
    config_file : Configfile
        config file of the propellers configuration on the aircraft

    """

    nb_rotor = int(config_file["NB_ROTOR"])

    for k in range(1, nb_rotor + 1):
        # get the rotor configuration from cfg file
        rotor_uid = config_file[f"UID_{k}"]
        radius = float(config_file[f"{rotor_uid}_ROTOR_RADIUS"])
        sym = int(config_file[f"{rotor_uid}_SYMMETRIC"])
        trans_vector = (
            float(config_file[f"{rotor_uid}_TRANS_X"]),
            float(config_file[f"{rotor_uid}_TRANS_Y"]),
            float(config_file[f"{rotor_uid}_TRANS_Z"]),
        )
        rot_vector = (
            float(config_file[f"{rotor_uid}_ROT_X"]),
            float(config_file[f"{rotor_uid}_ROT_Y"]),
            float(config_file[f"{rotor_uid}_ROT_Z"]),
        )

        # Adding rotating disk
        gmsh.initialize()
        # generate the inlet_disk (gmsh always create a disk in the xy plane)
        disk_tag = gmsh.model.occ.addDisk(*trans_vector, radius, radius)
        disk_dimtag = (2, disk_tag)

        # y axis 180deg flip to make the inlet of the disk face forward
        gmsh.model.occ.rotate([disk_dimtag], *trans_vector, 0, 1, 0, np.radians(180))
        gmsh.model.occ.synchronize()

        # rotation given in the cpacs file
        # x axis
        gmsh.model.occ.rotate([disk_dimtag], *trans_vector, 1, 0, 0, np.radians(rot_vector[0]))
        # y axis
        gmsh.model.occ.rotate([disk_dimtag], *trans_vector, 0, 1, 0, np.radians(rot_vector[1]))
        # z axis
        gmsh.model.occ.rotate([disk_dimtag], *trans_vector, 0, 0, 1, np.radians(rot_vector[2]))

        gmsh.model.occ.synchronize()

        path_disk = Path(brep_dir, f"{rotor_uid}.brep")
        gmsh.write(str(path_disk))

        gmsh.clear()
        gmsh.finalize()

        if sym == 2:
            # Adding the symmetric
            gmsh.initialize()
            # generate the inlet_disk (gmsh always create a disk in the xy plane)
            disk_tag = gmsh.model.occ.addDisk(*trans_vector, radius, radius)
            disk_dimtag = (2, disk_tag)

            # y axis 180deg flip to make the inlet of the disk face forward is not necessary for
            # the mirrored part, and for now the symmetry is not implemented correctly since
            # the symmetry does not take into account the orientation of the rotor and the plane
            # of symmetry is assume to be the xz plane
            # When the face of the disk actuator are not oriented well the simulation shows
            # increasing cd and will probably diverge

            # rotation given in the cpacs file
            # x axis
            gmsh.model.occ.rotate([disk_dimtag], *trans_vector, 1, 0, 0, np.radians(rot_vector[0]))
            # y axis
            gmsh.model.occ.rotate([disk_dimtag], *trans_vector, 0, 1, 0, np.radians(rot_vector[1]))
            # z axis
            gmsh.model.occ.rotate([disk_dimtag], *trans_vector, 0, 0, 1, np.radians(rot_vector[2]))

            gmsh.model.occ.synchronize()

            gmsh.model.occ.mirror([disk_dimtag], 0, 1, 0, 0)
            gmsh.model.occ.synchronize()
            path_disk = Path(brep_dir, f"{rotor_uid}_mirrored.brep")
            gmsh.write(str(path_disk))

            gmsh.clear()
            gmsh.finalize()


def duplicate_disk_actuator_surfaces(part):
    """
    Function to duplicate the surfaces of a disk actuator
    ...

    Args:
    ----------
    part : ModelPart
        Part object of the rotor modeled as a disk actuator
    """
    # "crack" the mesh by duplicating the elements and nodes on the disk surface
    if len(part.physical_groups) > 1:
        # raise error since disk actuator can only have one surface before duplicating
        raise ValueError("Disk actuator can only have one surface")

    gmsh.plugin.setNumber("Crack", "Dimension", 2)
    gmsh.plugin.setNumber("Crack", "PhysicalGroup", part.physical_groups[0])
    # find the last physical group tag
    new_tag = 1 + len(gmsh.model.getPhysicalGroups(dim=-1))
    gmsh.plugin.setNumber("Crack", "NewPhysicalGroup", new_tag)

    # Set the new physical group for the back surface
    gmsh.model.setPhysicalName(2, new_tag, f"{part.uid}{ACTUATOR_DISK_OUTLET_SUFFIX}")
    gmsh.plugin.run("Crack")


def control_disk_actuator_normal():
    """
    Function to control the surface orientation of disk actuator in the model
    sometimes the 'crack' plugin change the surface orientation of the inlet and outlet
    of disk actuator, thus we need to control if the inlet and outlet surface are
    well oriented, if not we switch the physical groups names of the inlet and outlet.

    """

    # Get the physical groups list
    physical_groups = gmsh.model.getPhysicalGroups(dim=2)
    physical_groups_name = [gmsh.model.getPhysicalName(*group) for group in physical_groups]

    inlet_groups = [
        group
        for group in physical_groups
        if ACTUATOR_DISK_INLET_SUFFIX in gmsh.model.getPhysicalName(*group)
    ]

    # Check the disk actuator  inlet normal, should point forward (x>0))
    for inlet_group in inlet_groups:
        # Get the normal
        surface_tag = gmsh.model.getEntitiesForPhysicalGroup(*inlet_group)
        surface_dimtag = (2, *surface_tag)
        surface_center = gmsh.model.occ.getCenterOfMass(*surface_dimtag)
        parametric_coord = gmsh.model.getParametrization(*surface_dimtag, list(surface_center))
        normal_x = gmsh.model.getNormal(surface_dimtag[1], parametric_coord)[0]

        if normal_x >= 0.0:
            continue

        # Switch the physical group name
        inlet_name = gmsh.model.getPhysicalName(*inlet_group)
        outlet_name = inlet_name.replace(ACTUATOR_DISK_INLET_SUFFIX, ACTUATOR_DISK_OUTLET_SUFFIX)

        outlet_group = physical_groups[physical_groups_name.index(outlet_name)]

        # Delete the physical group name
        gmsh.model.removePhysicalName(inlet_name)
        gmsh.model.removePhysicalName(outlet_name)

        # Rename by swapping inlet outlet
        gmsh.model.setPhysicalName(*inlet_group, outlet_name)
        gmsh.model.setPhysicalName(*outlet_group, inlet_name)


def generate_gmsh(
    cpacs,
    cpacs_path,
    brep_dir,
    results_dir,
    open_gmsh=False,
    farfield_factor=6,
    symmetry=False,
    farfield_size_factor=10,
    n_power_factor=2,
    n_power_field=0.9,
    fuselage_mesh_size_factor=1,
    wing_mesh_size_factor=1.5,
    mesh_size_engines=0.23,
    mesh_size_propellers=0.23,
    refine_factor=2.0,
    refine_truncated=False,
    auto_refine=True,
    testing_gmsh=False,
):
    """
    Function to generate a mesh from brep files forming an airplane
    Function 'generate_gmsh' is a subfunction of CPACS2GMSH which return a
    mesh file.
    The airplane is fused with the different brep files : fuselage, wings and
    other parts are identified anf fused together, then a farfield is generated
    and the airplane is subtracted to him to generate the final fluid domain
    marker of each airplane part and farfield surfaces is reported in the mesh
    file.
    Args:
    ----------
    cpacs : CPACS
        CPACS object
    brep_dir : Path
        Path to the directory containing the brep files
    results_dir : Path
        Path to the directory containing the result (mesh) files
    open_gmsh : bool
        Open gmsh GUI after the mesh generation if set to true
    farfield_factor = float
        Factor to enlarge the farfield : factor times the largest dimension(x,y,z)
        of the aircraft
    symmetry : bool
        If set to true, the mesh will be generated with symmetry wrt the x,z plane
    mesh_size_farfield : float
        Size of the farfield mesh
    mesh_size_fuselage : float
        Size of the fuselage mesh
    mesh_size_wings : float
        Size of the wing mesh
    mesh_size_engines : float
        Size of the engine mesh
    mesh_size_propellers : float
        Size of the propeller mesh
    advance_mesh : bool
        If set to true, the mesh will be generated with advanced meshing options
    refine_factor : float
        refine factor for the mesh le and te edge
    refine_truncated : bool
        If set to true, the refinement can change to match the truncated te thickness
    auto_refine : bool
        If set to true, the mesh will be checked for quality
    testing_gmsh : bool
        If set to true, the gmsh sessions will not be clear and killed at the end of
        the function, this allow to test the gmsh feature after the call of generate_gmsh()
    ...
    Returns:
    ----------
    mesh_file : Path
        Path to the mesh file generated by gmsh
    aircraft_parts : list(ModelPart)
        List of the aircraft parts in the model

    """

    # Determine if rotor are present in the aircraft model
    rotor_model = False
    if Path(brep_dir, "config_rotors.cfg").exists():
        rotor_model = True

    if rotor_model:
        log.info("Adding disk actuator")
        config_file = ConfigFile(Path(brep_dir, "config_rotors.cfg"))
        add_disk_actuator(brep_dir, config_file)

    # Retrieve all brep
    brep_files = list(brep_dir.glob("*.brep"))
    brep_files.sort()

    # initialize gmsh
    gmsh.initialize()
    # Stop gmsh output log in the terminal
    gmsh.option.setNumber("General.Terminal", 0)
    # Log complexity
    gmsh.option.setNumber("General.Verbosity", 5)

    # Import each aircraft original parts / parent parts
    aircraft_parts = []
    parts_parent_dimtag = []
    log.info(f"Importing files from {brep_dir}")
    for brep_file in brep_files:
        # Import the part and create the aircraft part object
        part_entities = gmsh.model.occ.importShapes(str(brep_file), highestDimOnly=False)
        gmsh.model.occ.synchronize()

        # Create the aircraft part object
        part_obj = ModelPart(uid=brep_file.stem)
        part_obj.part_type = get_part_type(cpacs.tixi, part_obj.uid)

        # Add to the list of aircraft parts
        aircraft_parts.append(part_obj)
        parts_parent_dimtag.append(part_entities[0])

        log.info(f"Part : {part_obj.uid} imported")

    gmsh.model.occ.synchronize()

    # Create external domain for the farfield
    model_bb = gmsh.model.getBoundingBox(-1, -1)
    model_dimensions = [
        abs(model_bb[0] - model_bb[3]),
        abs(model_bb[1] - model_bb[4]),
        abs(model_bb[2] - model_bb[5]),
    ]
    model_center = [
        model_bb[0] + model_dimensions[0] / 2,
        0,  # the y coordinate is set to zero because sometimes (when act disk
        # actuator is present) the coordinate of the model is not exact
        model_bb[2] + model_dimensions[2] / 2,
    ]

    domain_length = farfield_factor * max(model_dimensions)
    farfield = gmsh.model.occ.addSphere(*model_center, domain_length)
    gmsh.model.occ.synchronize()

    ext_domain = [(3, farfield)]

    if symmetry:
        log.info("Preparing: symmetry operation")
        sym_plane = gmsh.model.occ.addDisk(*model_center, domain_length, domain_length)
        sym_vector = [0, 1, 0]
        plane_vector = [0, 0, 1]
        if sym_vector != plane_vector:
            rotation_axis = np.cross(sym_vector, plane_vector)
            gmsh.model.occ.rotate([(2, sym_plane)], *model_center, *rotation_axis, np.pi / 2)
            sym_box = gmsh.model.occ.extrude(
                [(2, sym_plane)], *(np.multiply(sym_vector, -domain_length * 1.1))
            )
        parts_parent_dimtag.append(sym_box[1])

    log.info("Start fragment operation between the aircraft and the farfield")

    _, children_dimtag = gmsh.model.occ.fragment(ext_domain, parts_parent_dimtag)
    gmsh.model.occ.synchronize()

    log.info("Fragment operation finished")

    # fragment produce fragments_dimtag and children_dimtag

    # fragments_dimtag is a list of tuples (dimtag, tag) of all the volumes in the model
    # the first fragment is the entire domain, each other fragment are sub volume of the domain

    # children_dimtag is a list list of tuples (dimtag, tag)
    # the first list is associated to the entire domain as for fragments_dimtag, we don't need it
    # so for the following we work with children_dimtag[1:]

    # The rest of children_dimtag are list of tuples (dimtag, tag) that represent volumes in the
    # model children_dimtag is "sorted" according to the order of importation of the parent parts.
    # for example : if the first part imported was "fuselage1" then the first children_dimtag
    # is a list of all the "child" volumes in the model that are from the "parent" "fuselage1"
    # we can then associate each entities in the model to their parent origin

    # When two parents part ex. a fuselage and a wing intersect each other
    # two children are generated for both parts, thus if a child is shared by
    # two parent parts (or more), then this child is a volume given
    # by the intersection of the two parent parts, we don't need them and some
    # of its surfaces, lines and point in the final models

    # Thus we need to find those unwanted child and their entities that don't belong
    # to the final model, and remove them

    # afterward the entities of each child will be associated with their parent part names
    # then we can delete all the child in the model, and only keep the final domain
    # Removing a child will not delete its entities shared by the final domain, this means that
    # at the end we will only have one volume with all the surfaces,lines,points assigned
    # to the original parent parts imported at the begging of the function

    # If symmetry is applied the last children_dimtag is all the volume in the symmetry cylinder
    # thus the we can easily remove them and only keep the volumes of half domain

    unwanted_children = []
    if symmetry:
        # take the unwanted children from symmetry
        unwanted_children = children_dimtag[-1]
        # Attention this only take into account volumes elements in the symmetry
        # Disk actuator that are 2D element are not taken into account
        # and will be removed latter

        # remove them from the model
        gmsh.model.occ.remove(unwanted_children, recursive=True)
        gmsh.model.occ.synchronize()

    # Get the children of the aircraft parts
    aircraft_parts_children_dimtag = children_dimtag[1:]

    log.info("Before/after fragment operation relations:")
    for parent, children in zip(aircraft_parts, aircraft_parts_children_dimtag):
        # don't assign unwanted children if symmetry was used
        children = [child for child in children if child not in unwanted_children]
        log.info(f"{parent.uid} has generated {children} children")
        parent.children_dimtag = set(children)

    # Some parent may have no children (due to symmetry), we need to remove them
    unwanted_parents = []
    for parent in aircraft_parts:
        if parent.part_type == "rotor":
            # Control possible 2D children not removed by the fragment symmetry unwanted_children
            for dimtag in list(parent.children_dimtag):
                try:  # check if the child exists in the model
                    gmsh.model.getType(*dimtag)

                except Exception:
                    # if not remove it from the parent
                    parent.children_dimtag.remove(dimtag)

        if not parent.children_dimtag:
            log.info(f"{parent.uid} has no more children due to symmetry, it will be deleted")
            unwanted_parents.append(parent)

    # Remove unwanted parents
    if unwanted_parents:
        aircraft_parts = [part for part in aircraft_parts if part not in unwanted_parents]

    # Process and add children that are shared by two parent parts in the shared children list
    # and put them in a new unwanted children list

    unwanted_children = set()

    if len(aircraft_parts) > 1:
        for p, part in enumerate(aircraft_parts):
            for other_part in aircraft_parts[(p + 1) :]:
                shared_children = part.children_dimtag.intersection(other_part.children_dimtag)

                if shared_children:
                    part.children_dimtag = part.children_dimtag - shared_children
                    other_part.children_dimtag = other_part.children_dimtag - shared_children

                unwanted_children = unwanted_children.union(shared_children)

    unwanted_children = list(unwanted_children)

    # Remove unwanted children from the model
    gmsh.model.occ.remove(unwanted_children, recursive=True)
    gmsh.model.occ.synchronize()
    log.info(f"Unwanted children {unwanted_children} removed from model")

    # Associate good child with their parent
    good_children = []

    for parent in aircraft_parts:
        for child_dimtag in parent.children_dimtag:
            if child_dimtag not in unwanted_children:
                good_children.append(child_dimtag)
                log.info(f"Associating child {child_dimtag} to parent {parent.uid}")
                parent.associate_child_to_parent(child_dimtag)

    # Now that its clear which child entities in the model are from which parent part,
    # we can delete the child volumes and only keep the final domain
    gmsh.model.occ.remove(good_children, recursive=True)
    gmsh.model.occ.synchronize()

    # Now only the final domain is left, in the model, we can find its entities
    # we will use the ModelPart class to store the entities of the final domain
    final_domain = ModelPart("fluid")
    left_volume = gmsh.model.getEntities(dim=3)
    final_domain.associate_child_to_parent(*left_volume)

    # As already discussed, it is often that two parts intersect each other,
    # it can also happened that some parts create holes inside other parts
    # for example a fuselage and 2 wings defined in the center of the fuselage
    # will create a holed fragment of the fuselage
    # This is not a problem since this hole is not in the final domain volume
    # but they may be some lines and surfaces from the hole in the fuselage
    # that were not eliminated since they were shared by the unwanted children
    # and those lines and surfaces were assigned to the fuselage part

    # thus we need to clean a bit the associated entities by the function
    # associate_child_to_parent() by comparing them with the entities of the
    # final domain

    # Create an aircraft part containing all the parts of the aircraft
    aircraft = ModelPart("aircraft")

    for part in aircraft_parts:
        part.clean_inside_entities(final_domain)

        aircraft.points.extend(part.points)
        aircraft.lines.extend(part.lines)
        aircraft.surfaces.extend(part.surfaces)
        aircraft.volume.extend(part.volume)
        aircraft.points_tags.extend(part.points_tags)
        aircraft.lines_tags.extend(part.lines_tags)
        aircraft.surfaces_tags.extend(part.surfaces_tags)
        aircraft.volume_tag.extend(part.volume_tag)

        # Set surface BC for each part of the aircraft
        if part.part_type == "engine":
            define_engine_bc(part, brep_dir)
        else:
            surfaces_group = gmsh.model.addPhysicalGroup(2, part.surfaces_tags)
            if part.part_type == "rotor":
                gmsh.model.setPhysicalName(
                    2, surfaces_group, f"{part.uid}{ACTUATOR_DISK_INLET_SUFFIX}"
                )
            else:
                gmsh.model.setPhysicalName(2, surfaces_group, f"{part.uid}")
            part.physical_groups.append(surfaces_group)

    log.info("Model has been cleaned")

    # Farfield
    # farfield entities are simply the entities left in the final domain
    # that don't belong to the aircraft

    farfield_surfaces = list(set(final_domain.surfaces) - set(aircraft.surfaces))
    farfield_points = list(set(final_domain.points) - set(aircraft.points))
    farfield_surfaces_tags = list(set(final_domain.surfaces_tags) - set(aircraft.surfaces_tags))

    if symmetry:
        symmetry_surfaces = []
        symmetry_surfaces_tags = []

        # If symmetry was used, it means that in the farfield entities we have
        # a surface that is the plane of symmetry, we need to find it
        # and remove it from the farfield entities

        # In general it is easy because the symmetry plane should be the only surface
        # in the farfield who touch the aircraft

        for farfield_surface in farfield_surfaces:
            _, adj_lines_tags = gmsh.model.getAdjacencies(*farfield_surface)

            if set(adj_lines_tags).intersection(set(aircraft.lines_tags)):
                farfield_surfaces.remove(farfield_surface)
                farfield_surfaces_tags.remove(farfield_surface[1])

                symmetry_surfaces.append(farfield_surface)
                symmetry_surfaces_tags.append(farfield_surface[1])

        symmetry_group = gmsh.model.addPhysicalGroup(2, symmetry_surfaces_tags)
        gmsh.model.setPhysicalName(2, symmetry_group, "symmetry")

    farfield = gmsh.model.addPhysicalGroup(2, farfield_surfaces_tags)
    gmsh.model.setPhysicalName(2, farfield, "Farfield")

    # Fluid domain
    ps = gmsh.model.addPhysicalGroup(3, final_domain.volume_tag)
    gmsh.model.setPhysicalName(3, ps, final_domain.uid)

    gmsh.model.occ.synchronize()
    log.info("Markers for SU2 generated")
    # Mesh Generation

    # Set mesh size of the aircraft parts

    # not that points common between parts will have the size of the last part
    # to set its mesh size.
    # Thus be sure to define mesh size in a certain order to control
    # the size of the points on boundaries.

    fuselage_maxlen, fuselage_minlen = fuselage_size(cpacs_path)
    mesh_size_fuselage = fuselage_mesh_size_factor * fuselage_minlen
    log.info(f"Mesh size fuselage={mesh_size_fuselage:.3f} m")

    create_branch(cpacs.tixi, GMSH_MESH_SIZE_FUSELAGE_XPATH)
    cpacs.tixi.updateDoubleElement(GMSH_MESH_SIZE_FUSELAGE_XPATH, mesh_size_fuselage, "%.3f")

    wing_maxlen, wing_minlen = wings_size(cpacs_path)
    mesh_size_wing = wing_mesh_size_factor * wing_minlen
    log.info(f"Mesh size wing={mesh_size_wing:.3f} m")

    create_branch(cpacs.tixi, GMSH_MESH_SIZE_WINGS_XPATH)
    cpacs.tixi.updateDoubleElement(GMSH_MESH_SIZE_WINGS_XPATH, mesh_size_wing, "%.3f")

    for part in aircraft_parts:
        if part.part_type == "fuselage":
            part.mesh_size = mesh_size_fuselage
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
            gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)
        elif part.part_type in ["wing", "pylon"]:
            part.mesh_size = mesh_size_wing
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
            gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)
        elif part.part_type == "engine":
            part.mesh_size = mesh_size_engines
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
            gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)
        elif part.part_type == "rotor":
            part.mesh_size = mesh_size_propellers
            gmsh.model.mesh.setSize(part.points, part.mesh_size)
            gmsh.model.setColor(part.surfaces, *MESH_COLORS[part.part_type], recursive=False)

    # Set mesh size and color of the farfield
    h_max_model = max(wing_maxlen, fuselage_maxlen)
    mesh_size_farfield = h_max_model * farfield_size_factor

    log.info(f"Farfield mesh size={mesh_size_farfield:.3f} m")

    gmsh.model.mesh.setSize(farfield_points, mesh_size_farfield)
    gmsh.model.setColor(farfield_surfaces, *MESH_COLORS["farfield"], recursive=False)

    if symmetry:
        gmsh.model.setColor(symmetry_surfaces, *MESH_COLORS["symmetry"], recursive=False)

    # Wing leading edge and trailing edge detection
    for part in aircraft_parts:
        if part.part_type == "wing":
            classify_wing(part, aircraft_parts)
            log.info(
                f"Classification of {part.uid} done"
                f" {len(part.wing_sections)} section(s) found "
            )

    # Generate advance meshing features
    if refine_factor != 1:
        mesh_fields = {"nbfields": 0, "restrict_fields": []}
        for part in aircraft_parts:
            if part.part_type == "wing":
                refine_wing_section(
                    mesh_fields,
                    final_domain.volume_tag,
                    aircraft,
                    part,
                    mesh_size_wing,
                    refine=refine_factor,
                    refine_truncated=refine_truncated,
                )

        # Domain mesh
        set_domain_mesh(
            mesh_fields,
            aircraft_parts,
            mesh_size_farfield,
            max(model_dimensions),
            final_domain.volume_tag,
            n_power_factor,
            n_power_field,
        )

        # Generate the minimal background mesh field
        mesh_fields = min_fields(mesh_fields)

    # Mesh generation
    log.info("Start of gmsh 2D surface meshing process")

    gmsh.option.setNumber("Mesh.Algorithm", 6)
    gmsh.option.setNumber("Mesh.LcIntegrationPrecision", 1e-6)

    gmsh.model.occ.synchronize()
    gmsh.logger.start()

    gmsh.model.mesh.generate(1)
    gmsh.model.mesh.generate(2)

    # Control of the mesh quality
    if refine_factor != 1 and auto_refine:
        bad_surfaces = []

        for part in aircraft_parts:
            refined_surfaces, mesh_fields = refine_small_surfaces(
                mesh_fields,
                part,
                mesh_size_farfield,
                max(model_dimensions),
                final_domain.volume_tag,
            )
            bad_surfaces.extend(refined_surfaces)

        if bad_surfaces:
            log.info(f"{len(bad_surfaces)} surface(s) need to be refined")

            # Reset the background mesh
            mesh_fields = min_fields(mesh_fields)

            if open_gmsh:
                log.info("Insufficient mesh size surfaces are displayed in red")
                log.info("GMSH GUI is open, close it to continue...")
                gmsh.fltk.run()

            log.info("Start of gmsh 2D surface remeshing process")

            gmsh.model.mesh.generate(1)
            gmsh.model.mesh.generate(2)

            for surface in bad_surfaces:
                gmsh.model.setColor([(2, surface)], *MESH_COLORS["good_surface"], recursive=False)

            log.info("Remeshing process finished")
            if open_gmsh:
                log.info("Corrected mesh surfaces are displayed in green")

    # Apply smoothing
    log.info("2D mesh smoothing process started")
    gmsh.model.mesh.optimize("Laplace2D", niter=10)
    log.info("Smoothing process finished")

    gmsh.model.occ.synchronize()

    mesh_2d_path = Path(results_dir, "2d_mesh.msh")
    gmsh.write(str(mesh_2d_path))

    if open_gmsh:
        log.info("Result of 2D surface mesh")
        log.info("GMSH GUI is open, close it to continue...")
        gmsh.fltk.run()

    log.info("Start of gmsh 3D volume meshing process")
    gmsh.model.mesh.generate(3)
    gmsh.model.occ.synchronize()

    if rotor_model:
        log.info("Duplicating disk actuator mesh surfaces")
        for part in aircraft_parts:
            if part.part_type == "rotor":
                duplicate_disk_actuator_surfaces(part)

        # option to use when duplicating disk actuator surfaces
        gmsh.option.setNumber("Mesh.SaveAll", 1)

        # Control surface orientation
        control_disk_actuator_normal()

    su2mesh_path = Path(results_dir, "mesh.su2")
    gmsh.write(str(su2mesh_path))

    cgnsmesh_path = Path(results_dir, "mesh.cgns")
    gmsh.write(str(cgnsmesh_path))

    process_gmsh_log(gmsh.logger.get())

    if open_gmsh:
        log.info("Result of the 3D volume mesh")
        log.info("GMSH GUI is open, close it to continue...")
        gmsh.fltk.run()

    log.info("Mesh generation finished")
    # Create duplicated mesh surface for disk actuator

    if not testing_gmsh:
        gmsh.clear()
        gmsh.finalize()
    return su2mesh_path, aircraft_parts


# =================================================================================================
#    MAIN
# =================================================================================================
if __name__ == "__main__":
    print("Nothing to execute!")
