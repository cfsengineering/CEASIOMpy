"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Use .brep files parts of an airplane to generate a fused airplane in GMSH with
the OCC kernel. Then Spherical farfield is created around the airplane and the
resulting domain is meshed using gmsh

Python version: >=3.8

| Author: Guido Vallifuoco
| Creation: 2024-02-01
| Modified: Leon Deligny
| Date: 2025-Feb-28

TODO:

    - It may be good to move all the function and some of the code in generategmsh()
    that are related to disk actuator to another python script and import it here

    - Add mesh sizing for each aircraft part and as consequence add marker

    - Integrate other parts during fragmentation

"""


# =================================================================================================
#   IMPORTS
# =================================================================================================

import os

import gmsh
from ceasiompy.CPACS2GMSH.func.generategmesh import (
    # duplicate_disk_actuator_surfaces,
    # control_disk_actuator_normal,
    # get_entities_from_volume,
    fuselage_size,
    process_gmsh_log,
)
from ceasiompy import log
# from ceasiompy.utils.commonnames import (
#     ACTUATOR_DISK_OUTLET_SUFFIX,
#     ENGINE_EXHAUST_SUFFIX,
#     ENGINE_INTAKE_SUFFIX,
#     GMSH_ENGINE_CONFIG_NAME,
# )
from ceasiompy.utils.ceasiompyutils import bool_, get_reasonable_nb_cpu, get_part_type, run_software
from ceasiompy.CPACS2GMSH.func.cpacs2gmsh_utils import check_path, initialize_gmsh, cfg_rotors
from pathlib import Path
from ceasiompy.CPACS2GMSH.func.generategmesh import ModelPart
from typing import Dict
from cpacspy.cpacspy import CPACS

# from ceasiompy.utils.commonxpath import GMSH_MESH_SIZE_WINGS_XPATH


# =================================================================================================
#   FUNCTIONS
# =================================================================================================


def generate_2d_mesh_for_pentagrow(
    cpacs: CPACS,
    brep_dir: Path,
    results_dir: Path,
    open_gmsh: bool,
    min_max_mesh_factor,
    symmetry: bool = False,
    farfield_size_factor=10,
    n_power_factor=2,
    n_power_field=0.9,
    fuselage_mesh_size_factor=1,
    wing_mesh_size_factor=0.5,
    mesh_size_engines: float = 0.23,
    mesh_size_propellers: float = 0.23,
    refine_factor: float = 2.0,
    refine_truncated: bool = False,
    auto_refine: bool = True,
    testing_gmsh: bool = False,
):
    """
    Returns a mesh file useful for pentagrow.
    The airplane is fused with the different brep files: fuselage, wings etc,
    in order to obtain a watertight volume.

    Args:
        cpacs (CPACS): CPACS file.
        brep_dir (Path): Path to the directory containing the brep files.
        results_dir (Path): Path to the directory containing the result mesh files.
        open_gmsh (bool): Open gmsh GUI after the mesh generation.
        symmetry (bool): Mesh will be generated with symmetry wrt to the x,z plane.

        mesh_size_fuselage : float
            Size of the fuselage mesh
        mesh_size_wings : float
            Size of the wing mesh
        mesh_size_engines : float
            Size of the engine mesh
        mesh_size_propellers : float
            Size of the propeller mesh
        advance_mesh : bool
            If set to true, the mesh will be generated with advanced meshing options
        refine_factor : float
            refine factor for the mesh le and te edge
        refine_truncated : bool
            If set to true, the refinement can change to match the truncated te thickness
        auto_refine : bool
            If set to true, the mesh will be checked for quality
        testing_gmsh : bool
            If set to true, the gmsh sessions will not be clear and killed at the end of
            the function, this allow to test the gmsh feature after the call of generate_gmsh()

    Returns:
        Path: Path to the mesh file generated by gmsh.

    """

    tixi = cpacs.tixi

    # Determine if rotor are present in the aircraft model
    # TODO: add rotor model ?
    # rotor_model = cfg_rotors(brep_dir)

    # Retrieve all brep
    brep_files = sorted(brep_dir.glob("*.brep"))

    # Initialize gmsh
    initialize_gmsh()

    # Import each aircraft original parts / parent parts
    fuselage_volume_dimtags = []
    wings_volume_dimtags = []

    # enginePylons_enginePylon_volume_dimtags = []
    # engine_nacelle_fanCowl_volume_dimtags = []
    # engine_nacelle_coreCowl_volume_dimtags = []
    # vehicles_engines_engine_volume_dimtags = []
    # vehicles_rotorcraft_model_rotors_rotor_volume_dimtags = []

    log.info(f"Importing files from {brep_dir}")
    for brep_file in brep_files:
        # Import the part and create the aircraft part object
        part_entities = gmsh.model.occ.importShapes(str(brep_file), highestDimOnly=False)
        gmsh.model.occ.synchronize()

        # Create the aircraft part object
        part_obj = ModelPart(uid=brep_file.stem)
        part_obj.part_type = get_part_type(cpacs.tixi, part_obj.uid)

        if part_obj.part_type == "fuselage":
            fuselage_volume_dimtags.append(part_entities[0])

        elif part_obj.part_type == "wing":
            wings_volume_dimtags.append(part_entities[0])

        # elif part_obj.part_type == "enginePylons/enginePylon":
        #    enginePylons_enginePylon_volume_dimtags.append(part_entities[0])

        # elif part_obj.part_type == "engine/nacelle/fanCowl":
        #    engine_nacelle_fanCowl_volume_dimtags.append(part_entities[0])

        # elif part_obj.part_type == "engine/nacelle/coreCowl":
        #    engine_nacelle_coreCowl_volume_dimtags.append(part_entities[0])

        # elif part_obj.part_type == "vehicles/engines/engine":
        #    vehicles_engines_engine_volume_dimtags.append(part_entities[0])

        # elif part_obj.part_type == "vehicles/rotorcraft/model/rotors/rotor":
        #    vehicles_rotorcraft_model_rotors_rotor_volume_dimtags.append(part_entities[0])
        # else:
        #    log.warning(f"'{brep_file}' cannot be categorized!")
        #    return None

    gmsh.model.occ.synchronize()

    log.info("Start manipulation to obtain a watertight volume.")
    # we have to obtain a wathertight volume
    gmsh.model.occ.cut(wings_volume_dimtags, fuselage_volume_dimtags, -1, True, False)

    gmsh.model.occ.synchronize()

    gmsh.model.occ.fuse(wings_volume_dimtags, fuselage_volume_dimtags, -1, True, True)

    gmsh.model.occ.synchronize()

    model_bb = gmsh.model.get_bounding_box(
        fuselage_volume_dimtags[0][0], fuselage_volume_dimtags[0][1]
    )

    model_dimensions = [
        abs(model_bb[0] - model_bb[3]),
        abs(model_bb[1] - model_bb[4]),
        abs(model_bb[2] - model_bb[5]),
    ]

    gmsh.model.occ.translate(
        [(3, 1)],
        -((model_bb[0]) + (model_dimensions[0] / 2)),
        -(0),  # the y coordinate is set to zero because sometimes (when act disk
        # actuator is present) the coordinate of the model is not exact
        -((model_bb[2]) + (model_dimensions[2] / 2)),
    )

    gmsh.model.occ.synchronize()
    log.info("Manipulation finished.")

    aircraft_surface_dimtags = gmsh.model.get_entities(2)
    len_aircraft_surface = len(aircraft_surface_dimtags)
    surface = []

    for i in range(len_aircraft_surface):
        tags = aircraft_surface_dimtags[i][1]
        surface.append(tags)

    gmsh.model.add_physical_group(2, surface, -1, name="aircraft_surface")

    # Mesh generation
    log.info("Start of gmsh 2D surface meshing process.")

    gmsh.option.setNumber("Mesh.Algorithm", 6)
    gmsh.option.setNumber("Mesh.LcIntegrationPrecision", 1e-6)
    mesh_size = model_dimensions[0] * float(min_max_mesh_factor) * (10**-3)
    gmsh.option.set_number("Mesh.MeshSizeMin", mesh_size)
    gmsh.option.set_number("Mesh.MeshSizeMax", mesh_size)
    gmsh.option.setNumber("Mesh.StlOneSolidPerSurface", 2)

    gmsh.model.occ.synchronize()
    gmsh.logger.start()
    gmsh.model.mesh.generate(1)
    gmsh.model.mesh.generate(2)

    if bool_(open_gmsh):
        log.info("Result of 2D surface mesh.")
        log.info("GMSH GUI is open, close it to continue...")
        gmsh.fltk.run()

    gmsh.model.occ.synchronize()

    # Add GMSH path
    gmesh_path = Path(results_dir, "mesh_2d.stl")
    gmsh.write(str(gmesh_path))

    process_gmsh_log(gmsh.logger.get())

    fuselage_maxlen, _ = fuselage_size(tixi)

    return gmesh_path, fuselage_maxlen


def pentagrow_3d_mesh(
    result_dir: str,
    cfg_params: Dict,
    surf: str = None,
    angle: str = None,
) -> Path:
    """
    Runs pentagrow.

    Args:
        result_dir (str): Results directory.
        cfg_params (Dict): Configuration parameters for ConfigFile.

    """

    # Create the config file for pentagrow
    config_penta_path = Path(result_dir, "config.cfg")

    # Add cfg_params in config file
    with open(config_penta_path, "w") as file:
        for key, value in cfg_params.items():
            file.write(f"{key} = {value}\n")

    os.chdir("Results/GMSH")

    check_path("mesh_2d.stl")
    check_path("config.cfg")

    current_dir = os.getcwd()
    os.chdir(current_dir)

    command = ["mesh_2d.stl", "config.cfg"]

    # Specify the file path
    file_path = "command.txt"

    with open(file_path, "w") as file:
        file.write(" ".join(command))

    # Running command = "pentagrow mesh_2d.stl config.cfg"
    run_software(
        software_name="pentagrow",
        arguments=command,
        wkdir=current_dir,
        with_mpi=False,
        nb_cpu=get_reasonable_nb_cpu(),
    )

# =================================================================================================
#    MAIN
# =================================================================================================


if __name__ == "__main__":
    log.info("Nothing to execute!")
