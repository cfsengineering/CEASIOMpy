"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Extract results from SU2 calculations and save them in a CPACS file.

| Author: Aidan Jungo
| Creation: 2019-10-02

TODO:
    * Saving for Control surface deflections

"""

# =================================================================================================
#   IMPORTS
# =================================================================================================

import os
import itertools
import pyvista as pv
import numpy as np

from ceasiompy.SU2Run.func.extractloads import extract_loads
from ceasiompy.SU2Run.func.dotderivatives import (
    load_parameters,
    compute_derivatives,
)
from cpacspy.cpacsfunctions import (
    get_value,
    create_branch,
    get_value_or_default,
)
from ceasiompy.utils.ceasiompyutils import (
    bool_,
    get_conditions_from_aeromap,
    ensure_and_append_text_element,
)
from ceasiompy.SU2Run.func.utils import (
    check_one_entry,
    get_wetted_area,
    get_su2_aerocoefs,
    # process_config_dir,
    get_aeromap_uid,
    check_force_file_exists,
    get_efficiency_and_aoa,
    get_su2_forces_moments,
)

from pathlib import Path
from numpy import ndarray
from ambiance import Atmosphere
from typing import (
    List,
    Dict,
    Tuple,
)
from tixi3.tixi3wrapper import Tixi3
from cpacspy.cpacspy import (
    CPACS,
    AeroMap,
)

from ceasiompy import log
from cpacspy.utils import COEFS
from ceasiompy.utils.commonnames import (
    SU2_FORCES_BREAKDOWN_NAME,
    SURFACE_FLOW_FILE_NAME
)
from ceasiompy.utils.commonxpath import (
    AREA_XPATH,
    LENGTH_XPATH,
    GMSH_SYMMETRY_XPATH,
    RANGE_LD_RATIO_XPATH,
    WING_SPAN_XPATH,
    SU2_EXTRACT_LOAD_XPATH,
    SU2_FIXED_CL_XPATH,
    SU2_ROTATION_RATE_XPATH,
    SU2_UPDATE_WETTED_AREA_XPATH,
    WETTED_AREA_XPATH,
    SU2_DAMPING_DER_XPATH,
    SU2_DYNAMICDERIVATIVES_TIMESIZE_XPATH,
    SU2_DYNAMICDERIVATIVES_DATA_XPATH,
)

# =================================================================================================
#   FUNCTIONS
# =================================================================================================


def save_screenshot(surface_flow_file: Path, scalar: str = "Mach") -> Path:
    """
    Save a screenshot as a .png file from a surface_flow .vtu file generated by SU2.

    Args:
        surface_flow_file (Path): Path to the Surface flow file.
        scalar (str = "Mach"): Scalar value represented on the screenshot.

    Returns:
        (Path): Path to the screenshot.

    """

    # Initialize pyvista reader and plotter
    plotter = pv.Plotter(off_screen=True)

    # Read data and send to plotter
    mesh = pv.read(str(surface_flow_file))
    plotter.add_mesh(mesh, scalars=scalar, show_scalar_bar=True)

    # Set camera
    plotter.camera.azimuth = 110.0
    plotter.camera.elevation = -25.0
    plotter.camera.zoom(1.6)

    # Save Screenshot
    screenshot_path = Path(surface_flow_file.parent, f"3d_view_{scalar}.png")
    plotter.show(screenshot=screenshot_path)

    log.info(f"A screenshot has been saved at {screenshot_path}.")
    return screenshot_path


def get_value_at(i: int, *lists: List[float]) -> Tuple[float, ...]:
    return tuple(lst[i] for lst in lists)


def update_wetted_area_func(tixi: Tixi3, config_dir: Path) -> None:
    wetted_area = get_wetted_area(Path(config_dir, "no_deformation", "logfile_SU2_CFD.log"))

    # Check if symmetry plane is defined (Default: False)
    sym_factor = 1.0
    if get_value_or_default(tixi, GMSH_SYMMETRY_XPATH, False):
        log.info("Symmetry plane is defined. Multiplying wetted area by 2.")
        sym_factor = 2.0

    create_branch(tixi, WETTED_AREA_XPATH)
    tixi.updateDoubleElement(WETTED_AREA_XPATH, wetted_area * sym_factor, "%g")


def update_damping_derivatives(
    tixi: Tixi3,
    config_dir: Path,
    aeromap: AeroMap,
    alt: float,
    mach: float,
    aoa: float,
    aos: float,
    coefs: Dict,
    velocity: float,
) -> None:
    rotation_rate = get_value(tixi, SU2_ROTATION_RATE_XPATH)
    ref_len = tixi.getTextElement(WING_SPAN_XPATH)
    adim_rot_rate = rotation_rate * ref_len / velocity

    for axis in ["dp", "dq", "dr"]:
        if f"_{axis}" not in config_dir.name:
            continue

        for coef in COEFS:
            coef_baseline = aeromap.get(coef, alt=alt, mach=mach, aoa=aoa, aos=aos)
            dcoef = (coefs[coef] - coef_baseline) / adim_rot_rate
            aeromap.add_damping_derivatives(
                alt=alt,
                mach=mach,
                aoa=aoa,
                aos=aos,
                coef=coef,
                axis=axis,
                value=dcoef,
                rate=rotation_rate,
            )


def update_fixed_cl(tixi: Tixi3, aeromap: AeroMap, force_file_path: Path) -> None:
    cl_cd, aoa = get_efficiency_and_aoa(force_file_path)

    # Replace aoa with the with the value from fixed cl calculation
    aeromap.df.loc[0, ["angleOfAttack"]] = aoa

    # Save cl/cd found during the fixed CL calculation (useful for range analysis)
    create_branch(tixi, RANGE_LD_RATIO_XPATH)
    tixi.updateDoubleElement(RANGE_LD_RATIO_XPATH, cl_cd, "%g")


def save_screenshots(config_dir: Path):
    surface_flow_path = Path(config_dir, SURFACE_FLOW_FILE_NAME)
    if surface_flow_path.exists() and "DISPLAY" in os.environ:
        save_screenshot(surface_flow_path, "Mach")
        save_screenshot(surface_flow_path, "Pressure_Coefficient")


def get_static_results(
    tixi: Tixi3,
    aeromap: AeroMap,
    config_dir: Path,
    fixed_cl: str,
    found_wetted_area: bool,
) -> None:
    save_screenshots(config_dir)
    force_file_path = check_force_file_exists(config_dir)
    case_nb = int(config_dir.name.split("_")[0].split("Case")[1])

    alt_list, mach_list, aoa_list, aos_list = get_conditions_from_aeromap(aeromap)
    aoa, aos, mach, alt = get_value_at(case_nb, aoa_list, aos_list, mach_list, alt_list)

    if fixed_cl == "YES":
        update_fixed_cl(tixi, aeromap, force_file_path)

    # Load aerocoefs
    cl, cd, cs, cmd, cms, cml, velocity = get_su2_aerocoefs(force_file_path)

    # Damping derivatives
    if bool_(get_value(tixi, SU2_DAMPING_DER_XPATH)):
        coefs = {"cl": cl, "cd": cd, "cs": cs, "cmd": cmd, "cms": cms, "cml": cml}
        update_damping_derivatives(
            tixi,
            config_dir,
            aeromap,
            alt, mach, aoa, aos,
            coefs, velocity,
        )
    # Baseline coefficients (no damping derivatives)
    else:
        aeromap.add_coefficients(
            alt=alt, mach=mach, aos=aos, aoa=aoa,
            cd=cd, cl=cl, cs=cs,
            cml=cml, cmd=cmd, cms=cms,
        )

    if "_TED_" in config_dir.name:
        # TODO: convert when it is possible to save TED in cpacspy
        raise NotImplementedError("TED not implemented yet")

    update_wetted_area = bool_(get_value(tixi, SU2_UPDATE_WETTED_AREA_XPATH))
    if not found_wetted_area and update_wetted_area:
        update_wetted_area_func(tixi, config_dir)
        found_wetted_area = True

    if bool_(get_value(tixi, SU2_EXTRACT_LOAD_XPATH)):
        extract_loads(config_dir)


def get_dynamic_force_files(file_path: Path) -> Path:
    # Get results from dynstab
    force_file_paths = list(
        Path(file_path).glob("forces_breakdown_*.dat")
    )

    if not force_file_paths:
        raise OSError("No result force file have been found!")
    return force_file_paths


def compute_dynamic_coefs(
    tixi: Tixi3,
    forces_coef_list: List,
    moments_coef_list: List,
    f_static: ndarray,
    m_static: ndarray,
    alt: float,
    mach: float,
    s: float,
    b: float,
    c: float,
) -> Tuple[float, float, float, float]:
    # Convert the list to a numpy array
    f_time = np.array(forces_coef_list)
    m_time = np.array(moments_coef_list)

    # Compute derivatives
    a, omega, _, t = load_parameters(tixi)
    fx, fy = compute_derivatives(a, omega, t, f_time, f_static)
    mx, my = compute_derivatives(a, omega, t, m_time, m_static)

    # Velocity in m/s in atmospheric environment
    Atm = Atmosphere(alt)
    velocity = Atm.speed_of_sound[0] * mach

    # Dynamic pressure
    q_dyn = Atm.density[0] * (velocity ** 2) / 2.0

    qs = q_dyn * s
    qsb = qs * b
    qsc = qs * c

    # Scale forces accordingly
    cfx = fx / qs
    cfy = fy / qs

    # Scale moments accordingly
    cmx = np.copy(mx)
    cmy = np.copy(my)
    cmx[[0, 2], ] /= qsb
    cmx[1, ] /= qsc
    cmy[[0, 2], ] /= qsb
    cmy[1, ] /= qsc
    log.info(f"q {q_dyn} fx {fx} mx {mx}, cfx {cfx} cmx {cmx}")

    return cfx, cfy, cmx, cmy


def add_dynamic_coefs(
    tixi: Tixi3,
    mach: str,
    alt: str,
    angle: str,
    cfx: str,
    cfy: str,
    cmx: str,
    cmy: str,
) -> None:
    # Put derivatives in CPACS at SU2 in DynamicDerivatives
    xpath = SU2_DYNAMICDERIVATIVES_DATA_XPATH

    # Ensure the path exists
    create_branch(tixi, xpath)

    ensure_and_append_text_element(tixi, xpath, "mach", str(mach))
    ensure_and_append_text_element(tixi, xpath, "alt", str(alt))

    ensure_and_append_text_element(
        tixi, xpath, f"cf_{angle}", cfx,
    )
    ensure_and_append_text_element(
        tixi, xpath, f"cf_{angle}_prim", cfy,
    )
    ensure_and_append_text_element(
        tixi, xpath, f"cm_{angle}", cmx,
    )
    ensure_and_append_text_element(
        tixi, xpath, f"cm_{angle}_prim", cmy,
    )


def get_dynstab_results(tixi: Tixi3, dict_dir: Dict) -> None:
    # Extract unique mach and alt values
    mach_values = list(set(d['mach'] for d in dict_dir))
    alt_values = list(set(d['alt'] for d in dict_dir))
    n = int(get_value(tixi, SU2_DYNAMICDERIVATIVES_TIMESIZE_XPATH))
    b: float = tixi.getDoubleElement(AREA_XPATH)
    c: float = tixi.getDoubleElement(LENGTH_XPATH)
    s: float = b / c

    for mach, alt in itertools.product(mach_values, alt_values):
        none_file = check_one_entry(dict_dir, mach, alt, "none")
        alpha_file = check_one_entry(dict_dir, mach, alt, "alpha")
        # beta_file = check_one_entry(dict_dir, "beta")

        angle_file = {
            "alpha": alpha_file / "no_deformation"
        }  # "beta": beta_file

        # Retrieve forces and moments for (alpha, alpha_dot) = (0, 0)
        none_force_file_path = Path(
            none_file, "no_deformation", SU2_FORCES_BREAKDOWN_NAME
        )

        (
            cfx_0, cfy_0, cfz_0,
            cmx_0, cmy_0, cmz_0,

        ) = get_su2_forces_moments(none_force_file_path)

        log.info(
            f"cfx_0: {cfx_0}, cfy_0: {cfy_0}, cfz_0: {cfz_0}, "
            f"cmx_0: {cmx_0}, cmy_0: {cmy_0}, cmz_0: {cmz_0}"
        )

        # Force
        f_static = np.tile([
            cfx_0, cfy_0, cfz_0,
        ], (n, 1))

        # Moments
        m_static = np.tile([
            cmx_0, cmy_0, cmz_0
        ], (n, 1))

        # Retrive forces and moments for (alpha, alpha_dot) = (alpha(t), alpha_dot(t))
        for angle in ['alpha']:  # , 'beta'
            force_file_paths = get_dynamic_force_files(angle_file[angle])
            forces_coef_list, moments_coef_list = [], []

            for force_file_path in force_file_paths:
                # Access coefficients
                cfx, cfy, cfz, cmx, cmy, cmz = get_su2_forces_moments(
                    force_file_path
                )
                forces_coef_list.append([cfx, cfy, cfz])
                moments_coef_list.append([cmx, cmy, cmz])

            cfx, cfy, cmx, cmy = compute_dynamic_coefs(
                tixi,
                forces_coef_list,
                moments_coef_list,
                f_static,
                m_static,
                alt,
                mach,
                s,
                b,
                c,
            )

            # Add them in the CPACS
            add_dynamic_coefs(
                tixi, mach, alt, angle,
                str(cfx), str(cfy), str(cmx), str(cmy),
            )


def get_su2_results(cpacs: CPACS, wkdir: Path) -> None:
    """
    Updates CPACS file with SU2 results.

    Updates Aeromap at xPath:
    '/cpacs/vehicles/aircraft/model/analyses/aeroPerformance/aeroMap[n]/aeroPerformanceMap'

    """
    tixi = cpacs.tixi
    found_wetted_area = False

    fixed_cl = get_value(tixi, SU2_FIXED_CL_XPATH)
    aeromap_uid = get_aeromap_uid(tixi, fixed_cl)
    aeromap: AeroMap = cpacs.get_aeromap_by_uid(aeromap_uid)

    case_dir_list = [
        case_dir
        for case_dir in wkdir.iterdir()
        if ("Case" in case_dir.name) and (case_dir.is_dir())
    ]

    # dict_dir: List[Dict] = []

    for config_dir in sorted(case_dir_list):
        # process_config_dir(config_dir, dict_dir)

        # Retrieve non dynamic stability data
        if "dynstab" not in str(config_dir):
            get_static_results(
                tixi,
                aeromap,
                config_dir,
                fixed_cl,
                found_wetted_area
            )

    aeromap.save()


# =================================================================================================
#    MAIN
# =================================================================================================


if __name__ == "__main__":
    log.info("Nothing to execute!")
