<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libQGLViewer: QGLViewer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" href="../images/qglviewer.ico" type="image/x-icon" /><link rel="icon" href="../images/qglviewer.icon.png" type="image/png" />
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>

    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>QGLViewer Class Reference</h1><!-- doxytag: class="QGLViewer" -->A versatile 3D OpenGL viewer based on QGLWidget.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classQGLViewer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Keyboard customization</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a> { <br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1a9c213a1cf39290bfcad5d6813d2395d">DRAW_AXIS</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c19891606ac8b160f15d3e705f7d192604">DRAW_GRID</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c17522d8401eb437769071ba3b1562ca97">DISPLAY_FPS</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1f12e793187e1edaf1e236818225b9e0e">ENABLE_TEXT</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c17ff2639b181c08e5d9196a0303a72cd1">EXIT_VIEWER</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c11e9b410aa72809cf30d86b2d34ee7239">SAVE_SCREENSHOT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c191b759170cb0389695a3c219a9a69073">CAMERA_MODE</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c14750f7f8fc87e44b233c6186713f8e59">FULL_SCREEN</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1a0cd9874b7ec35409aa4ef363b818a4e">STEREO</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1f3b49771c99e24d1407f9fc662fc7a6f">ANIMATION</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c19f5cb747b2e1f0ea781d2b1f2a5b4824">HELP</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c197ed373cfcaeadc41c6975357bbc17df">EDIT_CAMERA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1c71e3cca6e8031a8c05944d15f257b30">MOVE_CAMERA_LEFT</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1dee5dcac0e4f4dfe9190a769f3575a63">MOVE_CAMERA_RIGHT</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1eaca3cc65bb13383b55ff6704f80adeb">MOVE_CAMERA_UP</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1e8ffd7bbd8e032bf43298331a6525274">MOVE_CAMERA_DOWN</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c10f5233365123b2f88633907040a95a5a">INCREASE_FLYSPEED</a>, 
<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1595e91c7270892a31306f01e105c1dd8">DECREASE_FLYSPEED</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#b6dd5b47ea7d89e1f86c05c58d25c11d">shortcut</a> (<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a> action) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Qt::Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#dfe21e109b45f8c79f2c360bf35fb835">pathKey</a> (int index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Qt::KeyboardModifiers&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7c91f5b77f92266cff3fe4ef99847b93">addKeyFrameKeyboardModifiers</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Qt::KeyboardModifiers&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#02cb4ab51746a7bb14d1fab077e94ea7">playPathKeyboardModifiers</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut</a> (<a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a> action, int key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription</a> (int key, QString description)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#da7e68536b6593f8a8bde9a746c99c13">setPathKey</a> (int key, int index=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7c941d66cf641971ef0bb99e998290dc">setPlayPathKeyboardModifiers</a> (Qt::KeyboardModifiers modifiers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a9a5108680fffd096a3e086a3b8b45d4">setAddKeyFrameKeyboardModifiers</a> (Qt::KeyboardModifiers modifiers)</td></tr>

<tr><td colspan="2"><br><h2>Mouse customization</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> { <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a>, 
<a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">ClickAction</a> { <br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8fed60c81bb5edd0570ff12ac8a0e2b604">NO_CLICK_ACTION</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8fc7b18b21c4c8f1eeb5d54bf1b7919db4">ZOOM_ON_PIXEL</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8fb1efbb77356f16254fd4a62e1236b531">ZOOM_TO_FIT</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f1697a91b22c2369eb2ba427c2d193329">SELECT</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f6423101303db857a4217e8e66606128a">RAP_FROM_PIXEL</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f131d4a2b38607d5d753c4fe19884a9cc">RAP_IS_CENTER</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8fbf4ad7098f468bfaf170fd5e16902929">CENTER_FRAME</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f23a1d829d84b71f5aa5a0e19385e8ce7">CENTER_SCENE</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f3f717d1605f3ca83254beb93ea399ddc">SHOW_ENTIRE_SCENE</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f3d318f59bc81979e3922c7e716085304">ALIGN_FRAME</a>, 
<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f35685e5c7e681c3c0eb079e4f132a82a">ALIGN_CAMERA</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a> { <br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753b20d5f27f63af5ea6e5b6af1112ecf8">NO_MOUSE_ACTION</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753dcfe0046eb5876e287dbf0914819b16">ROTATE</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201">ZOOM</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875bc6501410409b0638909b580970b35f7">TRANSLATE</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef87599906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef87521fa52d8ef1574dce79cab9ddbb6cd73">LOOK_AROUND</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875b3313fc5887b62fd14b36f1d67903e08">MOVE_BACKWARD</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875410b0fa7f49e7eedd6d739db37c67209">SCREEN_ROTATE</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8752eeb9fef8a6a516fa6437a44a6efbd52">ROLL</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875f7b6d6d8e5e14633d388ef9cc7a941b7">DRIVE</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753de224b064ad81a76d8739cf288543a3">SCREEN_TRANSLATE</a>, 
<a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875fbac98d470c69690e178ff5ab9ad504d">ZOOM_ON_REGION</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3bc7b6c4d3ca76c0faecfdbfd2ede69a">mouseAction</a> (int state) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3d400c0d0a5824e70d36b01f9b7211c1">mouseHandler</a> (int state) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#5e9d4c07afc73f5c8a0926641e1428ac">mouseButtonState</a> (<a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">ClickAction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#77651b87caa33aaa234457b1ef784e2a">clickAction</a> (int state, bool doubleClick, Qt::MouseButtons buttonsBefore) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#0fbf5d9d33985397f382ee2706c5898b">getClickButtonState</a> (<a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">ClickAction</a> action, int &amp;state, bool &amp;doubleClick, Qt::MouseButtons &amp;buttonsBefore) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aeb802e1db589dad89db8300e82454f4">wheelAction</a> (Qt::KeyboardModifiers modifiers) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#24751ec23d337eb0fb9851e8cb140502">wheelHandler</a> (Qt::KeyboardModifiers modifiers) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#253566e1950c2c0cfe69bdb6c42258d6">wheelButtonState</a> (<a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding</a> (int state, <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3225418600cc93fb968e11ce195bee2d">setMouseBinding</a> (int state, <a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">ClickAction</a> action, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#2e1e005bde20f65b7269e2dd4e978306">setMouseBindingDescription</a> (int state, QString description, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#4198b3b668c342e39752bade04f78c64">setWheelBinding</a> (Qt::KeyboardModifiers modifiers, <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#0f709bcb22461a4e9df78de2821b9c80">setHandlerKeyboardModifiers</a> (<a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, Qt::KeyboardModifiers modifiers)</td></tr>

<tr><td colspan="2"><br><h2>Display of visual hints</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7d38e6f11078e886f7978525def15797">axisIsDrawn</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ee18c56a8321a60771b085a5fe798ee7">gridIsDrawn</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#87896d67f84ddb458e1e5ab326db2631">textIsEnabled</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn</a> (bool draw=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#e9dd114195dfdf82e23b5754b7c161de">setGridIsDrawn</a> (bool draw=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed</a> (bool display=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#73d76caa402acd217e504d0bcd13e421">setTextIsEnabled</a> (bool enable=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#521c83b1d745b37331932b4d7b976d41">setCameraIsEdited</a> (bool edit=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#cf2ccb8a346c04a5c7da87da0e8e601f">toggleAxisIsDrawn</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#8dfaa8be71152ae881b9347235ccc6a1">toggleGridIsDrawn</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#b8a88948237894dca2b7b57a67226d66">toggleFPSIsDisplayed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#b92b2b41db85e4347675b0bc453366d7">toggleTextIsEnabled</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3a53b30eacfccf0825b808977d634936">toggleCameraIsEdited</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Viewer's colors</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">QColor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7ddf68dcfb09cc5a991a06d91cb4cc5b">backgroundColor</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">QColor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a2f726def3615050a9c816c0ca32171d">foregroundColor</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor</a> (const QColor &amp;color)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7d986b1944dc5a190e509835e7c79eec">setForegroundColor</a> (const QColor &amp;color)</td></tr>

<tr><td colspan="2"><br><h2>Scene dimensions</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#5a0503bc22a710f96bfd779eaf538bab">sceneCenter</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ef99f105486d457f0199fcc35181fa83">setSceneRadius</a> (float radius)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#6712acd05f9d518d6babfe96e537d06d">setSceneCenter</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;center)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a8339148d876e633c27e5df826f06c9c">setSceneBoundingBox</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;min, const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;max)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#da8dd7d2346ebf46ed1f9822a8418df2">showEntireScene</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Associated objects</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#9c45e1d2c4777de28664d3db952b7585">setCamera</a> (<a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *const camera)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#c6964ec1ebb2f42464313e0c43e767a3">setManipulatedFrame</a> (<a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *frame)</td></tr>

<tr><td colspan="2"><br><h2>Mouse grabbers</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3f0b956f948f469c095ff3c2c1b73494">setMouseGrabberIsEnabled</a> (const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const mouseGrabber, bool enabled=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#5fe9b0a1fcd39a5cb132ffdc86f2574f">mouseGrabberIsEnabled</a> (const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const mouseGrabber)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#993285ef8a16ccbdc5d57a1264212712">setMouseGrabber</a> (<a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *mouseGrabber)</td></tr>

<tr><td colspan="2"><br><h2>State of the viewer</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#915589f4d93e15d110444ed9b3464fa1">aspectRatio</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#6fde4d85dfc5338aa237ba1eb505e975">currentFPS</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#129c439f36bb669672148192abc8ffed">isFullScreen</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QSize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#d8288a17cf54658f1ce1c0db9e97dc8a">sizeHint</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7e021e15180ba348e90c955bdd28b1a4">setFullScreen</a> (bool fullScreen=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#fe362ba5c3851a93f23fb833b2479f08">setStereoDisplay</a> (bool stereo=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5b47397e4ad7c2bb9573e0d186170e0">toggleFullScreen</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#4e0ebf98eacbcbad3b094e26d9e35886">toggleStereoDisplay</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#17ea00dd30fb78086cf7e22bc2f10695">toggleCameraMode</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Display methods</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem</a> (bool upward=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#9cff22af974391604bff7f91df789138">stopScreenCoordinatesSystem</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText</a> (int x, int y, const QString &amp;text, const QFont &amp;fnt=QFont())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#61336516f9771ac6aef90875f848add4">displayMessage</a> (const QString &amp;message, int delay=2000)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#14fc47f313bbb65c38d2a8ae754215e0">drawArrow</a> (float length=1.0f, float radius=-1.0f, int nbSubdivisions=12)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#27edb1331c7bf373d126487e9547969f">drawArrow</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;from, const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;to, float radius=-1.0f, int nbSubdivisions=12)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#f18c0661b9a86e6b07ae344e05979c4c">drawAxis</a> (float length=1.0f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#d4a4d99fabe53083099c70439bc3564d">drawGrid</a> (float size=1.0f, int nbSubdivisions=10)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#2a3b971fe826a90efaffcb7c68fdcc53">drawLight</a> (GLenum light, float scale=1.0f) const </td></tr>

<tr><td colspan="2"><br><h2>Useful inherited methods</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#369399896761e31ae71db57fdd0ba431">width</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#e26bcfe2f33f5873dbdfb6948cf1f59f">height</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#e12b7378efbffabc24a133ca1deb19ae">updateGL</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#8911f3aec33c17d1eba4390436b5c868">qglColor</a> (const QColor &amp;color) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#88b363f05e720484cde551d5f798e69b">qglClearColor</a> (const QColor &amp;color) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ac1b70a2ed67ead038c4d3f5ac4d8a81">isValid</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#514d24ec3ec6c94657ef302a2b3fa74a">isSharing</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#1436277e13026c94601bbe37a2f1d262">makeCurrent</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#47c0968a61bcd23c491817631e4ec953">hasMouseTracking</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#d1185e99a9efec124b7a9bede84a6cf1">resize</a> (int width, int height)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#cf0a4ee197fe91b8c07dd74cad1aafaa">setMouseTracking</a> (bool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static QImage&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#75679575b3b071cddce2a56c77e1bd68">convertToGLFormat</a> (const QImage &amp;image)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#36faca915c37548a53ab04f297bb5c17">autoBufferSwap</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#d95e0ffd255bcc1fb69c9213d8d8b017">setAutoBufferSwap</a> (bool on)</td></tr>

<tr><td colspan="2"><br><h2>Snapshots</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const QString &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const QString &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#bbb1add55632dced395e2f1b78ef491c">snapshotFormat</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#50685165e76c57dc87dea3c84b7e5be0">snapshotQuality</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot</a> (bool automatic=true, bool overwrite=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#82544567565cfa0b750cb24ac1aa8358">saveSnapshot</a> (const QString &amp;fileName, bool overwrite=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a15be68d137eca013942eae69e40e0ee">setSnapshotFileName</a> (const QString &amp;name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#82043998256d08163f79ceee83278e14">setSnapshotFormat</a> (const QString &amp;format)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#feb307bbd1a56cdfb3749f699d4af03c">setSnapshotCounter</a> (int counter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#b64b04b76b1f35ee1b3f07fa747dc9a0">setSnapshotQuality</a> (int quality)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#c9c409fd034bc5ab42aacfa4c23fe55c">openSnapshotFormatDialog</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Buffer to texture</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GLuint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#6435e0a64e14d04dce25e524051f8d69">bufferTextureId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#c60a0831696a80344fd04b2fba039f48">bufferTextureMaxU</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#8d3ecfdb46f8971e46a0ab0f52c5bbf7">bufferTextureMaxV</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#eb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture</a> (GLint internalFormat, GLenum format=GL_NONE)</td></tr>

<tr><td colspan="2"><br><h2>Animation</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#700d9398d4293d9274766efa8b17917e">animationPeriod</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a37d4e0afe6a47e8f4f828ed41072176">setAnimationPeriod</a> (int period)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#d5344a5f702678f309fafa0c699b2cf3">startAnimation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#84c1367b486680bcf22987540e217cfb">stopAnimation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#67be4f5d4065852e7f46a2fc6197c070">toggleAnimation</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Help window</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#38ddb3cdf15e24de824a2d7a170ec915">helpString</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#6d66b99a4c5a38ef0072f350b055201b">mouseString</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#0e20e13c1170d50b46b6fe2a49377690">keyboardString</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#f08b8ca0f43910754ecd5d314e3febf0">aboutQGLViewer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">QTabWidget *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#f3af989be04f1d45b6ff3f748c2e9d4a">helpWidget</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Object selection</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#0015a8bc683c3a1483c5ad638550bdde">selectedName</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#13e131ca92b021fb8946a9af0b0c269d">selectBufferSize</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#db0b15577ca9bcabc99c78601cfce59f">selectRegionHeight</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GLuint *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select</a> (const QMouseEvent *event)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#f2ed82c063635ce439d9c73223e20fd6">select</a> (const QPoint &amp;point)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#e8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize</a> (int size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#0bfc48a72feefc6c90bd187280853911">setSelectRegionWidth</a> (int width)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#e830757057c41db506410fd3c332d7dd">setSelectRegionHeight</a> (int height)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#eaa1327270d0bcdf991874e7d741afd5">setSelectedName</a> (int id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#f0a48cc50f194926bad38d4924162116">beginSelection</a> (const QPoint &amp;point)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection</a> (const QPoint &amp;point)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection</a> (const QPoint &amp;point)</td></tr>

<tr><td colspan="2"><br><h2>State persistence</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QDomElement&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#48e0e2dd26cd96418c8b889ceabe80f6">domElement</a> (const QString &amp;name, QDomDocument &amp;document) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#cd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement</a> (const QDomElement &amp;element)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#68737cce3d7301701bca6e4270a5a34e">setStateFileName</a> (const QString &amp;name)</td></tr>

<tr><td colspan="2"><br><h2>QGLViewer pool</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const QList&lt; QGLViewer * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#32d7a506084c50fd97a24f94d9ca4864">QGLViewerPool</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#9570ddcbaab08bce6f121e69db4fb903">QGLViewerIndex</a> (const QGLViewer *const viewer)</td></tr>

<tr><td colspan="2"><br><h2>Drawing methods</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3efe88f982dbec7825725dd954991139">resizeGL</a> (int width, int height)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#2d3d45239c78255c23a70ca558b4d4f1">initializeGL</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#c5cbfafb28ef4c0474ae96437294f547">paintGL</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#43df4754781c2aaf3236d676401cec59">preDrawStereo</a> (bool leftBuffer=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#8b6601997fe7a83e7cd041104d4b21d2">fastDraw</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#24f5dce22199f5eea71f034cae6ae4fa">postDraw</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Mouse, keyboard and event handlers</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#991f0a076bd76a1ee5bda0df7fa474f4">mousePressEvent</a> (QMouseEvent *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent</a> (QMouseEvent *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#158642bef03883cc4157b8b40e1aa0ea">mouseReleaseEvent</a> (QMouseEvent *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a11ba8137b62942cede01c57aade3073">mouseDoubleClickEvent</a> (QMouseEvent *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#bc61c05ed30a94d66ab715c718532c03">wheelEvent</a> (QWheelEvent *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#2cc4c898ca007c7cc0ebb7791aa3e5b3">keyPressEvent</a> (QKeyEvent *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#cd355cb527aec563bbefc75edc9deffd">timerEvent</a> (QTimerEvent *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#3fb8c90e5c48e6ccc09f9125aa86943e">closeEvent</a> (QCloseEvent *)</td></tr>

<tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#252b68caec768d882a3fa78ecd1499db">viewerInitialized</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#7a712ca70a0b1c22af51363b786fc86e">drawNeeded</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#fc74e28548768da157f2fe75bced2803">drawFinished</a> (bool automatic)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#841503c97db5a51e33f8a7e56d4ca006">animateNeeded</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#64f461121859dc0c19e7af2d413935e0">helpRequired</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#541cdbec67d0c5895cd6c77c01b0f89e">axisIsDrawnChanged</a> (bool drawn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#02d191cc46db491d9807266fe62b6178">gridIsDrawnChanged</a> (bool drawn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#4b005fb3bda4582ce4ab7aeda6692699">FPSIsDisplayedChanged</a> (bool displayed)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#c0b30c0de291a24af638e8c1d6171943">textIsEnabledChanged</a> (bool enabled)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#38968d2f050efa14869c2e4de416b7b4">cameraIsEditedChanged</a> (bool edited)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#9d7df8ab7c351e32da3c72b19c4585c0">stereoChanged</a> (bool on)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#b78f96913c9aede4854b0efccf53f983">pointSelected</a> (const QMouseEvent *e)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#959ca6df1731d57aa692af99abcd28d1">mouseGrabberChanged</a> (<a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *mouseGrabber)</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#1a30c8c6e5166bc2eb82d599351d7712">QGLViewer</a> (QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WFlags flags=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#f38a060fc322d6381e28245b2a05a880">QGLViewer</a> (QGLContext *context, QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WFlags flags=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#172fc2a1bb06b7811576a6eaff46ec90">QGLViewer</a> (const QGLFormat &amp;format, QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WFlags flags=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#8c90239e64b7a43473a189d5da865ac7">~QGLViewer</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A versatile 3D OpenGL viewer based on QGLWidget. 
<p>
It features many classical viewer functionalities, such as a camera trackball, manipulated objects, snapshot saving and much <a href="../features.html">more</a>. Its main goal is to ease the development of new 3D applications.<p>
New users should read the <a href="../introduction.html">introduction page</a> to get familiar with important notions such as <a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>, <a class="el" href="classQGLViewer.html#5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a> and the world coordinate system. Try the numerous simple <a href="../examples/index.html">examples</a> to discover the possibilities and understand how it works.<p>
<h3>Usage</h3>
<p>
To use a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>, derive you viewer class from the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> and overload its <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> virtual method. See the <a href="../examples/simpleViewer.html">simpleViewer example</a> for an illustration.<p>
An other option is to connect your drawing methods to the signals emitted by the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> (Qt's callback mechanism). See the <a href="../examples/callback.html">callback example</a> for a complete implementation. <hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1"></a><!-- doxytag: member="QGLViewer::KeyboardAction" ref="7a90ec0b49f9586addb5eed9026077c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the different actions that can be associated with a keyboard shortcut using <a class="el" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut()</a>.<p>
See the <a href="../keyboard.html">keyboard page</a> for details. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1a9c213a1cf39290bfcad5d6813d2395d"></a><!-- doxytag: member="DRAW_AXIS" ref="7a90ec0b49f9586addb5eed9026077c1a9c213a1cf39290bfcad5d6813d2395d" args="" -->DRAW_AXIS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c19891606ac8b160f15d3e705f7d192604"></a><!-- doxytag: member="DRAW_GRID" ref="7a90ec0b49f9586addb5eed9026077c19891606ac8b160f15d3e705f7d192604" args="" -->DRAW_GRID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c17522d8401eb437769071ba3b1562ca97"></a><!-- doxytag: member="DISPLAY_FPS" ref="7a90ec0b49f9586addb5eed9026077c17522d8401eb437769071ba3b1562ca97" args="" -->DISPLAY_FPS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1f12e793187e1edaf1e236818225b9e0e"></a><!-- doxytag: member="ENABLE_TEXT" ref="7a90ec0b49f9586addb5eed9026077c1f12e793187e1edaf1e236818225b9e0e" args="" -->ENABLE_TEXT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c17ff2639b181c08e5d9196a0303a72cd1"></a><!-- doxytag: member="EXIT_VIEWER" ref="7a90ec0b49f9586addb5eed9026077c17ff2639b181c08e5d9196a0303a72cd1" args="" -->EXIT_VIEWER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c11e9b410aa72809cf30d86b2d34ee7239"></a><!-- doxytag: member="SAVE_SCREENSHOT" ref="7a90ec0b49f9586addb5eed9026077c11e9b410aa72809cf30d86b2d34ee7239" args="" -->SAVE_SCREENSHOT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c191b759170cb0389695a3c219a9a69073"></a><!-- doxytag: member="CAMERA_MODE" ref="7a90ec0b49f9586addb5eed9026077c191b759170cb0389695a3c219a9a69073" args="" -->CAMERA_MODE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c14750f7f8fc87e44b233c6186713f8e59"></a><!-- doxytag: member="FULL_SCREEN" ref="7a90ec0b49f9586addb5eed9026077c14750f7f8fc87e44b233c6186713f8e59" args="" -->FULL_SCREEN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1a0cd9874b7ec35409aa4ef363b818a4e"></a><!-- doxytag: member="STEREO" ref="7a90ec0b49f9586addb5eed9026077c1a0cd9874b7ec35409aa4ef363b818a4e" args="" -->STEREO</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1f3b49771c99e24d1407f9fc662fc7a6f"></a><!-- doxytag: member="ANIMATION" ref="7a90ec0b49f9586addb5eed9026077c1f3b49771c99e24d1407f9fc662fc7a6f" args="" -->ANIMATION</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c19f5cb747b2e1f0ea781d2b1f2a5b4824"></a><!-- doxytag: member="HELP" ref="7a90ec0b49f9586addb5eed9026077c19f5cb747b2e1f0ea781d2b1f2a5b4824" args="" -->HELP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c197ed373cfcaeadc41c6975357bbc17df"></a><!-- doxytag: member="EDIT_CAMERA" ref="7a90ec0b49f9586addb5eed9026077c197ed373cfcaeadc41c6975357bbc17df" args="" -->EDIT_CAMERA</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1c71e3cca6e8031a8c05944d15f257b30"></a><!-- doxytag: member="MOVE_CAMERA_LEFT" ref="7a90ec0b49f9586addb5eed9026077c1c71e3cca6e8031a8c05944d15f257b30" args="" -->MOVE_CAMERA_LEFT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1dee5dcac0e4f4dfe9190a769f3575a63"></a><!-- doxytag: member="MOVE_CAMERA_RIGHT" ref="7a90ec0b49f9586addb5eed9026077c1dee5dcac0e4f4dfe9190a769f3575a63" args="" -->MOVE_CAMERA_RIGHT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1eaca3cc65bb13383b55ff6704f80adeb"></a><!-- doxytag: member="MOVE_CAMERA_UP" ref="7a90ec0b49f9586addb5eed9026077c1eaca3cc65bb13383b55ff6704f80adeb" args="" -->MOVE_CAMERA_UP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1e8ffd7bbd8e032bf43298331a6525274"></a><!-- doxytag: member="MOVE_CAMERA_DOWN" ref="7a90ec0b49f9586addb5eed9026077c1e8ffd7bbd8e032bf43298331a6525274" args="" -->MOVE_CAMERA_DOWN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c10f5233365123b2f88633907040a95a5a"></a><!-- doxytag: member="INCREASE_FLYSPEED" ref="7a90ec0b49f9586addb5eed9026077c10f5233365123b2f88633907040a95a5a" args="" -->INCREASE_FLYSPEED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7a90ec0b49f9586addb5eed9026077c1595e91c7270892a31306f01e105c1dd8"></a><!-- doxytag: member="DECREASE_FLYSPEED" ref="7a90ec0b49f9586addb5eed9026077c1595e91c7270892a31306f01e105c1dd8" args="" -->DECREASE_FLYSPEED</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="5b90ab220b7700ca28db5ecf3217325d"></a><!-- doxytag: member="QGLViewer::MouseHandler" ref="5b90ab220b7700ca28db5ecf3217325d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the different mouse handlers: <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> or <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>.<p>
Used by <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a>, setMouseBinding(int, ClickAction, bool, int) and <a class="el" href="classQGLViewer.html#4198b3b668c342e39752bade04f78c64">setWheelBinding()</a> to define which handler receives the mouse events. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956"></a><!-- doxytag: member="CAMERA" ref="5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956" args="" -->CAMERA</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6"></a><!-- doxytag: member="FRAME" ref="5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6" args="" -->FRAME</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="85fe75121d351785616b75b2c5661d8f"></a><!-- doxytag: member="QGLViewer::ClickAction" ref="85fe75121d351785616b75b2c5661d8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">ClickAction</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the possible actions that can be binded to a mouse click using setMouseBinding(int,ClickAction,bool,int).<p>
See the <a href="../mouse.html">mouse page</a> for details. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8fed60c81bb5edd0570ff12ac8a0e2b604"></a><!-- doxytag: member="NO_CLICK_ACTION" ref="85fe75121d351785616b75b2c5661d8fed60c81bb5edd0570ff12ac8a0e2b604" args="" -->NO_CLICK_ACTION</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8fc7b18b21c4c8f1eeb5d54bf1b7919db4"></a><!-- doxytag: member="ZOOM_ON_PIXEL" ref="85fe75121d351785616b75b2c5661d8fc7b18b21c4c8f1eeb5d54bf1b7919db4" args="" -->ZOOM_ON_PIXEL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8fb1efbb77356f16254fd4a62e1236b531"></a><!-- doxytag: member="ZOOM_TO_FIT" ref="85fe75121d351785616b75b2c5661d8fb1efbb77356f16254fd4a62e1236b531" args="" -->ZOOM_TO_FIT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8f1697a91b22c2369eb2ba427c2d193329"></a><!-- doxytag: member="SELECT" ref="85fe75121d351785616b75b2c5661d8f1697a91b22c2369eb2ba427c2d193329" args="" -->SELECT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8f6423101303db857a4217e8e66606128a"></a><!-- doxytag: member="RAP_FROM_PIXEL" ref="85fe75121d351785616b75b2c5661d8f6423101303db857a4217e8e66606128a" args="" -->RAP_FROM_PIXEL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8f131d4a2b38607d5d753c4fe19884a9cc"></a><!-- doxytag: member="RAP_IS_CENTER" ref="85fe75121d351785616b75b2c5661d8f131d4a2b38607d5d753c4fe19884a9cc" args="" -->RAP_IS_CENTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8fbf4ad7098f468bfaf170fd5e16902929"></a><!-- doxytag: member="CENTER_FRAME" ref="85fe75121d351785616b75b2c5661d8fbf4ad7098f468bfaf170fd5e16902929" args="" -->CENTER_FRAME</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8f23a1d829d84b71f5aa5a0e19385e8ce7"></a><!-- doxytag: member="CENTER_SCENE" ref="85fe75121d351785616b75b2c5661d8f23a1d829d84b71f5aa5a0e19385e8ce7" args="" -->CENTER_SCENE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8f3f717d1605f3ca83254beb93ea399ddc"></a><!-- doxytag: member="SHOW_ENTIRE_SCENE" ref="85fe75121d351785616b75b2c5661d8f3f717d1605f3ca83254beb93ea399ddc" args="" -->SHOW_ENTIRE_SCENE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8f3d318f59bc81979e3922c7e716085304"></a><!-- doxytag: member="ALIGN_FRAME" ref="85fe75121d351785616b75b2c5661d8f3d318f59bc81979e3922c7e716085304" args="" -->ALIGN_FRAME</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="85fe75121d351785616b75b2c5661d8f35685e5c7e681c3c0eb079e4f132a82a"></a><!-- doxytag: member="ALIGN_CAMERA" ref="85fe75121d351785616b75b2c5661d8f35685e5c7e681c3c0eb079e4f132a82a" args="" -->ALIGN_CAMERA</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="ded669cb17515ea2b5971496f9aef875"></a><!-- doxytag: member="QGLViewer::MouseAction" ref="ded669cb17515ea2b5971496f9aef875" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the possible actions that can be binded to a mouse motion (a click, followed by a mouse displacement).<p>
These actions may be binded to the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> or to the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> (see <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">QGLViewer::MouseHandler</a>) using <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a>. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef8753b20d5f27f63af5ea6e5b6af1112ecf8"></a><!-- doxytag: member="NO_MOUSE_ACTION" ref="ded669cb17515ea2b5971496f9aef8753b20d5f27f63af5ea6e5b6af1112ecf8" args="" -->NO_MOUSE_ACTION</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef8753dcfe0046eb5876e287dbf0914819b16"></a><!-- doxytag: member="ROTATE" ref="ded669cb17515ea2b5971496f9aef8753dcfe0046eb5876e287dbf0914819b16" args="" -->ROTATE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201"></a><!-- doxytag: member="ZOOM" ref="ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201" args="" -->ZOOM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef875bc6501410409b0638909b580970b35f7"></a><!-- doxytag: member="TRANSLATE" ref="ded669cb17515ea2b5971496f9aef875bc6501410409b0638909b580970b35f7" args="" -->TRANSLATE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef87599906f0ddded6cfdab57271cd33e308c"></a><!-- doxytag: member="MOVE_FORWARD" ref="ded669cb17515ea2b5971496f9aef87599906f0ddded6cfdab57271cd33e308c" args="" -->MOVE_FORWARD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef87521fa52d8ef1574dce79cab9ddbb6cd73"></a><!-- doxytag: member="LOOK_AROUND" ref="ded669cb17515ea2b5971496f9aef87521fa52d8ef1574dce79cab9ddbb6cd73" args="" -->LOOK_AROUND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef875b3313fc5887b62fd14b36f1d67903e08"></a><!-- doxytag: member="MOVE_BACKWARD" ref="ded669cb17515ea2b5971496f9aef875b3313fc5887b62fd14b36f1d67903e08" args="" -->MOVE_BACKWARD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef875410b0fa7f49e7eedd6d739db37c67209"></a><!-- doxytag: member="SCREEN_ROTATE" ref="ded669cb17515ea2b5971496f9aef875410b0fa7f49e7eedd6d739db37c67209" args="" -->SCREEN_ROTATE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef8752eeb9fef8a6a516fa6437a44a6efbd52"></a><!-- doxytag: member="ROLL" ref="ded669cb17515ea2b5971496f9aef8752eeb9fef8a6a516fa6437a44a6efbd52" args="" -->ROLL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef875f7b6d6d8e5e14633d388ef9cc7a941b7"></a><!-- doxytag: member="DRIVE" ref="ded669cb17515ea2b5971496f9aef875f7b6d6d8e5e14633d388ef9cc7a941b7" args="" -->DRIVE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef8753de224b064ad81a76d8739cf288543a3"></a><!-- doxytag: member="SCREEN_TRANSLATE" ref="ded669cb17515ea2b5971496f9aef8753de224b064ad81a76d8739cf288543a3" args="" -->SCREEN_TRANSLATE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ded669cb17515ea2b5971496f9aef875fbac98d470c69690e178ff5ab9ad504d"></a><!-- doxytag: member="ZOOM_ON_REGION" ref="ded669cb17515ea2b5971496f9aef875fbac98d470c69690e178ff5ab9ad504d" args="" -->ZOOM_ON_REGION</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="1a30c8c6e5166bc2eb82d599351d7712"></a><!-- doxytag: member="QGLViewer::QGLViewer" ref="1a30c8c6e5166bc2eb82d599351d7712" args="(QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WFlags flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QGLViewer           </td>
          <td>(</td>
          <td class="paramtype">QWidget *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGLWidget *&nbsp;</td>
          <td class="paramname"> <em>shareWidget</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::WFlags&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. See <code>QGLWidget</code> documentation for details.<p>
All viewer parameters (display flags, scene parameters, associated objects...) are set to their default values. See the associated documentation.<p>
If the <code>shareWidget</code> parameter points to a valid <code>QGLWidget</code>, the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> will share the OpenGL context with <code>shareWidget</code> (see <a class="el" href="classQGLViewer.html#514d24ec3ec6c94657ef302a2b3fa74a">isSharing()</a>). 
</div>
</div><p>
<a class="anchor" name="f38a060fc322d6381e28245b2a05a880"></a><!-- doxytag: member="QGLViewer::QGLViewer" ref="f38a060fc322d6381e28245b2a05a880" args="(QGLContext *context, QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WFlags flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QGLViewer           </td>
          <td>(</td>
          <td class="paramtype">QGLContext *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGLWidget *&nbsp;</td>
          <td class="paramname"> <em>shareWidget</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::WFlags&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#1a30c8c6e5166bc2eb82d599351d7712">QGLViewer()</a>, but a <code>QGLContext</code> can be provided so that viewers share GL contexts, even with <code>QGLContext</code> sub-classes (use <code>shareWidget</code> otherwise).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This constructor is correctly working only with Qt versions greater or equal than 3.2. The provided <code>context</code> is simply ignored otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="172fc2a1bb06b7811576a6eaff46ec90"></a><!-- doxytag: member="QGLViewer::QGLViewer" ref="172fc2a1bb06b7811576a6eaff46ec90" args="(const QGLFormat &amp;format, QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WFlags flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QGLViewer           </td>
          <td>(</td>
          <td class="paramtype">const QGLFormat &amp;&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGLWidget *&nbsp;</td>
          <td class="paramname"> <em>shareWidget</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::WFlags&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#1a30c8c6e5166bc2eb82d599351d7712">QGLViewer()</a>, but a specific <code>QGLFormat</code> can be provided.<p>
This is for instance needed to ask for a stencil buffer or for stereo display (as is illustrated in the <a href="../examples/stereoViewer.html">stereoViewer example</a>). 
</div>
</div><p>
<a class="anchor" name="8c90239e64b7a43473a189d5da865ac7"></a><!-- doxytag: member="QGLViewer::~QGLViewer" ref="8c90239e64b7a43473a189d5da865ac7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~QGLViewer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor.<p>
The viewer is replaced by <code>NULL</code> in the <a class="el" href="classQGLViewer.html#32d7a506084c50fd97a24f94d9ca4864">QGLViewerPool()</a> (in order to preserve other viewer's indexes) and allocated memory is released. The <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> is deleted and should be copied before if it is shared by an other viewer. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7d38e6f11078e886f7978525def15797"></a><!-- doxytag: member="QGLViewer::axisIsDrawn" ref="7d38e6f11078e886f7978525def15797" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool axisIsDrawn           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if the world axis is drawn by the viewer.<p>
Set by <a class="el" href="classQGLViewer.html#5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn()</a> or <a class="el" href="classQGLViewer.html#cf2ccb8a346c04a5c7da87da0e8e601f">toggleAxisIsDrawn()</a>. Default value is <code>false</code>. 
</div>
</div><p>
<a class="anchor" name="ee18c56a8321a60771b085a5fe798ee7"></a><!-- doxytag: member="QGLViewer::gridIsDrawn" ref="ee18c56a8321a60771b085a5fe798ee7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gridIsDrawn           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if a XY grid is drawn by the viewer.<p>
Set by <a class="el" href="classQGLViewer.html#e9dd114195dfdf82e23b5754b7c161de">setGridIsDrawn()</a> or <a class="el" href="classQGLViewer.html#8dfaa8be71152ae881b9347235ccc6a1">toggleGridIsDrawn()</a>. Default value is <code>false</code>. 
</div>
</div><p>
<a class="anchor" name="4b8985b86aca5584d9869c8ac868984a"></a><!-- doxytag: member="QGLViewer::FPSIsDisplayed" ref="4b8985b86aca5584d9869c8ac868984a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FPSIsDisplayed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if the viewer displays the current frame rate (Frames Per Second).<p>
Use QApplication::setFont() to define the display font (see <a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText()</a>).<p>
Set by <a class="el" href="classQGLViewer.html#ad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed()</a> or <a class="el" href="classQGLViewer.html#b8a88948237894dca2b7b57a67226d66">toggleFPSIsDisplayed()</a>. Use <a class="el" href="classQGLViewer.html#6fde4d85dfc5338aa237ba1eb505e975">currentFPS()</a> to get the current FPS. Default value is <code>false</code>. 
</div>
</div><p>
<a class="anchor" name="87896d67f84ddb458e1e5ab326db2631"></a><!-- doxytag: member="QGLViewer::textIsEnabled" ref="87896d67f84ddb458e1e5ab326db2631" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool textIsEnabled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if text display (see <a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText()</a>) is enabled.<p>
Set by <a class="el" href="classQGLViewer.html#73d76caa402acd217e504d0bcd13e421">setTextIsEnabled()</a> or <a class="el" href="classQGLViewer.html#b92b2b41db85e4347675b0bc453366d7">toggleTextIsEnabled()</a>. This feature conveniently removes all the possibly displayed text, cleaning display. Default value is <code>true</code>. 
</div>
</div><p>
<a class="anchor" name="1bf2817fb27f0ad326e3db75aeb46af7"></a><!-- doxytag: member="QGLViewer::cameraIsEdited" ref="1bf2817fb27f0ad326e3db75aeb46af7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cameraIsEdited           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> is being edited in the viewer.<p>
Set by <a class="el" href="classQGLViewer.html#521c83b1d745b37331932b4d7b976d41">setCameraIsEdited()</a> or <a class="el" href="classQGLViewer.html#3a53b30eacfccf0825b808977d634936">toggleCameraIsEdited()</a>. Default value is <code>false</code>.<p>
The current implementation is limited: the defined <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> paths (see <a class="el" href="classqglviewer_1_1Camera.html#bfbef567a6bbb9163b31c6f46238e4de">qglviewer::Camera::keyFrameInterpolator()</a>) are simply displayed using <a class="el" href="classqglviewer_1_1Camera.html#eea4caff561e6b1d8fe4b3d8efe4ae87">qglviewer::Camera::drawAllPaths()</a>. Actual camera and path edition will be implemented in the future. 
</div>
</div><p>
<a class="anchor" name="5be8cff3702c1a130f8a17330737a887"></a><!-- doxytag: member="QGLViewer::setAxisIsDrawn" ref="5be8cff3702c1a130f8a17330737a887" args="(bool draw=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAxisIsDrawn           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>draw</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the state of <a class="el" href="classQGLViewer.html#7d38e6f11078e886f7978525def15797">axisIsDrawn()</a>. Emits the <a class="el" href="classQGLViewer.html#541cdbec67d0c5895cd6c77c01b0f89e">axisIsDrawnChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#cf2ccb8a346c04a5c7da87da0e8e601f">toggleAxisIsDrawn()</a>. 
</div>
</div><p>
<a class="anchor" name="e9dd114195dfdf82e23b5754b7c161de"></a><!-- doxytag: member="QGLViewer::setGridIsDrawn" ref="e9dd114195dfdf82e23b5754b7c161de" args="(bool draw=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setGridIsDrawn           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>draw</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the state of <a class="el" href="classQGLViewer.html#ee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a>. Emits the <a class="el" href="classQGLViewer.html#02d191cc46db491d9807266fe62b6178">gridIsDrawnChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#8dfaa8be71152ae881b9347235ccc6a1">toggleGridIsDrawn()</a>. 
</div>
</div><p>
<a class="anchor" name="ad24c89e014de3ea16f071c3bc18f4db"></a><!-- doxytag: member="QGLViewer::setFPSIsDisplayed" ref="ad24c89e014de3ea16f071c3bc18f4db" args="(bool display=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFPSIsDisplayed           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>display</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the state of <a class="el" href="classQGLViewer.html#4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>. Emits the <a class="el" href="classQGLViewer.html#4b005fb3bda4582ce4ab7aeda6692699">FPSIsDisplayedChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#b8a88948237894dca2b7b57a67226d66">toggleFPSIsDisplayed()</a>. 
</div>
</div><p>
<a class="anchor" name="73d76caa402acd217e504d0bcd13e421"></a><!-- doxytag: member="QGLViewer::setTextIsEnabled" ref="73d76caa402acd217e504d0bcd13e421" args="(bool enable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTextIsEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the state of <a class="el" href="classQGLViewer.html#87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a>. Emits the <a class="el" href="classQGLViewer.html#c0b30c0de291a24af638e8c1d6171943">textIsEnabledChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#b92b2b41db85e4347675b0bc453366d7">toggleTextIsEnabled()</a>. 
</div>
</div><p>
<a class="anchor" name="521c83b1d745b37331932b4d7b976d41"></a><!-- doxytag: member="QGLViewer::setCameraIsEdited" ref="521c83b1d745b37331932b4d7b976d41" args="(bool edit=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCameraIsEdited           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>edit</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts (<code>edit</code> = <code>true</code>, default) or stops (<code>edit=<code>false</code>)</code> the edition of the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>.<p>
Current implementation is limited to paths display. Get current state using <a class="el" href="classQGLViewer.html#1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>This method sets the <a class="el" href="classqglviewer_1_1Camera.html#cd07c1b9464b935ad21bb38b7c27afca">qglviewer::Camera::zClippingCoefficient()</a> to 5.0 when <code>edit</code> is <code>true</code>, so that the Camera paths (see <a class="el" href="classqglviewer_1_1Camera.html#bfbef567a6bbb9163b31c6f46238e4de">qglviewer::Camera::keyFrameInterpolator()</a>) are not clipped. It restores the previous value when <code>edit</code> is <code>false</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf2ccb8a346c04a5c7da87da0e8e601f"></a><!-- doxytag: member="QGLViewer::toggleAxisIsDrawn" ref="cf2ccb8a346c04a5c7da87da0e8e601f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleAxisIsDrawn           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the state of <a class="el" href="classQGLViewer.html#7d38e6f11078e886f7978525def15797">axisIsDrawn()</a>. See also <a class="el" href="classQGLViewer.html#5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn()</a>. 
</div>
</div><p>
<a class="anchor" name="8dfaa8be71152ae881b9347235ccc6a1"></a><!-- doxytag: member="QGLViewer::toggleGridIsDrawn" ref="8dfaa8be71152ae881b9347235ccc6a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleGridIsDrawn           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the state of <a class="el" href="classQGLViewer.html#ee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a>. See also <a class="el" href="classQGLViewer.html#e9dd114195dfdf82e23b5754b7c161de">setGridIsDrawn()</a>. 
</div>
</div><p>
<a class="anchor" name="b8a88948237894dca2b7b57a67226d66"></a><!-- doxytag: member="QGLViewer::toggleFPSIsDisplayed" ref="b8a88948237894dca2b7b57a67226d66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleFPSIsDisplayed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the state of <a class="el" href="classQGLViewer.html#4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>. See also <a class="el" href="classQGLViewer.html#ad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed()</a>. 
</div>
</div><p>
<a class="anchor" name="b92b2b41db85e4347675b0bc453366d7"></a><!-- doxytag: member="QGLViewer::toggleTextIsEnabled" ref="b92b2b41db85e4347675b0bc453366d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleTextIsEnabled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the state of <a class="el" href="classQGLViewer.html#87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a>. See also <a class="el" href="classQGLViewer.html#73d76caa402acd217e504d0bcd13e421">setTextIsEnabled()</a>. 
</div>
</div><p>
<a class="anchor" name="3a53b30eacfccf0825b808977d634936"></a><!-- doxytag: member="QGLViewer::toggleCameraIsEdited" ref="3a53b30eacfccf0825b808977d634936" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleCameraIsEdited           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the state of <a class="el" href="classQGLViewer.html#1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a>. See also <a class="el" href="classQGLViewer.html#521c83b1d745b37331932b4d7b976d41">setCameraIsEdited()</a>. 
</div>
</div><p>
<a class="anchor" name="7ddf68dcfb09cc5a991a06d91cb4cc5b"></a><!-- doxytag: member="QGLViewer::backgroundColor" ref="7ddf68dcfb09cc5a991a06d91cb4cc5b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QColor backgroundColor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the background color of the viewer.<p>
This method is provided for convenience since the background color is an OpenGL state variable set with <code>glClearColor()</code>. However, this internal representation has the advantage that it is saved (resp. restored) with <a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> (resp. <a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>).<p>
Use <a class="el" href="classQGLViewer.html#70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor()</a> to define and activate a background color.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Each QColor component is an integer ranging from 0 to 255. This differs from the float values used by <code>glClearColor()</code> which are in the 0.0-1.0 range. Default value is (51, 51, 51) (dark gray). You may have to change <a class="el" href="classQGLViewer.html#a2f726def3615050a9c816c0ca32171d">foregroundColor()</a> accordingly.<p>
This method does not return the current OpenGL clear color as <code>glGet()</code> does. Instead, it returns the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> internal variable. If you directly use <code>glClearColor()</code> or <code><a class="el" href="classQGLViewer.html#88b363f05e720484cde551d5f798e69b">qglClearColor()</a></code> instead of <a class="el" href="classQGLViewer.html#70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor()</a>, the two results will differ. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2f726def3615050a9c816c0ca32171d"></a><!-- doxytag: member="QGLViewer::foregroundColor" ref="a2f726def3615050a9c816c0ca32171d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QColor foregroundColor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the foreground color used by the viewer.<p>
This color is used when <a class="el" href="classQGLViewer.html#4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>, <a class="el" href="classQGLViewer.html#ee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a>, to display the camera paths when the <a class="el" href="classQGLViewer.html#1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Each QColor component is an integer in the range 0-255. This differs from the float values used by <code>glColor3f()</code> which are in the range 0-1. Default value is (180, 180, 180) (light gray).</dd></dl>
Use <code>qglColor</code>(<a class="el" href="classQGLViewer.html#a2f726def3615050a9c816c0ca32171d">foregroundColor()</a>) to set the current OpenGL color to the <a class="el" href="classQGLViewer.html#a2f726def3615050a9c816c0ca32171d">foregroundColor()</a>.<p>
See also <a class="el" href="classQGLViewer.html#7ddf68dcfb09cc5a991a06d91cb4cc5b">backgroundColor()</a>. 
</div>
</div><p>
<a class="anchor" name="70d4e21190fdc47edd88f078dd2037cb"></a><!-- doxytag: member="QGLViewer::setBackgroundColor" ref="70d4e21190fdc47edd88f078dd2037cb" args="(const QColor &amp;color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBackgroundColor           </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#7ddf68dcfb09cc5a991a06d91cb4cc5b">backgroundColor()</a> of the viewer and calls <code><a class="el" href="classQGLViewer.html#88b363f05e720484cde551d5f798e69b">qglClearColor()</a></code>. See also <a class="el" href="classQGLViewer.html#7d986b1944dc5a190e509835e7c79eec">setForegroundColor()</a>. 
</div>
</div><p>
<a class="anchor" name="7d986b1944dc5a190e509835e7c79eec"></a><!-- doxytag: member="QGLViewer::setForegroundColor" ref="7d986b1944dc5a190e509835e7c79eec" args="(const QColor &amp;color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setForegroundColor           </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#a2f726def3615050a9c816c0ca32171d">foregroundColor()</a> of the viewer, used to draw visual hints. See also <a class="el" href="classQGLViewer.html#70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor()</a>. 
</div>
</div><p>
<a class="anchor" name="58c17044cc4a601c6b446bf5e83513f9"></a><!-- doxytag: member="QGLViewer::sceneRadius" ref="58c17044cc4a601c6b446bf5e83513f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sceneRadius           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the scene radius.<p>
The entire displayed scene should be included in a sphere of radius <a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>, centered on <a class="el" href="classQGLViewer.html#5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a>.<p>
This approximate value is used by the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> to set <a class="el" href="classqglviewer_1_1Camera.html#419a57556a6681c3a0489c847d687ea5">qglviewer::Camera::zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a7461df81c1ea0384d4c64723eb7b949">qglviewer::Camera::zFar()</a>. It is also used to <a class="el" href="classQGLViewer.html#da8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a> or to scale the world axis display..<p>
Default value is 1.0. This method is equivalent to <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;<a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>. See <a class="el" href="classQGLViewer.html#ef99f105486d457f0199fcc35181fa83">setSceneRadius()</a>. 
</div>
</div><p>
<a class="anchor" name="5a0503bc22a710f96bfd779eaf538bab"></a><!-- doxytag: member="QGLViewer::sceneCenter" ref="5a0503bc22a710f96bfd779eaf538bab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> sceneCenter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the scene center, defined in world coordinates.<p>
See <a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> for details.<p>
Default value is (0,0,0). Simply a wrapper for <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;<a class="el" href="classQGLViewer.html#5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a>. Set using <a class="el" href="classQGLViewer.html#6712acd05f9d518d6babfe96e537d06d">setSceneCenter()</a>.<p>
Do not mismatch this value (that only depends on the scene) with the <a class="el" href="classqglviewer_1_1Camera.html#fd168442e2a05bd41881936fb722b5fe">qglviewer::Camera::revolveAroundPoint()</a>. 
</div>
</div><p>
<a class="anchor" name="ef99f105486d457f0199fcc35181fa83"></a><!-- doxytag: member="QGLViewer::setSceneRadius" ref="ef99f105486d457f0199fcc35181fa83" args="(float radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setSceneRadius           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>.<p>
The <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> <a class="el" href="classqglviewer_1_1Camera.html#c1758b72dab0895b9340fa833e62b802">qglviewer::Camera::flySpeed()</a> is set to 1% of this value by this method. Simple wrapper around <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;<a class="el" href="classQGLViewer.html#ef99f105486d457f0199fcc35181fa83">setSceneRadius()</a>. 
</div>
</div><p>
<a class="anchor" name="6712acd05f9d518d6babfe96e537d06d"></a><!-- doxytag: member="QGLViewer::setSceneCenter" ref="6712acd05f9d518d6babfe96e537d06d" args="(const qglviewer::Vec &amp;center)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setSceneCenter           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a>, defined in world coordinates.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>The <a class="el" href="classqglviewer_1_1Camera.html#fd168442e2a05bd41881936fb722b5fe">qglviewer::Camera::revolveAroundPoint()</a> is set to the <a class="el" href="classQGLViewer.html#5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a> value by this method. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8339148d876e633c27e5df826f06c9c"></a><!-- doxytag: member="QGLViewer::setSceneBoundingBox" ref="a8339148d876e633c27e5df826f06c9c" args="(const qglviewer::Vec &amp;min, const qglviewer::Vec &amp;max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSceneBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenient way to call <a class="el" href="classQGLViewer.html#6712acd05f9d518d6babfe96e537d06d">setSceneCenter()</a> and <a class="el" href="classQGLViewer.html#ef99f105486d457f0199fcc35181fa83">setSceneRadius()</a> from a (world axis aligned) bounding box of the scene.<p>
This is equivalent to: <div class="fragment"><pre class="fragment">                <a class="code" href="classQGLViewer.html#6712acd05f9d518d6babfe96e537d06d">setSceneCenter</a>((m+M)/2.0);
                <a class="code" href="classQGLViewer.html#ef99f105486d457f0199fcc35181fa83">setSceneRadius</a>(0.5*(M-m).norm());
</pre></div> 
</div>
</div><p>
<a class="anchor" name="da8dd7d2346ebf46ed1f9822a8418df2"></a><!-- doxytag: member="QGLViewer::showEntireScene" ref="da8dd7d2346ebf46ed1f9822a8418df2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showEntireScene           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the camera so that the entire scene is visible.<p>
Simple wrapper around <a class="el" href="classqglviewer_1_1Camera.html#da8dd7d2346ebf46ed1f9822a8418df2">qglviewer::Camera::showEntireScene()</a>. 
</div>
</div><p>
<a class="anchor" name="27a9e97573822d296b48e1c408b74042"></a><!-- doxytag: member="QGLViewer::camera" ref="27a9e97573822d296b48e1c408b74042" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a>* camera           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the associated <a class="el" href="classqglviewer_1_1Camera.html" title="A perspective or orthographic camera.">qglviewer::Camera</a>, never <code>NULL</code>. 
</div>
</div><p>
<a class="anchor" name="ba8c9c519574192fb7197bdbad8049db"></a><!-- doxytag: member="QGLViewer::manipulatedFrame" ref="ba8c9c519574192fb7197bdbad8049db" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a>* manipulatedFrame           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the viewer's <a class="el" href="classqglviewer_1_1ManipulatedFrame.html" title="A ManipulatedFrame is a Frame that can be rotated and translated using the mouse...">qglviewer::ManipulatedFrame</a>.<p>
This <a class="el" href="classqglviewer_1_1ManipulatedFrame.html" title="A ManipulatedFrame is a Frame that can be rotated and translated using the mouse...">qglviewer::ManipulatedFrame</a> can be moved with the mouse when the associated mouse bindings are used (default is when pressing the <code>Control</code> key with any mouse button). Use <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> to define new bindings.<p>
See the <a href="../examples/manipulatedFrame.html">manipulatedFrame example</a> for a complete implementation.<p>
Default value is <code>NULL</code>, meaning that no <a class="el" href="classqglviewer_1_1ManipulatedFrame.html" title="A ManipulatedFrame is a Frame that can be rotated and translated using the mouse...">qglviewer::ManipulatedFrame</a> is set. 
</div>
</div><p>
<a class="anchor" name="9c45e1d2c4777de28664d3db952b7585"></a><!-- doxytag: member="QGLViewer::setCamera" ref="9c45e1d2c4777de28664d3db952b7585" args="(qglviewer::Camera *const camera)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCamera           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *const &nbsp;</td>
          <td class="paramname"> <em>camera</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associates a new <a class="el" href="classqglviewer_1_1Camera.html" title="A perspective or orthographic camera.">qglviewer::Camera</a> to the viewer.<p>
You should only use this method when you derive a new class from <a class="el" href="classqglviewer_1_1Camera.html" title="A perspective or orthographic camera.">qglviewer::Camera</a> and want to use one of its instances instead of the original class.<p>
It you simply want to save and restore Camera positions, use <a class="el" href="classqglviewer_1_1Camera.html#804ee001a41c3ddc33948447fc555cec">qglviewer::Camera::addKeyFrameToPath()</a> and <a class="el" href="classqglviewer_1_1Camera.html#4eb47bb1cf02f806f1f355f63b445818">qglviewer::Camera::playPath()</a> instead.<p>
This method silently ignores NULL <code>camera</code> pointers. The calling method is responsible for deleting the previous camera pointer in order to prevent memory leaks if needed.<p>
The <a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a> and <a class="el" href="classQGLViewer.html#5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a> of <code>camera</code> are set to the <em>current</em> <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> values.<p>
All the <code>camera</code> <a class="el" href="classqglviewer_1_1Camera.html#bfbef567a6bbb9163b31c6f46238e4de">qglviewer::Camera::keyFrameInterpolator()</a> <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#b55c2a4f1732b90057fae4b6037399de">qglviewer::KeyFrameInterpolator::interpolated()</a> signals are connected to the viewer <a class="el" href="classQGLViewer.html#e12b7378efbffabc24a133ca1deb19ae">updateGL()</a> slot. The connections with the previous viewer's camera are removed. 
</div>
</div><p>
<a class="anchor" name="c6964ec1ebb2f42464313e0c43e767a3"></a><!-- doxytag: member="QGLViewer::setManipulatedFrame" ref="c6964ec1ebb2f42464313e0c43e767a3" args="(qglviewer::ManipulatedFrame *frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setManipulatedFrame           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *&nbsp;</td>
          <td class="paramname"> <em>frame</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the viewer's <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>.<p>
Several objects can be manipulated simultaneously, as is done the <a href="../examples/multiSelect.html">multiSelect example</a>.<p>
Defining the <em>own</em> viewer's <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;frame() as the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> is possible and will result in a classical camera manipulation. See the <a href="../examples/luxo.html">luxo example</a> for an illustration.<p>
Note that a <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific...">qglviewer::ManipulatedCameraFrame</a> can be set as the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>: it is possible to manipulate the camera of a first viewer in a second viewer. 
</div>
</div><p>
<a class="anchor" name="6c834adafd727025b63741dd27cb6925"></a><!-- doxytag: member="QGLViewer::mouseGrabber" ref="6c834adafd727025b63741dd27cb6925" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a>* mouseGrabber           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current <a class="el" href="classqglviewer_1_1MouseGrabber.html" title="Abstract class for objects that grab mouse focus in a QGLViewer.">qglviewer::MouseGrabber</a>, or <code>NULL</code> if no <a class="el" href="classqglviewer_1_1MouseGrabber.html" title="Abstract class for objects that grab mouse focus in a QGLViewer.">qglviewer::MouseGrabber</a> currently grabs mouse events.<p>
When <a class="el" href="classqglviewer_1_1MouseGrabber.html#4eb7e14d035ae255b77ac1711aef039e">qglviewer::MouseGrabber::grabsMouse()</a>, the different mouse events are sent to the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> instead of their usual targets (<a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> or <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>).<p>
See the <a class="el" href="classqglviewer_1_1MouseGrabber.html" title="Abstract class for objects that grab mouse focus in a QGLViewer.">qglviewer::MouseGrabber</a> documentation for details on MouseGrabber's mode of operation.<p>
In order to use MouseGrabbers, you need to enable mouse tracking (so that <a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> is called even when no mouse button is pressed). Add this line in <a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init()</a> or in your viewer constructor: <div class="fragment"><pre class="fragment">        <a class="code" href="classQGLViewer.html#cf0a4ee197fe91b8c07dd74cad1aafaa">setMouseTracking</a>(<span class="keyword">true</span>);
</pre></div> Note that mouse tracking is disabled by default. Use QWidget::hasMouseTracking() to retrieve current state. 
</div>
</div><p>
<a class="anchor" name="3f0b956f948f469c095ff3c2c1b73494"></a><!-- doxytag: member="QGLViewer::setMouseGrabberIsEnabled" ref="3f0b956f948f469c095ff3c2c1b73494" args="(const qglviewer::MouseGrabber *const mouseGrabber, bool enabled=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseGrabberIsEnabled           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const &nbsp;</td>
          <td class="paramname"> <em>mouseGrabber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#5fe9b0a1fcd39a5cb132ffdc86f2574f">mouseGrabberIsEnabled()</a> state. 
</div>
</div><p>
<a class="anchor" name="5fe9b0a1fcd39a5cb132ffdc86f2574f"></a><!-- doxytag: member="QGLViewer::mouseGrabberIsEnabled" ref="5fe9b0a1fcd39a5cb132ffdc86f2574f" args="(const qglviewer::MouseGrabber *const mouseGrabber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mouseGrabberIsEnabled           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const &nbsp;</td>
          <td class="paramname"> <em>mouseGrabber</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if <code>mouseGrabber</code> is enabled.<p>
Default value is <code>true</code> for all MouseGrabbers. When set to <code>false</code> using <a class="el" href="classQGLViewer.html#3f0b956f948f469c095ff3c2c1b73494">setMouseGrabberIsEnabled()</a>, the specified <code>mouseGrabber</code> will never become the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> of this <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>. This is useful when you use several viewers: some MouseGrabbers may only have a meaning for some specific viewers and should not be selectable in others.<p>
You can also use <a class="el" href="classqglviewer_1_1MouseGrabber.html#4ac2261aafd5f48f2d90c989cdd69369">qglviewer::MouseGrabber::removeFromMouseGrabberPool()</a> to completely disable a MouseGrabber in all the QGLViewers. 
</div>
</div><p>
<a class="anchor" name="993285ef8a16ccbdc5d57a1264212712"></a><!-- doxytag: member="QGLViewer::setMouseGrabber" ref="993285ef8a16ccbdc5d57a1264212712" args="(qglviewer::MouseGrabber *mouseGrabber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseGrabber           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&nbsp;</td>
          <td class="paramname"> <em>mouseGrabber</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Directly defines the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>.<p>
You should not call this method directly as it bypasses the <a class="el" href="classqglviewer_1_1MouseGrabber.html#6110636d4e031373ecebd42c6ea838ea">qglviewer::MouseGrabber::checkIfGrabsMouse()</a> test performed by <a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a>.<p>
If the MouseGrabber is disabled (see <a class="el" href="classQGLViewer.html#5fe9b0a1fcd39a5cb132ffdc86f2574f">mouseGrabberIsEnabled()</a>), this method silently does nothing. 
</div>
</div><p>
<a class="anchor" name="915589f4d93e15d110444ed9b3464fa1"></a><!-- doxytag: member="QGLViewer::aspectRatio" ref="915589f4d93e15d110444ed9b3464fa1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float aspectRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the aspect ratio of the viewer's widget (<a class="el" href="classQGLViewer.html#369399896761e31ae71db57fdd0ba431">width()</a> / <a class="el" href="classQGLViewer.html#e26bcfe2f33f5873dbdfb6948cf1f59f">height()</a>). 
</div>
</div><p>
<a class="anchor" name="6fde4d85dfc5338aa237ba1eb505e975"></a><!-- doxytag: member="QGLViewer::currentFPS" ref="6fde4d85dfc5338aa237ba1eb505e975" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float currentFPS           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current averaged viewer frame rate.<p>
This value is computed and averaged over 20 successive frames. It only changes every 20 <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> (previously computed value is otherwise returned).<p>
This method is useful for true real-time applications that may adapt their computational load accordingly in order to maintain a given frequency.<p>
This value is meaningful only when <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> is regularly called, either using a <code>QTimer</code>, when <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a> or when the camera is manipulated with the mouse. 
</div>
</div><p>
<a class="anchor" name="129c439f36bb669672148192abc8ffed"></a><!-- doxytag: member="QGLViewer::isFullScreen" ref="129c439f36bb669672148192abc8ffed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isFullScreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if the viewer is in fullScreen mode.<p>
Default value is <code>false</code>. Set by <a class="el" href="classQGLViewer.html#7e021e15180ba348e90c955bdd28b1a4">setFullScreen()</a> or <a class="el" href="classQGLViewer.html#a5b47397e4ad7c2bb9573e0d186170e0">toggleFullScreen()</a>.<p>
Note that if the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> is embedded in an other QWidget, it returns <code>true</code> when the top level widget is in full screen mode. 
</div>
</div><p>
<a class="anchor" name="2fc4c62e317a0f64c2a943ed11faa337"></a><!-- doxytag: member="QGLViewer::displaysInStereo" ref="2fc4c62e317a0f64c2a943ed11faa337" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool displaysInStereo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if the viewer displays in stereo.<p>
The <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> object must be created with a stereo format to handle stereovision: <div class="fragment"><pre class="fragment">        QGLFormat format;
        format.setStereoDisplay( TRUE );
        <a class="code" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> viewer(format);
</pre></div> The hardware needs to support stereo display. Try the <a href="../examples/stereoViewer.html">stereoViewer example</a> to check.<p>
Set by <a class="el" href="classQGLViewer.html#fe362ba5c3851a93f23fb833b2479f08">setStereoDisplay()</a> or <a class="el" href="classQGLViewer.html#4e0ebf98eacbcbad3b094e26d9e35886">toggleStereoDisplay()</a>. Default value is <code>false</code>.<p>
Stereo is performed using the Parallel axis asymmetric frustum perspective projection method. See Camera::loadProjectionMatrixStereo() and Camera::loadModelViewMatrixStereo().<p>
The stereo parameters are defined by the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>. See <a class="el" href="classqglviewer_1_1Camera.html#6cd81fe74a9dfe5c7124d00341ad0234">qglviewer::Camera::setIODistance()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a88668546aa531dc0702d1b005904bcf">qglviewer::Camera::setPhysicalDistanceToScreen()</a>, <a class="el" href="classqglviewer_1_1Camera.html#34911cda1cc1bc13336024c844ff4401">qglviewer::Camera::setPhysicalScreenWidth()</a> and <a class="el" href="classqglviewer_1_1Camera.html#863ffb0284b534d5c57ac64a98e5e49a">qglviewer::Camera::setFocusDistance()</a>. 
</div>
</div><p>
<a class="anchor" name="d8288a17cf54658f1ce1c0db9e97dc8a"></a><!-- doxytag: member="QGLViewer::sizeHint" ref="d8288a17cf54658f1ce1c0db9e97dc8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QSize sizeHint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the recommended size for the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>. Default value is 600x400 pixels. 
</div>
</div><p>
<a class="anchor" name="7e021e15180ba348e90c955bdd28b1a4"></a><!-- doxytag: member="QGLViewer::setFullScreen" ref="7e021e15180ba348e90c955bdd28b1a4" args="(bool fullScreen=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFullScreen           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fullScreen</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#129c439f36bb669672148192abc8ffed">isFullScreen()</a> state.<p>
If the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> is embedded in an other QWidget (see QWidget::topLevelWidget()), this widget is displayed in full screen instead. 
</div>
</div><p>
<a class="anchor" name="fe362ba5c3851a93f23fb833b2479f08"></a><!-- doxytag: member="QGLViewer::setStereoDisplay" ref="fe362ba5c3851a93f23fb833b2479f08" args="(bool stereo=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setStereoDisplay           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>stereo</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the state of <a class="el" href="classQGLViewer.html#2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>. See also <a class="el" href="classQGLViewer.html#4e0ebf98eacbcbad3b094e26d9e35886">toggleStereoDisplay()</a>.<p>
First checks that the display is able to handle stereovision using QGLWidget::format(). Opens a warning message box in case of failure. Emits the <a class="el" href="classQGLViewer.html#9d7df8ab7c351e32da3c72b19c4585c0">stereoChanged()</a> signal otherwise. 
</div>
</div><p>
<a class="anchor" name="a5b47397e4ad7c2bb9573e0d186170e0"></a><!-- doxytag: member="QGLViewer::toggleFullScreen" ref="a5b47397e4ad7c2bb9573e0d186170e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleFullScreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the state of <a class="el" href="classQGLViewer.html#129c439f36bb669672148192abc8ffed">isFullScreen()</a>. See also <a class="el" href="classQGLViewer.html#7e021e15180ba348e90c955bdd28b1a4">setFullScreen()</a>. 
</div>
</div><p>
<a class="anchor" name="4e0ebf98eacbcbad3b094e26d9e35886"></a><!-- doxytag: member="QGLViewer::toggleStereoDisplay" ref="4e0ebf98eacbcbad3b094e26d9e35886" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleStereoDisplay           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the state of <a class="el" href="classQGLViewer.html#2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>. See <a class="el" href="classQGLViewer.html#fe362ba5c3851a93f23fb833b2479f08">setStereoDisplay()</a>. 
</div>
</div><p>
<a class="anchor" name="17ea00dd30fb78086cf7e22bc2f10695"></a><!-- doxytag: member="QGLViewer::toggleCameraMode" ref="17ea00dd30fb78086cf7e22bc2f10695" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleCameraMode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps between two predefined camera mouse bindings.<p>
The first mode makes the camera observe the scene while revolving around the <a class="el" href="classqglviewer_1_1Camera.html#fd168442e2a05bd41881936fb722b5fe">qglviewer::Camera::revolveAroundPoint()</a>. The second mode is designed for walkthrough applications and simulates a flying camera.<p>
Practically, the three mouse buttons are respectively binded to: <ul>
<li>In revolve mode: <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753dcfe0046eb5876e287dbf0914819b16">ROTATE</a>, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201">ZOOM</a>, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875bc6501410409b0638909b580970b35f7">TRANSLATE</a>. </li>
<li>In fly mode: <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef87599906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a>, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef87521fa52d8ef1574dce79cab9ddbb6cd73">LOOK_AROUND</a>, <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875b3313fc5887b62fd14b36f1d67903e08">MOVE_BACKWARD</a>.</li>
</ul>
The current mode is determined by checking if a mouse button is binded to <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753dcfe0046eb5876e287dbf0914819b16">ROTATE</a> for the <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a> (using <a class="el" href="classQGLViewer.html#5e9d4c07afc73f5c8a0926641e1428ac">mouseButtonState()</a>). The state key that was previously used to move the camera is preserved. 
</div>
</div><p>
<a class="anchor" name="14fc47f313bbb65c38d2a8ae754215e0"></a><!-- doxytag: member="QGLViewer::drawArrow" ref="14fc47f313bbb65c38d2a8ae754215e0" args="(float length=1.0f, float radius=-1.0f, int nbSubdivisions=12)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawArrow           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em> = <code>-1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nbSubdivisions</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws a 3D arrow along the positive Z axis.<p>
<code>length</code>, <code>radius</code> and <code>nbSubdivisions</code> define its geometry. If <code>radius</code> is negative (default), it is set to 0.05 * <code>length</code>.<p>
Use drawArrow(const Vec&amp; from, const Vec&amp; to, float radius, int nbSubdivisions) or change the <code>ModelView</code> matrix to place the arrow in 3D.<p>
Uses current color and does not modify the OpenGL state. 
</div>
</div><p>
<a class="anchor" name="27edb1331c7bf373d126487e9547969f"></a><!-- doxytag: member="QGLViewer::drawArrow" ref="27edb1331c7bf373d126487e9547969f" args="(const qglviewer::Vec &amp;from, const qglviewer::Vec &amp;to, float radius=-1.0f, int nbSubdivisions=12)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawArrow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em> = <code>-1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nbSubdivisions</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws a 3D arrow between the 3D point <code>from</code> and the 3D point <code>to</code>, both defined in the current ModelView coordinates system.<p>
See <a class="el" href="classQGLViewer.html#14fc47f313bbb65c38d2a8ae754215e0">drawArrow(float length, float radius, int nbSubdivisions)</a> for details. 
</div>
</div><p>
<a class="anchor" name="f18c0661b9a86e6b07ae344e05979c4c"></a><!-- doxytag: member="QGLViewer::drawAxis" ref="f18c0661b9a86e6b07ae344e05979c4c" args="(float length=1.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawAxis           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>1.0f</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws an XYZ axis, with a given size (default is 1.0).<p>
The axis position and orientation matches the current modelView matrix state: three arrows (red, green and blue) of length <code>length</code> are drawn along the positive X, Y and Z directions.<p>
Use the following code to display the current position and orientation of a <a class="el" href="classqglviewer_1_1Frame.html" title="The Frame class represents a coordinate system, defined by a position and an orientation...">qglviewer::Frame</a>: <div class="fragment"><pre class="fragment">glPushMatrix();
glMultMatrixd(frame.matrix());
<a class="code" href="classQGLViewer.html#f18c0661b9a86e6b07ae344e05979c4c">QGLViewer::drawAxis</a>(<a class="code" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius</a>() / 5.0); <span class="comment">// Or any scale</span>
glPopMatrix();
</pre></div><p>
The current color and line width are used to draw the X, Y and Z characters at the extremities of the three arrows. The OpenGL state is not modified by this method.<p>
<a class="el" href="classQGLViewer.html#7d38e6f11078e886f7978525def15797">axisIsDrawn()</a> uses this method to draw a representation of the world coordinate system. See also <a class="el" href="classQGLViewer.html#14fc47f313bbb65c38d2a8ae754215e0">QGLViewer::drawArrow()</a> and <a class="el" href="classQGLViewer.html#d4a4d99fabe53083099c70439bc3564d">QGLViewer::drawGrid()</a>. 
</div>
</div><p>
<a class="anchor" name="d4a4d99fabe53083099c70439bc3564d"></a><!-- doxytag: member="QGLViewer::drawGrid" ref="d4a4d99fabe53083099c70439bc3564d" args="(float size=1.0f, int nbSubdivisions=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawGrid           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nbSubdivisions</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws a grid in the XY plane, centered on (0,0,0) (defined in the current coordinate system).<p>
<code>size</code> (OpenGL units) and <code>nbSubdivisions</code> define its geometry. Set the <code>GL_MODELVIEW</code> matrix to place and orientate the grid in 3D space (see the <a class="el" href="classQGLViewer.html#f18c0661b9a86e6b07ae344e05979c4c">drawAxis()</a> documentation).<p>
The OpenGL state is not modified by this method. 
</div>
</div><p>
<a class="anchor" name="5825ac26bdef13ae5ddd021e318aaf15"></a><!-- doxytag: member="QGLViewer::startScreenCoordinatesSystem" ref="5825ac26bdef13ae5ddd021e318aaf15" args="(bool upward=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startScreenCoordinatesSystem           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>upward</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify the projection matrix so that drawing can be done directly with 2D screen coordinates.<p>
Once called, the <code>x</code> and <code>y</code> coordinates passed to <code>glVertex</code> are expressed in pixels screen coordinates. The origin (0,0) is in the upper left corner of the widget by default. This follows the Qt standards, so that you can directly use the <code>pos()</code> provided by for instance <code>QMouseEvent</code>. Set <code>upward</code> to <code>true</code> to place the origin in the <em>lower</em> left corner, thus following the OpenGL and mathematical standards. It is always possible to switch between the two representations using <code>newY</code> = <a class="el" href="classQGLViewer.html#e26bcfe2f33f5873dbdfb6948cf1f59f">height()</a> - <code>y</code>.<p>
You need to call <a class="el" href="classQGLViewer.html#9cff22af974391604bff7f91df789138">stopScreenCoordinatesSystem()</a> at the end of the drawing block to restore the previous camera matrix.<p>
In practice, this method should be used in <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. It sets an appropriate orthographic projection matrix and then sets <code>glMatrixMode</code> to <code>GL_MODELVIEW</code>.<p>
See the <a href="../examples/screenCoordSystem.html">screenCoordSystem</a>, <a href="../examples/multiSelect.html">multiSelect</a> and <a href="../examples/contribs.html#backgroundImage">backgroundImage</a> examples for an illustration.<p>
You may want to disable <code>GL_LIGHTING</code>, to enable <code>GL_LINE_SMOOTH</code> or <code>GL_BLEND</code> to draw when this method is used.<p>
If you want to link 2D drawings to 3D objects, use <a class="el" href="classqglviewer_1_1Camera.html#c4dc649d17bd2ae8664a7f4fdd50360f">qglviewer::Camera::projectedCoordinatesOf()</a> to compute the 2D projection on screen of a 3D point (see the <a href="../examples/screenCoordSystem.html">screenCoordSystem</a> example). See also <a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText()</a>.<p>
In this mode, you should use z values that are in the [0.0, 1.0[ range (0.0 corresponding to the near clipping plane and 1.0 being just beyond the far clipping plane). This interval matches the values that can be read from the z-buffer. Note that if you use the convenient <code>glVertex2i()</code> to provide coordinates, the implicit 0.0 z coordinate will make your drawings appear <em>on</em> <em>top</em> of the rest of the scene. 
</div>
</div><p>
<a class="anchor" name="9cff22af974391604bff7f91df789138"></a><!-- doxytag: member="QGLViewer::stopScreenCoordinatesSystem" ref="9cff22af974391604bff7f91df789138" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stopScreenCoordinatesSystem           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops the pixel coordinate drawing block started by <a class="el" href="classQGLViewer.html#5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem()</a>.<p>
The <code>GL_MODELVIEW</code> and <code>GL_PROJECTION</code> matrices modified in <a class="el" href="classQGLViewer.html#5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem()</a> are restored. <code>glMatrixMode</code> is set to <code>GL_MODELVIEW</code>. 
</div>
</div><p>
<a class="anchor" name="d604ec747b161c869877fcb647a3c775"></a><!-- doxytag: member="QGLViewer::drawText" ref="d604ec747b161c869877fcb647a3c775" args="(int x, int y, const QString &amp;text, const QFont &amp;fnt=QFont())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawText           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QFont &amp;&nbsp;</td>
          <td class="paramname"> <em>fnt</em> = <code>QFont()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws <code>text</code> at position <code>x</code>, <code>y</code> (expressed in screen coordinates pixels, origin in the upper left corner of the widget).<p>
The default QApplication::font() is used to render the text when no <code>fnt</code> is specified. Use QApplication::setFont() to define this default font.<p>
You should disable <code>GL_LIGHTING</code> before this method so that colors are properly rendered.<p>
This method can be used in conjunction with the <a class="el" href="classqglviewer_1_1Camera.html#c4dc649d17bd2ae8664a7f4fdd50360f">qglviewer::Camera::projectedCoordinatesOf()</a> method to display a text attached to an object. In your <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> method use: <div class="fragment"><pre class="fragment"><a class="code" href="classqglviewer_1_1Vec.html" title="The Vec class represents 3D positions and 3D vectors.">qglviewer::Vec</a> screenPos = <a class="code" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#c4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf</a>(myFrame.position());
<a class="code" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText</a>((<span class="keywordtype">int</span>)screenPos[0], (<span class="keywordtype">int</span>)screenPos[1], <span class="stringliteral">"My Object"</span>);
</pre></div> See the <a href="../examples/screenCoordSystem.html">screenCoordSystem example</a> for an illustration.<p>
Text is displayed only when <a class="el" href="classQGLViewer.html#87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a> (default). This mechanism allows the user to conveniently remove all the displayed text with a single keyboard shortcut.<p>
Use <a class="el" href="classQGLViewer.html#61336516f9771ac6aef90875f848add4">displayMessage()</a> to <a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText()</a> for only a short amount of time.<p>
Use the QGLWidget::renderText(x,y,z, text) method (Qt version &gt;= 3.1) to draw a text (fixed size, facing the camera) located at a specific 3D position instead of 2D screen coordinates.<p>
The <code>GL_MODELVIEW</code> and <code>GL_PROJECTION</code> matrices are not modified by this method.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>This method uses display lists to render the characters, with an index that starts at 2000 by default (see the QGLWidget::renderText() documentation). If you use more than 2000 Display Lists, they may overlap with these. Directly use QGLWidget::renderText() in that case, with a higher <code>listBase</code> parameter (or overload <code>fontDisplayListBase</code> with Qt4).<p>
There is a problem with anti-aliased font with nVidia cards and Qt versions lower than 3.3. Until this version, the <code>fnt</code> parameter is not taken into account to prevent a crash. It is replaced by a fixed font that should be compatible with the <code>qtconfig</code> anti-aliased font configuration (disable this option otherwise).</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method uses QGLWidget::renderText() if your Qt version is greater or equal to 3.1, otherwise it uses (and requires) GLUT. When GLUT is used, only the <code>fnt</code> size attribute (set with QFont::setPixelSize() or QFont::setPointSize()) is taken into account. Also note that in that case each call to <a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText()</a> changes the camera projection matrix and restores it back (using <a class="el" href="classQGLViewer.html#5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem()</a> and <a class="el" href="classQGLViewer.html#9cff22af974391604bff7f91df789138">stopScreenCoordinatesSystem()</a>). If you call this method several times and it slows down your frame rate, consider factorizing the context changes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="61336516f9771ac6aef90875f848add4"></a><!-- doxytag: member="QGLViewer::displayMessage" ref="61336516f9771ac6aef90875f848add4" args="(const QString &amp;message, int delay=2000)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void displayMessage           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>delay</em> = <code>2000</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Briefly displays a message in the lower left corner of the widget. Convenient to provide feedback to the user.<p>
<code>message</code> is displayed during <code>delay</code> milliseconds (default is 2 seconds) using <a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText()</a>.<p>
This method should not be called in <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. If you want to display a text in each <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>, use <a class="el" href="classQGLViewer.html#d604ec747b161c869877fcb647a3c775">drawText()</a> instead.<p>
If this method is called when a message is already displayed, the new message replaces the old one. Use <a class="el" href="classQGLViewer.html#73d76caa402acd217e504d0bcd13e421">setTextIsEnabled()</a> (default shortcut is '?') to enable or disable text (and hence messages) display. 
</div>
</div><p>
<a class="anchor" name="2a3b971fe826a90efaffcb7c68fdcc53"></a><!-- doxytag: member="QGLViewer::drawLight" ref="2a3b971fe826a90efaffcb7c68fdcc53" args="(GLenum light, float scale=1.0f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawLight           </td>
          <td>(</td>
          <td class="paramtype">GLenum&nbsp;</td>
          <td class="paramname"> <em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>scale</em> = <code>1.0f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws a representation of <code>light</code>.<p>
Called in <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>, this method is useful to debug or display your light setup. Light drawing depends on the type of light (point, spot, directional).<p>
The method retrieves the light setup using <code>glGetLightfv</code>. Position and define your lights before calling this method.<p>
Light is drawn using its diffuse color. Disabled lights are not displayed.<p>
Drawing size is proportional to <a class="el" href="classQGLViewer.html#58c17044cc4a601c6b446bf5e83513f9">sceneRadius()</a>. Use <code>scale</code> to rescale it.<p>
See the <a href="../examples/drawLight.html">drawLight example</a> for an illustration.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>You need to enable <code>GL_COLOR_MATERIAL</code> before calling this method. <code>glColor</code> is set to the light diffuse color. </dd></dl>

</div>
</div><p>
<a class="anchor" name="369399896761e31ae71db57fdd0ba431"></a><!-- doxytag: member="QGLViewer::width" ref="369399896761e31ae71db57fdd0ba431" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int width           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns viewer's widget width (in pixels). See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="e26bcfe2f33f5873dbdfb6948cf1f59f"></a><!-- doxytag: member="QGLViewer::height" ref="e26bcfe2f33f5873dbdfb6948cf1f59f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int height           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns viewer's widget height (in pixels). See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="e12b7378efbffabc24a133ca1deb19ae"></a><!-- doxytag: member="QGLViewer::updateGL" ref="e12b7378efbffabc24a133ca1deb19ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateGL           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates the display. Do not call <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> directly, use this method instead. See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="75679575b3b071cddce2a56c77e1bd68"></a><!-- doxytag: member="QGLViewer::convertToGLFormat" ref="75679575b3b071cddce2a56c77e1bd68" args="(const QImage &amp;image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static QImage convertToGLFormat           </td>
          <td>(</td>
          <td class="paramtype">const QImage &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts <code>image</code> into the unnamed format expected by OpenGL methods such as glTexImage2D(). See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="8911f3aec33c17d1eba4390436b5c868"></a><!-- doxytag: member="QGLViewer::qglColor" ref="8911f3aec33c17d1eba4390436b5c868" args="(const QColor &amp;color) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qglColor           </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <code>glColor3</code>. See QGLWidget::qglColor(). 
</div>
</div><p>
<a class="anchor" name="88b363f05e720484cde551d5f798e69b"></a><!-- doxytag: member="QGLViewer::qglClearColor" ref="88b363f05e720484cde551d5f798e69b" args="(const QColor &amp;color) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qglClearColor           </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <code>glClearColor</code>. See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="ac1b70a2ed67ead038c4d3f5ac4d8a81"></a><!-- doxytag: member="QGLViewer::isValid" ref="ac1b70a2ed67ead038c4d3f5ac4d8a81" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if the widget has a valid GL rendering context. See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="514d24ec3ec6c94657ef302a2b3fa74a"></a><!-- doxytag: member="QGLViewer::isSharing" ref="514d24ec3ec6c94657ef302a2b3fa74a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSharing           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if display list sharing with another QGLWidget was requested in the constructor. See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="1436277e13026c94601bbe37a2f1d262"></a><!-- doxytag: member="QGLViewer::makeCurrent" ref="1436277e13026c94601bbe37a2f1d262" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void makeCurrent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes this widget's rendering context the current OpenGL rendering context. Useful with several viewers. See QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="47c0968a61bcd23c491817631e4ec953"></a><!-- doxytag: member="QGLViewer::hasMouseTracking" ref="47c0968a61bcd23c491817631e4ec953" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hasMouseTracking           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if <a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> is called even when no mouse button is pressed.<p>
You need to <a class="el" href="classQGLViewer.html#cf0a4ee197fe91b8c07dd74cad1aafaa">setMouseTracking()</a> to <code>true</code> in order to use MouseGrabber (see <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>). See details in the QWidget documentation. 
</div>
</div><p>
<a class="anchor" name="d1185e99a9efec124b7a9bede84a6cf1"></a><!-- doxytag: member="QGLViewer::resize" ref="d1185e99a9efec124b7a9bede84a6cf1" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes the widget to size <code>width</code> by <code>height</code> pixels. See also <a class="el" href="classQGLViewer.html#369399896761e31ae71db57fdd0ba431">width()</a> and <a class="el" href="classQGLViewer.html#e26bcfe2f33f5873dbdfb6948cf1f59f">height()</a>. 
</div>
</div><p>
<a class="anchor" name="cf0a4ee197fe91b8c07dd74cad1aafaa"></a><!-- doxytag: member="QGLViewer::setMouseTracking" ref="cf0a4ee197fe91b8c07dd74cad1aafaa" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setMouseTracking           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#47c0968a61bcd23c491817631e4ec953">hasMouseTracking()</a> value. 
</div>
</div><p>
<a class="anchor" name="36faca915c37548a53ab04f297bb5c17"></a><!-- doxytag: member="QGLViewer::autoBufferSwap" ref="36faca915c37548a53ab04f297bb5c17" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autoBufferSwap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> when buffers are automatically swapped (default). See details in the QGLWidget documentation. 
</div>
</div><p>
<a class="anchor" name="d95e0ffd255bcc1fb69c9213d8d8b017"></a><!-- doxytag: member="QGLViewer::setAutoBufferSwap" ref="d95e0ffd255bcc1fb69c9213d8d8b017" args="(bool on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAutoBufferSwap           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>on</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#36faca915c37548a53ab04f297bb5c17">autoBufferSwap()</a> value. 
</div>
</div><p>
<a class="anchor" name="00f2094711c7349fe1f74b6fc0b5530f"></a><!-- doxytag: member="QGLViewer::snapshotFileName" ref="00f2094711c7349fe1f74b6fc0b5530f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString&amp; snapshotFileName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the snapshot file name used by <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>.<p>
This value is used in <code>automatic</code> mode (see <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>). A dialog is otherwise popped-up to set it.<p>
You can also directly provide a file name using <a class="el" href="classQGLViewer.html#82544567565cfa0b750cb24ac1aa8358">saveSnapshot(const QString&amp;, bool)</a>.<p>
If the file name is relative, the current working directory at the moment of the method call is used. Set using <a class="el" href="classQGLViewer.html#a15be68d137eca013942eae69e40e0ee">setSnapshotFileName()</a>. 
</div>
</div><p>
<a class="anchor" name="bbb1add55632dced395e2f1b78ef491c"></a><!-- doxytag: member="QGLViewer::snapshotFormat" ref="bbb1add55632dced395e2f1b78ef491c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString&amp; snapshotFormat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the snapshot file format used by <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>.<p>
This value is used when <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> is passed the <code>automatic</code> flag. It is defined using a saveAs pop-up dialog otherwise.<p>
The available formats are those handled by Qt. Classical values are <code>"JPEG"</code>, <code>"PNG"</code>, <code>"PPM, \c "BMP"</code>. Use the following code to get the actual list: <div class="fragment"><pre class="fragment">        QList&lt;QByteArray&gt; formatList = QImageReader::supportedImageFormats();
        <span class="comment">// or with Qt version 2 or 3:</span>
        QStringList formatList = QImage::outputFormatList();
</pre></div><p>
If the library was compiled with the vectorial rendering option (default), three additional vectorial formats are available: <code>"EPS"</code>, <code>"PS"</code> and <code>"XFIG"</code>. <code>"SVG"</code> and <code>"PDF"</code> formats should soon be available. The <a href="http://artis.imag.fr/Software/VRender">VRender library</a> was created by Cyril Soler.<p>
Note that the VRender library has some limitations: vertex shader effects are not reproduced and <code>PASS_THROUGH</code> tokens are not handled so one can not change point and line size in the middle of a drawing.<p>
Default value is the first supported among "JPEG, PNG, EPS, PS, PPM, BMP", in that order.<p>
This value is set using <a class="el" href="classQGLViewer.html#82043998256d08163f79ceee83278e14">setSnapshotFormat()</a> or with <a class="el" href="classQGLViewer.html#c9c409fd034bc5ab42aacfa4c23fe55c">openSnapshotFormatDialog()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>No verification is performed on the provided format validity. The next call to <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> may fail if the format string is not supported. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4de825bb96eba2c5f6a55facb9dc4cef"></a><!-- doxytag: member="QGLViewer::snapshotCounter" ref="4de825bb96eba2c5f6a55facb9dc4cef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snapshotCounter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value of the counter used to name snapshots in <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> when <code>automatic</code> is <code>true</code>.<p>
Set using <a class="el" href="classQGLViewer.html#feb307bbd1a56cdfb3749f699d4af03c">setSnapshotCounter()</a>. Default value is 0, and it is incremented after each <code>automatic</code> snapshot. See <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> for details. 
</div>
</div><p>
<a class="anchor" name="50685165e76c57dc87dea3c84b7e5be0"></a><!-- doxytag: member="QGLViewer::snapshotQuality" ref="50685165e76c57dc87dea3c84b7e5be0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snapshotQuality           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the image quality of the snapshots produced with <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>.<p>
Values must be in the range -1..100. Use 0 for lowest quality and 100 for highest quality (and larger files). -1 means use Qt default quality. Default value is 95.<p>
Set using <a class="el" href="classQGLViewer.html#b64b04b76b1f35ee1b3f07fa747dc9a0">setSnapshotQuality()</a>. See also the QImage::save() documentation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This value has no impact on the images produced in vectorial format. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1cf2ffb973b096b249dc7e90327a2a8e"></a><!-- doxytag: member="QGLViewer::saveSnapshot" ref="1cf2ffb973b096b249dc7e90327a2a8e" args="(bool automatic=true, bool overwrite=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saveSnapshot           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>automatic</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>overwrite</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves a snapshot of the current image displayed by the widget.<p>
Options are set using <a class="el" href="classQGLViewer.html#bbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a>, <a class="el" href="classQGLViewer.html#00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> and <a class="el" href="classQGLViewer.html#50685165e76c57dc87dea3c84b7e5be0">snapshotQuality()</a>. For non vectorial image formats, the image size is equal to the current viewer's dimensions (see <a class="el" href="classQGLViewer.html#369399896761e31ae71db57fdd0ba431">width()</a> and <a class="el" href="classQGLViewer.html#e26bcfe2f33f5873dbdfb6948cf1f59f">height()</a>). See <a class="el" href="classQGLViewer.html#bbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a> for details on supported formats.<p>
If <code>automatic</code> is <code>false</code> (or if <a class="el" href="classQGLViewer.html#00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> is empty), a file dialog is opened to ask for the file name.<p>
When <code>automatic</code> is <code>true</code>, the file name is set to <code>NAME-NUMBER</code>, where <code>NAME</code> is <a class="el" href="classQGLViewer.html#00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> and <code>NUMBER</code> is <a class="el" href="classQGLViewer.html#4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a>. The <a class="el" href="classQGLViewer.html#4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is automatically incremented after each snapshot saving. This is useful to create videos from your application: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> Viewer::init()
 {
   resize(720, 576); <span class="comment">// PAL DV format (use 720x480 for NTSC DV)</span>
   connect(<span class="keyword">this</span>, SIGNAL(drawFinished(<span class="keywordtype">bool</span>)), SLOT(saveSnapshot(<span class="keywordtype">bool</span>)));
 }
</pre></div> Then call <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> in a loop (for instance using <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and/or a <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> KeyFrameInterpolator replay) to create your image sequence.<p>
If you want to create a Quicktime VR panoramic sequence, simply use code like this: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> Viewer::createQuicktime()
 {
   <span class="keyword">const</span> <span class="keywordtype">int</span> nbImages = 36;
   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbImages; ++i)
     {
       camera()-&gt;setOrientation(2.0*M_PI/nbImages, 0.0); <span class="comment">// Theta-Phi orientation</span>
       showEntireScene();
       updateGL(); <span class="comment">// calls draw(), which emits drawFinished(), which calls saveSnapshot()</span>
     }
 }
</pre></div><p>
If <a class="el" href="classQGLViewer.html#4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is negative, no number is appended to <a class="el" href="classQGLViewer.html#00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> and the <a class="el" href="classQGLViewer.html#4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is not incremented. This is useful to force the creation of a file, overwriting the previous one.<p>
When <code>overwrite</code> is set to <code>false</code> (default), a window asks for confirmation if the file already exists. In <code>automatic</code> mode, the <a class="el" href="classQGLViewer.html#4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is incremented (if positive) until a non-existing file name is found instead. Otherwise the file is overwritten without confirmation.<p>
The VRender library was written by Cyril Soler (Cyril dot Soler at imag dot fr). If the generated PS or EPS file is not properly displayed, remove the anti-aliasing option in your postscript viewer.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In order to correctly grab the frame buffer, the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> window is raised in front of other windows by this method. </dd></dl>

</div>
</div><p>
<a class="anchor" name="82544567565cfa0b750cb24ac1aa8358"></a><!-- doxytag: member="QGLViewer::saveSnapshot" ref="82544567565cfa0b750cb24ac1aa8358" args="(const QString &amp;fileName, bool overwrite=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saveSnapshot           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>overwrite</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>, except that it uses <code>fileName</code> instead of <a class="el" href="classQGLViewer.html#00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a>.<p>
If <code>fileName</code> is empty, opens a file dialog to select the name.<p>
Snapshot settings are set from <a class="el" href="classQGLViewer.html#bbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a> and <a class="el" href="classQGLViewer.html#50685165e76c57dc87dea3c84b7e5be0">snapshotQuality()</a>.<p>
Asks for confirmation when <code>fileName</code> already exists and <code>overwrite</code> is <code>false</code> (default).<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>If <code>fileName</code> is a char* (as is "myFile.jpg"), it may be casted into a <code>bool</code>, and the other <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> method may be used instead. Pass QString("myFile.jpg") as a parameter to prevent this. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a15be68d137eca013942eae69e40e0ee"></a><!-- doxytag: member="QGLViewer::setSnapshotFileName" ref="a15be68d137eca013942eae69e40e0ee" args="(const QString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotFileName           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets <a class="el" href="classQGLViewer.html#00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a>. 
</div>
</div><p>
<a class="anchor" name="82043998256d08163f79ceee83278e14"></a><!-- doxytag: member="QGLViewer::setSnapshotFormat" ref="82043998256d08163f79ceee83278e14" args="(const QString &amp;format)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotFormat           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>format</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#bbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a>. 
</div>
</div><p>
<a class="anchor" name="feb307bbd1a56cdfb3749f699d4af03c"></a><!-- doxytag: member="QGLViewer::setSnapshotCounter" ref="feb307bbd1a56cdfb3749f699d4af03c" args="(int counter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotCounter           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>counter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a>. 
</div>
</div><p>
<a class="anchor" name="b64b04b76b1f35ee1b3f07fa747dc9a0"></a><!-- doxytag: member="QGLViewer::setSnapshotQuality" ref="b64b04b76b1f35ee1b3f07fa747dc9a0" args="(int quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotQuality           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>quality</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#50685165e76c57dc87dea3c84b7e5be0">snapshotQuality()</a>. 
</div>
</div><p>
<a class="anchor" name="c9c409fd034bc5ab42aacfa4c23fe55c"></a><!-- doxytag: member="QGLViewer::openSnapshotFormatDialog" ref="c9c409fd034bc5ab42aacfa4c23fe55c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openSnapshotFormatDialog           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a dialog that displays the different available snapshot formats.<p>
Then calls <a class="el" href="classQGLViewer.html#82043998256d08163f79ceee83278e14">setSnapshotFormat()</a> with the selected one (unless the user cancels).<p>
Returns <code>false</code> if the user presses the Cancel button and <code>true</code> otherwise. 
</div>
</div><p>
<a class="anchor" name="6435e0a64e14d04dce25e524051f8d69"></a><!-- doxytag: member="QGLViewer::bufferTextureId" ref="6435e0a64e14d04dce25e524051f8d69" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint bufferTextureId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the texture id of the texture created by <a class="el" href="classQGLViewer.html#eb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a>.<p>
Use glBindTexture() to use this texture. Note that this is already done by <a class="el" href="classQGLViewer.html#eb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a>.<p>
Returns <code>0</code> is <a class="el" href="classQGLViewer.html#eb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a> was never called or if the texure was deleted using glDeleteTextures() since then. 
</div>
</div><p>
<a class="anchor" name="c60a0831696a80344fd04b2fba039f48"></a><!-- doxytag: member="QGLViewer::bufferTextureMaxU" ref="c60a0831696a80344fd04b2fba039f48" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float bufferTextureMaxU           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the texture coordinate corresponding to the u extremum of the bufferTexture.<p>
The bufferTexture is created by <a class="el" href="classQGLViewer.html#eb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a>. The texture size has powers of two dimensions and the buffer image hence only fills a part of it. This value corresponds to the u coordinate of the extremum right side of the buffer image.<p>
Use (0,0) to (<a class="el" href="classQGLViewer.html#c60a0831696a80344fd04b2fba039f48">bufferTextureMaxU()</a>, <a class="el" href="classQGLViewer.html#8d3ecfdb46f8971e46a0ab0f52c5bbf7">bufferTextureMaxV()</a>) texture coordinates to map the entire texture on a quad. 
</div>
</div><p>
<a class="anchor" name="8d3ecfdb46f8971e46a0ab0f52c5bbf7"></a><!-- doxytag: member="QGLViewer::bufferTextureMaxV" ref="8d3ecfdb46f8971e46a0ab0f52c5bbf7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float bufferTextureMaxV           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#c60a0831696a80344fd04b2fba039f48">bufferTextureMaxU()</a>, but for the v texture coordinate. 
</div>
</div><p>
<a class="anchor" name="eb1721bfb1c032ae68665808bb2f4453"></a><!-- doxytag: member="QGLViewer::copyBufferToTexture" ref="eb1721bfb1c032ae68665808bb2f4453" args="(GLint internalFormat, GLenum format=GL_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copyBufferToTexture           </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>internalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&nbsp;</td>
          <td class="paramname"> <em>format</em> = <code>GL_NONE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes a copy of the current buffer into a texture.<p>
Creates a texture (when needed) and uses glCopyTexSubImage2D() to directly copy the buffer in it.<p>
Use <code>internalFormat</code> and <code>format</code> to define the texture format and hence which and how components of the buffer are copied into the texture. See the glTexImage2D() documentation for details.<p>
When <code>format</code> is c GL_NONE (default), its value is set to <code>internalFormat</code>, which fits most cases. Typical <code>internalFormat</code> (and <code>format</code>) values are <code>GL_DEPTH_COMPONENT</code> and <code>GL_RGBA</code>. Use <code>GL_LUMINANCE</code> as the <code>internalFormat</code> and <code>GL_RED</code>, <code>GL_GREEN</code> or <code>GL_BLUE</code> as <code>format</code> to capture a single color component as a luminance (grey scaled) value. Note that <code>GL_STENCIL</code> is not supported as a format.<p>
The texture has dimensions which are powers of two. It is as small as possible while always being larger or equal to the current size of the widget. The buffer image hence does not entirely fill the texture: it is stuck to the lower left corner (corresponding to the (0,0) texture coordinates). Use <a class="el" href="classQGLViewer.html#c60a0831696a80344fd04b2fba039f48">bufferTextureMaxU()</a> and <a class="el" href="classQGLViewer.html#8d3ecfdb46f8971e46a0ab0f52c5bbf7">bufferTextureMaxV()</a> to get the upper right corner maximum u and v texture coordinates. Use <a class="el" href="classQGLViewer.html#6435e0a64e14d04dce25e524051f8d69">bufferTextureId()</a> to retrieve the id of the created texture.<p>
Here is how to display a grey-level image of the z-buffer: <div class="fragment"><pre class="fragment"><a class="code" href="classQGLViewer.html#eb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture</a>(GL_DEPTH_COMPONENT);

glMatrixMode(GL_TEXTURE);
glLoadIdentity();

glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
glEnable(GL_TEXTURE_2D);

<a class="code" href="classQGLViewer.html#5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem</a>(<span class="keyword">true</span>);

glBegin(GL_QUADS);
glTexCoord2f(0.0, 0.0);                                 glVertex2i(0, 0);
glTexCoord2f(<a class="code" href="classQGLViewer.html#c60a0831696a80344fd04b2fba039f48">bufferTextureMaxU</a>(), 0.0);                 glVertex2i(<a class="code" href="classQGLViewer.html#369399896761e31ae71db57fdd0ba431">width</a>(), 0);
glTexCoord2f(<a class="code" href="classQGLViewer.html#c60a0831696a80344fd04b2fba039f48">bufferTextureMaxU</a>(), <a class="code" href="classQGLViewer.html#8d3ecfdb46f8971e46a0ab0f52c5bbf7">bufferTextureMaxV</a>()); glVertex2i(<a class="code" href="classQGLViewer.html#369399896761e31ae71db57fdd0ba431">width</a>(), <a class="code" href="classQGLViewer.html#e26bcfe2f33f5873dbdfb6948cf1f59f">height</a>());
glTexCoord2f(0.0, <a class="code" href="classQGLViewer.html#8d3ecfdb46f8971e46a0ab0f52c5bbf7">bufferTextureMaxV</a>());                 glVertex2i(0, <a class="code" href="classQGLViewer.html#e26bcfe2f33f5873dbdfb6948cf1f59f">height</a>());
glEnd();

<a class="code" href="classQGLViewer.html#9cff22af974391604bff7f91df789138">stopScreenCoordinatesSystem</a>();

glDisable(GL_TEXTURE_2D);
</pre></div><p>
Use glReadBuffer() to select which buffer is copied into the texture. See also <code>glPixelTransfer()</code>, <code>glPixelZoom()</code> and <code>glCopyPixel()</code> for pixel color transformations during copy.<p>
Call <a class="el" href="classQGLViewer.html#1436277e13026c94601bbe37a2f1d262">makeCurrent()</a> before this method to make the OpenGL context active if needed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <code>GL_DEPTH_COMPONENT</code> format may not be supported by all hardware. It may sometimes be emulated in software, resulting in poor performances.<p>
The <a class="el" href="classQGLViewer.html#6435e0a64e14d04dce25e524051f8d69">bufferTextureId()</a> texture is binded at the end of this method. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d865668850fb0aa249e79f21d2e9d40e"></a><!-- doxytag: member="QGLViewer::animationIsStarted" ref="d865668850fb0aa249e79f21d2e9d40e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool animationIsStarted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>true</code> when the animation loop is started.<p>
During animation, an infinite loop calls <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> and then waits for <a class="el" href="classQGLViewer.html#700d9398d4293d9274766efa8b17917e">animationPeriod()</a> milliseconds before calling <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> again. And again.<p>
Use <a class="el" href="classQGLViewer.html#d5344a5f702678f309fafa0c699b2cf3">startAnimation()</a>, <a class="el" href="classQGLViewer.html#84c1367b486680bcf22987540e217cfb">stopAnimation()</a> or <a class="el" href="classQGLViewer.html#67be4f5d4065852e7f46a2fc6197c070">toggleAnimation()</a> to change this value.<p>
See the <a href="../examples/animation.html">animation example</a> for illustration. 
</div>
</div><p>
<a class="anchor" name="700d9398d4293d9274766efa8b17917e"></a><!-- doxytag: member="QGLViewer::animationPeriod" ref="700d9398d4293d9274766efa8b17917e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int animationPeriod           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The animation loop period, in milliseconds.<p>
When <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>, this is delay waited after <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> to call <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> again. Default value is 40 milliseconds (25 Hz).<p>
This value will define the <a class="el" href="classQGLViewer.html#6fde4d85dfc5338aa237ba1eb505e975">currentFPS()</a> when <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a> (provided that your <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> methods are fast enough).<p>
If you want to know the maximum possible frame rate of your machine on a given scene, <a class="el" href="classQGLViewer.html#a37d4e0afe6a47e8f4f828ed41072176">setAnimationPeriod()</a> to <code>0</code>, and <a class="el" href="classQGLViewer.html#d5344a5f702678f309fafa0c699b2cf3">startAnimation()</a> (keyboard shortcut is <code>Enter</code>). The display will then be updated as often as possible, and the frame rate will be meaningful.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This value is taken into account only the next time you call <a class="el" href="classQGLViewer.html#d5344a5f702678f309fafa0c699b2cf3">startAnimation()</a>. If <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>, you should <a class="el" href="classQGLViewer.html#84c1367b486680bcf22987540e217cfb">stopAnimation()</a> first. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a37d4e0afe6a47e8f4f828ed41072176"></a><!-- doxytag: member="QGLViewer::setAnimationPeriod" ref="a37d4e0afe6a47e8f4f828ed41072176" args="(int period)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAnimationPeriod           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>period</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#700d9398d4293d9274766efa8b17917e">animationPeriod()</a>, in milliseconds. 
</div>
</div><p>
<a class="anchor" name="d5344a5f702678f309fafa0c699b2cf3"></a><!-- doxytag: member="QGLViewer::startAnimation" ref="d5344a5f702678f309fafa0c699b2cf3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startAnimation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the animation loop. See <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>. 
</div>
</div><p>
<a class="anchor" name="84c1367b486680bcf22987540e217cfb"></a><!-- doxytag: member="QGLViewer::stopAnimation" ref="84c1367b486680bcf22987540e217cfb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stopAnimation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops animation. See <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>. 
</div>
</div><p>
<a class="anchor" name="64465ac69c7fe9f4f8519a57501c76c2"></a><!-- doxytag: member="QGLViewer::animate" ref="64465ac69c7fe9f4f8519a57501c76c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void animate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scene animation method.<p>
When <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>, this method is in charge of the scene update before each <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. Overload it to define how your scene evolves over time. The time should either be regularly incremented in this method (frame-rate independent animation) or computed from actual time (for instance using QTime::elapsed()) for real-time animations.<p>
Note that KeyFrameInterpolator (which regularly updates a Frame) do not use this method but rather rely on a QTimer signal-slot mechanism.<p>
See the <a href="../examples/animation.html">animation example</a> for an illustration. 
</div>
</div><p>
<a class="anchor" name="67be4f5d4065852e7f46a2fc6197c070"></a><!-- doxytag: member="QGLViewer::toggleAnimation" ref="67be4f5d4065852e7f46a2fc6197c070" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleAnimation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classQGLViewer.html#d5344a5f702678f309fafa0c699b2cf3">startAnimation()</a> or <a class="el" href="classQGLViewer.html#84c1367b486680bcf22987540e217cfb">stopAnimation()</a>, depending on <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>. 
</div>
</div><p>
<a class="anchor" name="252b68caec768d882a3fa78ecd1499db"></a><!-- doxytag: member="QGLViewer::viewerInitialized" ref="252b68caec768d882a3fa78ecd1499db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viewerInitialized           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init()</a> method.<p>
Connect this signal to the methods that need to be called to initialize your viewer or overload <a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init()</a>. 
</div>
</div><p>
<a class="anchor" name="7a712ca70a0b1c22af51363b786fc86e"></a><!-- doxytag: member="QGLViewer::drawNeeded" ref="7a712ca70a0b1c22af51363b786fc86e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawNeeded           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> method.<p>
Connect this signal to your main drawing method or overload <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. See the <a href="../examples/callback.html">callback example</a> for an illustration. 
</div>
</div><p>
<a class="anchor" name="fc74e28548768da157f2fe75bced2803"></a><!-- doxytag: member="QGLViewer::drawFinished" ref="fc74e28548768da157f2fe75bced2803" args="(bool automatic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawFinished           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>automatic</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted at the end of the <a class="el" href="classQGLViewer.html#c5cbfafb28ef4c0474ae96437294f547">QGLViewer::paintGL()</a> method, when frame is drawn.<p>
Can be used to notify an image grabbing process that the image is ready. A typical example is to connect this signal to the <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> method, so that a (numbered) snapshot is generated after each new display, in order to create a movie: <div class="fragment"><pre class="fragment">        connect(viewer, SIGNAL(<a class="code" href="classQGLViewer.html#fc74e28548768da157f2fe75bced2803">drawFinished</a>(<span class="keywordtype">bool</span>)), SLOT(<a class="code" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot</a>(<span class="keywordtype">bool</span>)));
</pre></div><p>
The <code>automatic</code> bool variable is always <code>true</code> and has been added so that the signal can be connected to <a class="el" href="classQGLViewer.html#1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> with an <code>automatic</code> value set to <code>true</code>. 
</div>
</div><p>
<a class="anchor" name="841503c97db5a51e33f8a7e56d4ca006"></a><!-- doxytag: member="QGLViewer::animateNeeded" ref="841503c97db5a51e33f8a7e56d4ca006" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void animateNeeded           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a> method.<p>
Connect this signal to your scene animation method or overload <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a>. 
</div>
</div><p>
<a class="anchor" name="64f461121859dc0c19e7af2d413935e0"></a><!-- doxytag: member="QGLViewer::helpRequired" ref="64f461121859dc0c19e7af2d413935e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helpRequired           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">QGLViewer::help()</a> method.<p>
Connect this signal to your own help method or overload <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a>. 
</div>
</div><p>
<a class="anchor" name="541cdbec67d0c5895cd6c77c01b0f89e"></a><!-- doxytag: member="QGLViewer::axisIsDrawnChanged" ref="541cdbec67d0c5895cd6c77c01b0f89e" args="(bool drawn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void axisIsDrawnChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#7d38e6f11078e886f7978525def15797">axisIsDrawn()</a> changes value. 
</div>
</div><p>
<a class="anchor" name="02d191cc46db491d9807266fe62b6178"></a><!-- doxytag: member="QGLViewer::gridIsDrawnChanged" ref="02d191cc46db491d9807266fe62b6178" args="(bool drawn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gridIsDrawnChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#ee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a> changes value. 
</div>
</div><p>
<a class="anchor" name="4b005fb3bda4582ce4ab7aeda6692699"></a><!-- doxytag: member="QGLViewer::FPSIsDisplayedChanged" ref="4b005fb3bda4582ce4ab7aeda6692699" args="(bool displayed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPSIsDisplayedChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>displayed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a> changes value. 
</div>
</div><p>
<a class="anchor" name="c0b30c0de291a24af638e8c1d6171943"></a><!-- doxytag: member="QGLViewer::textIsEnabledChanged" ref="c0b30c0de291a24af638e8c1d6171943" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void textIsEnabledChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a> changes value. 
</div>
</div><p>
<a class="anchor" name="38968d2f050efa14869c2e4de416b7b4"></a><!-- doxytag: member="QGLViewer::cameraIsEditedChanged" ref="38968d2f050efa14869c2e4de416b7b4" args="(bool edited)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cameraIsEditedChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>edited</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a> changes value.. 
</div>
</div><p>
<a class="anchor" name="9d7df8ab7c351e32da3c72b19c4585c0"></a><!-- doxytag: member="QGLViewer::stereoChanged" ref="9d7df8ab7c351e32da3c72b19c4585c0" args="(bool on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stereoChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>on</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a> changes value. 
</div>
</div><p>
<a class="anchor" name="b78f96913c9aede4854b0efccf53f983"></a><!-- doxytag: member="QGLViewer::pointSelected" ref="b78f96913c9aede4854b0efccf53f983" args="(const QMouseEvent *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pointSelected           </td>
          <td>(</td>
          <td class="paramtype">const QMouseEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted by <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a>.<p>
Connect this signal to your selection method or overload <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a>, or more probably simply <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>. 
</div>
</div><p>
<a class="anchor" name="959ca6df1731d57aa692af99abcd28d1"></a><!-- doxytag: member="QGLViewer::mouseGrabberChanged" ref="959ca6df1731d57aa692af99abcd28d1" args="(qglviewer::MouseGrabber *mouseGrabber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mouseGrabberChanged           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&nbsp;</td>
          <td class="paramname"> <em>mouseGrabber</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted by <a class="el" href="classQGLViewer.html#993285ef8a16ccbdc5d57a1264212712">setMouseGrabber()</a> when the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> is changed.<p>
<code>mouseGrabber</code> is a pointer to the new MouseGrabber. Note that this signal is emitted with a <code>NULL</code> parameter each time a MouseGrabber stops grabbing mouse. 
</div>
</div><p>
<a class="anchor" name="38ddb3cdf15e24de824a2d7a170ec915"></a><!-- doxytag: member="QGLViewer::helpString" ref="38ddb3cdf15e24de824a2d7a170ec915" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString helpString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the QString displayed in the <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window main tab.<p>
Overload this method to define your own help string, which should shortly describe your application and explain how it works. Rich-text (HTML) tags can be used (see QStyleSheet() documentation for available tags): <div class="fragment"><pre class="fragment">        QString myViewer::helpString()<span class="keyword"> const</span>
<span class="keyword">        </span>{
        QString text(<span class="stringliteral">"&lt;h2&gt;M y V i e w e r&lt;/h2&gt;"</span>);
        text += <span class="stringliteral">"Displays a &lt;b&gt;Scene&lt;/b&gt; using OpenGL. Move the camera using the mouse."</span>;
        <span class="keywordflow">return</span> text;
        }
</pre></div><p>
See also <a class="el" href="classQGLViewer.html#6d66b99a4c5a38ef0072f350b055201b">mouseString()</a> and <a class="el" href="classQGLViewer.html#0e20e13c1170d50b46b6fe2a49377690">keyboardString()</a>. 
</div>
</div><p>
<a class="anchor" name="6d66b99a4c5a38ef0072f350b055201b"></a><!-- doxytag: member="QGLViewer::mouseString" ref="6d66b99a4c5a38ef0072f350b055201b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString mouseString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a QString that describes the application mouse bindings, displayed in the <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Mouse</code> tab.<p>
Result is a table that describes custom application mouse binding descriptions defined using <a class="el" href="classQGLViewer.html#2e1e005bde20f65b7269e2dd4e978306">setMouseBindingDescription()</a> as well as standard mouse bindings (defined using <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#4198b3b668c342e39752bade04f78c64">setWheelBinding()</a>). See the <a href="../mouse.html">mouse page</a> for details on mouse bindings.<p>
See also <a class="el" href="classQGLViewer.html#38ddb3cdf15e24de824a2d7a170ec915">helpString()</a> and <a class="el" href="classQGLViewer.html#0e20e13c1170d50b46b6fe2a49377690">keyboardString()</a>. 
</div>
</div><p>
<a class="anchor" name="0e20e13c1170d50b46b6fe2a49377690"></a><!-- doxytag: member="QGLViewer::keyboardString" ref="0e20e13c1170d50b46b6fe2a49377690" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString keyboardString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a QString that describes the application keyboard shortcut bindings, and that will be displayed in the <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Keyboard</code> tab.<p>
Default value is a table that describes the custom shortcuts defined using <a class="el" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription()</a> as well as the <em>standard</em> <a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a> shortcuts (defined using <a class="el" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut()</a>). See the <a href="../keyboard.html">keyboard page</a> for details on key customization.<p>
See also <a class="el" href="classQGLViewer.html#38ddb3cdf15e24de824a2d7a170ec915">helpString()</a> and <a class="el" href="classQGLViewer.html#6d66b99a4c5a38ef0072f350b055201b">mouseString()</a>. 
</div>
</div><p>
<a class="anchor" name="97ee70a8770dc30d06c744b24eb2fcfc"></a><!-- doxytag: member="QGLViewer::help" ref="97ee70a8770dc30d06c744b24eb2fcfc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void help           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a modal help window that includes three tabs, respectively filled with <a class="el" href="classQGLViewer.html#38ddb3cdf15e24de824a2d7a170ec915">helpString()</a>, <a class="el" href="classQGLViewer.html#0e20e13c1170d50b46b6fe2a49377690">keyboardString()</a> and <a class="el" href="classQGLViewer.html#6d66b99a4c5a38ef0072f350b055201b">mouseString()</a>.<p>
Rich html-like text can be used (see the QStyleSheet documentation). This method is called when the user presses the <a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c19f5cb747b2e1f0ea781d2b1f2a5b4824">HELP</a> (default is 'H').<p>
Use <a class="el" href="classQGLViewer.html#f3af989be04f1d45b6ff3f748c2e9d4a">helpWidget()</a> to access to the help widget (to add/remove tabs, change layout...). The "About" button (<a class="el" href="classQGLViewer.html#f3af989be04f1d45b6ff3f748c2e9d4a">helpWidget()</a>-&gt;cornerWidget()) is connected to the <a class="el" href="classQGLViewer.html#f08b8ca0f43910754ecd5d314e3febf0">aboutQGLViewer()</a> slot.<p>
The <a class="el" href="classQGLViewer.html#64f461121859dc0c19e7af2d413935e0">helpRequired()</a> signal is emitted. 
</div>
</div><p>
<a class="anchor" name="f08b8ca0f43910754ecd5d314e3febf0"></a><!-- doxytag: member="QGLViewer::aboutQGLViewer" ref="f08b8ca0f43910754ecd5d314e3febf0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aboutQGLViewer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens an about dialog.<p>
Default implementation displays libQGLViewer version, copyright notice and web site. 
</div>
</div><p>
<a class="anchor" name="f3af989be04f1d45b6ff3f748c2e9d4a"></a><!-- doxytag: member="QGLViewer::helpWidget" ref="f3af989be04f1d45b6ff3f748c2e9d4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QTabWidget* helpWidget           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the help widget.<p>
Use this only if you want to directly modify the help widget. Otherwise use <a class="el" href="classQGLViewer.html#38ddb3cdf15e24de824a2d7a170ec915">helpString()</a>, <a class="el" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription()</a> and <a class="el" href="classQGLViewer.html#2e1e005bde20f65b7269e2dd4e978306">setMouseBindingDescription()</a> to customize the text displayed in the help window tabs. 
</div>
</div><p>
<a class="anchor" name="3efe88f982dbec7825725dd954991139"></a><!-- doxytag: member="QGLViewer::resizeGL" ref="3efe88f982dbec7825725dd954991139" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resizeGL           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback method used when the widget size is modified.<p>
If you overload this method, first call the inherited method. Also called when the widget is created, before its first display. 
</div>
</div><p>
<a class="anchor" name="2d3d45239c78255c23a70ca558b4d4f1"></a><!-- doxytag: member="QGLViewer::initializeGL" ref="2d3d45239c78255c23a70ca558b4d4f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initializeGL           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> OpenGL context and then calls user-defined <a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init()</a>.<p>
This method is automatically called once, before the first call to <a class="el" href="classQGLViewer.html#c5cbfafb28ef4c0474ae96437294f547">paintGL()</a>.<p>
Overload <a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init()</a> instead of this method to modify viewer specific OpenGL state or to create display lists.<p>
To make beginners' life easier and to simplify the examples, this method slightly modifies the standard OpenGL state: <div class="fragment"><pre class="fragment">glEnable(GL_LIGHT0);
glEnable(GL_LIGHTING);
glEnable(GL_DEPTH_TEST);
glEnable(GL_COLOR_MATERIAL);
</pre></div><p>
If you port an existing application to <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> and your display changes, you probably want to disable these flags in <a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init()</a> to get back to a standard OpenGL state. 
</div>
</div><p>
<a class="anchor" name="9339772ec5ac9fa929938109207f2863"></a><!-- doxytag: member="QGLViewer::init" ref="9339772ec5ac9fa929938109207f2863" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the viewer OpenGL context.<p>
This method is called before the first drawing and should be overloaded to initialize some of the OpenGL flags. The default implementation is empty. See <a class="el" href="classQGLViewer.html#2d3d45239c78255c23a70ca558b4d4f1">initializeGL()</a>.<p>
Typical usage include <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> initialization (<a class="el" href="classQGLViewer.html#da8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>), previous viewer state restoration (<a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>), OpenGL state modification and display list creation.<p>
Note that <a class="el" href="classQGLViewer.html#2d3d45239c78255c23a70ca558b4d4f1">initializeGL()</a> modifies the standard OpenGL context. These values can be restored back in this method.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>You should not call <a class="el" href="classQGLViewer.html#e12b7378efbffabc24a133ca1deb19ae">updateGL()</a> (or any method that calls it) in this method, as it will result in an infinite loop. The different <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> set methods (<a class="el" href="classQGLViewer.html#5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn()</a>, <a class="el" href="classQGLViewer.html#ad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed()</a>...) are protected against this problem and can safely be called.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>All the OpenGL specific initializations must be done in this method: the OpenGL context is not yet available in your viewer constructor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5cbfafb28ef4c0474ae96437294f547"></a><!-- doxytag: member="QGLViewer::paintGL" ref="c5cbfafb28ef4c0474ae96437294f547" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void paintGL           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Main paint method, inherited from <code>QGLWidget</code>.<p>
Calls the following methods, in that order: <ul>
<li><a class="el" href="classQGLViewer.html#9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a> (or <a class="el" href="classQGLViewer.html#43df4754781c2aaf3236d676401cec59">preDrawStereo()</a> if viewer <a class="el" href="classQGLViewer.html#2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>) : places the camera in the world coordinate system. </li>
<li><a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> (or <a class="el" href="classQGLViewer.html#8b6601997fe7a83e7cd041104d4b21d2">fastDraw()</a> when the camera is manipulated) : main drawing method. Should be overloaded. </li>
<li><a class="el" href="classQGLViewer.html#24f5dce22199f5eea71f034cae6ae4fa">postDraw()</a> : display of visual hints (world axis, FPS...) </li>
</ul>

</div>
</div><p>
<a class="anchor" name="9c6b3ec107b4f010cf1fcd8c51ca92e4"></a><!-- doxytag: member="QGLViewer::preDraw" ref="9c6b3ec107b4f010cf1fcd8c51ca92e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void preDraw           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets OpenGL state before <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>.<p>
Default behavior clears screen and sets the projection and modelView matrices: <div class="fragment"><pre class="fragment">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

<a class="code" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix</a>();
<a class="code" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#81053f822008b76bff7b1a41dceedf53">loadModelViewMatrix</a>();
</pre></div><p>
Emits the <a class="el" href="classQGLViewer.html#7a712ca70a0b1c22af51363b786fc86e">drawNeeded()</a> signal once this is done (see the <a href="../examples/callback.html">callback example</a>). 
</div>
</div><p>
<a class="anchor" name="43df4754781c2aaf3236d676401cec59"></a><!-- doxytag: member="QGLViewer::preDrawStereo" ref="43df4754781c2aaf3236d676401cec59" args="(bool leftBuffer=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void preDrawStereo           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>leftBuffer</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called before <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> (instead of <a class="el" href="classQGLViewer.html#9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a>) when viewer <a class="el" href="classQGLViewer.html#2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>.<p>
Same as <a class="el" href="classQGLViewer.html#9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a> except that the glDrawBuffer() is set to <code>GL_BACK_LEFT</code> or <code>GL_BACK_RIGHT</code> depending on <code>leftBuffer</code>, and it uses <a class="el" href="classqglviewer_1_1Camera.html#79dac3c1bcb983c9025710b333f063a3">qglviewer::Camera::loadProjectionMatrixStereo()</a> and <a class="el" href="classqglviewer_1_1Camera.html#47c0f19a566d045a2872b44014be8392">qglviewer::Camera::loadModelViewMatrixStereo()</a> instead. 
</div>
</div><p>
<a class="anchor" name="bc45d04e5f5ce1fbd68f920fcdb2d0e0"></a><!-- doxytag: member="QGLViewer::draw" ref="bc45d04e5f5ce1fbd68f920fcdb2d0e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void draw           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The core method of the viewer, that draws the scene.<p>
If you build a class that inherits from <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>, this is the method you want to overload. See the <a href="../examples/simpleViewer.html">simpleViewer example</a> for an illustration.<p>
The camera modelView matrix set in <a class="el" href="classQGLViewer.html#9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a> converts from the world to the camera coordinate systems. Vertices given in <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> can then be considered as being given in the world coordinate system. The camera is moved in this world using the mouse. This representation is much more intuitive than the default camera-centric OpenGL standard.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>The <code>GL_PROJECTION</code> matrix should not be modified by this method, to correctly display visual hints (axis, grid, FPS...) in <a class="el" href="classQGLViewer.html#24f5dce22199f5eea71f034cae6ae4fa">postDraw()</a>. Use push/pop or call <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;loadProjectionMatrix() at the end of <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> if you need to change the projection matrix (unlikely). On the other hand, the <code>GL_MODELVIEW</code> matrix can be modified and left in a arbitrary state. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b6601997fe7a83e7cd041104d4b21d2"></a><!-- doxytag: member="QGLViewer::fastDraw" ref="8b6601997fe7a83e7cd041104d4b21d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fastDraw           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws a simplified version of the scene to guarantee interactive camera displacements.<p>
This method is called instead of <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> when the <a class="el" href="classqglviewer_1_1Camera.html#d367db656b03fe0bc87b021801d66b75">qglviewer::Camera::frame()</a> is <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#032c48e2e7cdced01dea0cb7eca14022">qglviewer::ManipulatedCameraFrame::isManipulated()</a>. Default implementation simply calls <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>.<p>
Overload this method if your scene is too complex to allow for interactive camera manipulation. See the <a href="../examples/fastDraw.html">fastDraw example</a> for an illustration. 
</div>
</div><p>
<a class="anchor" name="24f5dce22199f5eea71f034cae6ae4fa"></a><!-- doxytag: member="QGLViewer::postDraw" ref="24f5dce22199f5eea71f034cae6ae4fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void postDraw           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called after <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> to draw viewer visual hints.<p>
Default implementation displays axis, grid, FPS... when the respective flags are sets.<p>
See the <a href="../examples/multiSelect.html">multiSelect</a> and <a href="../examples/contribs.html#thumbnail">thumbnail</a> examples for an overloading illustration.<p>
The GLContext (color, LIGHTING, BLEND...) is <em>not</em> modified by this method, so that in <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>, the user can rely on the OpenGL context he defined. Respect this convention (by pushing/popping the different attributes) if you overload this method. 
</div>
</div><p>
<a class="anchor" name="991f0a076bd76a1ee5bda0df7fa474f4"></a><!-- doxytag: member="QGLViewer::mousePressEvent" ref="991f0a076bd76a1ee5bda0df7fa474f4" args="(QMouseEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mousePressEvent           </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QWidget</code> method.<p>
When the user clicks on the mouse: <ul>
<li>if a <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> is defined, <a class="el" href="classqglviewer_1_1MouseGrabber.html#56df172a6eff56ecc1a99d2e7d548d31">qglviewer::MouseGrabber::mousePressEvent()</a> is called, </li>
<li>otherwise, the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> or the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> interprets the mouse displacements, depending on mouse bindings.</li>
</ul>
Mouse bindings customization can be achieved using <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#4198b3b668c342e39752bade04f78c64">setWheelBinding()</a>. See the <a href="../mouse.html">mouse page</a> for a complete description of mouse bindings.<p>
See the <a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> documentation for an example of more complex mouse behavior customization using overloading.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> is a <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>, the modifier keys are not taken into account. This allows for a direct manipulation of the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> when the mouse hovers, which is probably what is expected. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88e672693c2cfdbaf9af942a58a8e1dd"></a><!-- doxytag: member="QGLViewer::mouseMoveEvent" ref="88e672693c2cfdbaf9af942a58a8e1dd" args="(QMouseEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mouseMoveEvent           </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QWidget</code> method.<p>
Mouse move event is sent to the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> (if any) or to the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> or the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>, depending on mouse bindings (see <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a>).<p>
If you want to define your own mouse behavior, do something like this: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Viewer::mousePressEvent(QMouseEvent* e)
{

<span class="comment">// Qt version 2 or 3 : use Qt::KeyButtonMask and Qt::MouseButtonMask to separate the modifiers</span>
<span class="comment">// (Qt::ControlButton/Qt::AltButton/Qt::ShiftButton/Qt::MetaButton) from the mouse buttons</span>
<span class="comment">// (Qt::LeftButton/Qt::MidButton/Qt::RightButton) in state().</span>
<span class="keywordflow">if</span> ( ((e-&gt;state() &amp; Qt::KeyButtonMask) == myModifiers) &amp;&amp;
((e-&gt;state() &amp; Qt::MouseButtonMask) == myButton) )

<span class="comment">// With Qt 4, use instead :</span>
<span class="keywordflow">if</span> ((e-&gt;button() == myButton) &amp;&amp; (e-&gt;modifiers() == myModifiers))
myMouseBehavior = <span class="keyword">true</span>;
<span class="keywordflow">else</span>
<a class="code" href="classQGLViewer.html#991f0a076bd76a1ee5bda0df7fa474f4">QGLViewer::mousePressEvent</a>(e);
}

<span class="keywordtype">void</span> Viewer::mouseMoveEvent(QMouseEvent *e)
{
<span class="keywordflow">if</span> (myMouseBehavior)
<span class="comment">// Use e-&gt;x() and e-&gt;y() as you want...</span>
<span class="keywordflow">else</span>
<a class="code" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">QGLViewer::mouseMoveEvent</a>(e);
}

<span class="keywordtype">void</span> Viewer::mouseReleaseEvent(QMouseEvent* e)
{
<span class="keywordflow">if</span> (myMouseBehavior)
myMouseBehavior = <span class="keyword">false</span>;
<span class="keywordflow">else</span>
<a class="code" href="classQGLViewer.html#158642bef03883cc4157b8b40e1aa0ea">QGLViewer::mouseReleaseEvent</a>(e);
}
</pre></div> 
</div>
</div><p>
<a class="anchor" name="158642bef03883cc4157b8b40e1aa0ea"></a><!-- doxytag: member="QGLViewer::mouseReleaseEvent" ref="158642bef03883cc4157b8b40e1aa0ea" args="(QMouseEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mouseReleaseEvent           </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QWidget</code> method.<p>
Calls the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>, <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> or manipulatedFrame <code>mouseReleaseEvent</code> method.<p>
See the <a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> documentation for an example of mouse behavior customization. 
</div>
</div><p>
<a class="anchor" name="a11ba8137b62942cede01c57aade3073"></a><!-- doxytag: member="QGLViewer::mouseDoubleClickEvent" ref="a11ba8137b62942cede01c57aade3073" args="(QMouseEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mouseDoubleClickEvent           </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QWidget</code> method.<p>
The behavior of the mouse double click depends on the mouse binding. See <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> and the <a href="../mouse.html">mouse page</a>. 
</div>
</div><p>
<a class="anchor" name="bc61c05ed30a94d66ab715c718532c03"></a><!-- doxytag: member="QGLViewer::wheelEvent" ref="bc61c05ed30a94d66ab715c718532c03" args="(QWheelEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wheelEvent           </td>
          <td>(</td>
          <td class="paramtype">QWheelEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QWidget</code> method.<p>
If defined, the wheel event is sent to the <a class="el" href="classQGLViewer.html#6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>. It is otherwise sent according to wheel bindings (see <a class="el" href="classQGLViewer.html#4198b3b668c342e39752bade04f78c64">setWheelBinding()</a>). 
</div>
</div><p>
<a class="anchor" name="2cc4c898ca007c7cc0ebb7791aa3e5b3"></a><!-- doxytag: member="QGLViewer::keyPressEvent" ref="2cc4c898ca007c7cc0ebb7791aa3e5b3" args="(QKeyEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void keyPressEvent           </td>
          <td>(</td>
          <td class="paramtype">QKeyEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QWidget</code> method.<p>
Default keyboard shortcuts are defined using <a class="el" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut()</a>. Overload this method to implement a specific keyboard binding. Call the original method if you do not catch the event to preserve the viewer default key bindings: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Viewer::keyPressEvent(QKeyEvent *e)
{
<span class="comment">// With Qt 2 or 3, you would retrieve modifiers keys using :</span>
<span class="comment">// const Qt::ButtonState modifiers = (Qt::ButtonState)(e-&gt;state() &amp; Qt::KeyButtonMask);</span>

<span class="comment">// Defines the Alt+R shortcut. Call updateGL to refresh display.</span>
<span class="keywordflow">if</span> ((e-&gt;key() == Qt::Key_R) &amp;&amp; (e-&gt;modifiers() == Qt::AltModifier))
{
myResetFunction();
updateGL();
}
<span class="keywordflow">else</span>
<a class="code" href="classQGLViewer.html#2cc4c898ca007c7cc0ebb7791aa3e5b3">QGLViewer::keyPressEvent</a>(e);
}
</pre></div> When you define a new keyboard shortcut, use <a class="el" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription()</a> to provide a short description which is displayed in the <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window Keyboard tab. See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for an illustration.<p>
See also QGLWidget::keyReleaseEvent(). 
</div>
</div><p>
<a class="anchor" name="cd355cb527aec563bbefc75edc9deffd"></a><!-- doxytag: member="QGLViewer::timerEvent" ref="cd355cb527aec563bbefc75edc9deffd" args="(QTimerEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timerEvent           </td>
          <td>(</td>
          <td class="paramtype">QTimerEvent *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QObject</code> method.<p>
If <a class="el" href="classQGLViewer.html#d865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>, calls <a class="el" href="classQGLViewer.html#64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. 
</div>
</div><p>
<a class="anchor" name="3fb8c90e5c48e6ccc09f9125aa86943e"></a><!-- doxytag: member="QGLViewer::closeEvent" ref="3fb8c90e5c48e6ccc09f9125aa86943e" args="(QCloseEvent *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void closeEvent           </td>
          <td>(</td>
          <td class="paramtype">QCloseEvent *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloading of the <code>QWidget</code> method.<p>
Saves the viewer state using <a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> and then calls QGLWidget::closeEvent(). 
</div>
</div><p>
<a class="anchor" name="0015a8bc683c3a1483c5ad638550bdde"></a><!-- doxytag: member="QGLViewer::selectedName" ref="0015a8bc683c3a1483c5ad638550bdde" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectedName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name (an integer value) of the entity that was last selected by <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a>. This value is set by <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a>. See the <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> documentation for details.<p>
As a convention, this method returns -1 if the <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> was empty, meaning that no object was selected.<p>
Return value is -1 before the first call to <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a>. This value is modified using <a class="el" href="classQGLViewer.html#eaa1327270d0bcdf991874e7d741afd5">setSelectedName()</a>. 
</div>
</div><p>
<a class="anchor" name="13e131ca92b021fb8946a9af0b0c269d"></a><!-- doxytag: member="QGLViewer::selectBufferSize" ref="13e131ca92b021fb8946a9af0b0c269d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectBufferSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> size.<p>
See the <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> documentation for details. Use <a class="el" href="classQGLViewer.html#e8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize()</a> to change this value.<p>
Default value is 4000 (i.e. 1000 objects in selection region, since each object pushes 4 values). This size should be over estimated to prevent a buffer overflow when many objects are drawn under the mouse cursor. 
</div>
</div><p>
<a class="anchor" name="16ad2d80aa574d32ae8237f56cfd7e06"></a><!-- doxytag: member="QGLViewer::selectRegionWidth" ref="16ad2d80aa574d32ae8237f56cfd7e06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectRegionWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the width (in pixels) of a selection frustum, centered on the mouse cursor, that is used to select objects.<p>
The height of the selection frustum is defined by <a class="el" href="classQGLViewer.html#db0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>.<p>
The objects that will be drawn in this region by <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> will be recorded in the <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a>. <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> then analyzes this buffer and <a class="el" href="classQGLViewer.html#eaa1327270d0bcdf991874e7d741afd5">setSelectedName()</a> to the name of the closest object. See the gluPickMatrix() documentation for details.<p>
The default value is 3, which is adapted to standard applications. A smaller value results in a more precise selection but the user has to be careful for small feature selection.<p>
See the <a href="../examples/multiSelect.html">multiSelect example</a> for an illustration. 
</div>
</div><p>
<a class="anchor" name="db0b15577ca9bcabc99c78601cfce59f"></a><!-- doxytag: member="QGLViewer::selectRegionHeight" ref="db0b15577ca9bcabc99c78601cfce59f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectRegionHeight           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See the <a class="el" href="classQGLViewer.html#16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a> documentation. Default value is 3 pixels. 
</div>
</div><p>
<a class="anchor" name="87015f560fd54b358d185482ae82eec3"></a><!-- doxytag: member="QGLViewer::selectBuffer" ref="87015f560fd54b358d185482ae82eec3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint* selectBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to an array of <code>GLuint</code>.<p>
This buffer is used by the <code>GL_SELECT</code> mode in <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> to perform object selection. The buffer size can be modified using <a class="el" href="classQGLViewer.html#e8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize()</a>. If you overload <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a>, you will analyze the content of this buffer. See the <code>glSelectBuffer()</code> man page for details. 
</div>
</div><p>
<a class="anchor" name="3b20e4da96e6d8c038a08c7d34d182c6"></a><!-- doxytag: member="QGLViewer::select" ref="3b20e4da96e6d8c038a08c7d34d182c6" args="(const QMouseEvent *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select           </td>
          <td>(</td>
          <td class="paramtype">const QMouseEvent *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple wrapper method: calls <code>select</code>(event-&gt;pos()).<p>
Emits <code>pointSelected(e)</code> which is useful only if you rely on the Qt signal-slot mechanism and you did not overload <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>. If you choose to derive your own viewer class, simply overload <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> (or probably simply <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>, see the <a href="../examples/select.html">select example</a>) to implement your selection mechanism.<p>
This method is called when you use the <a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f1697a91b22c2369eb2ba427c2d193329">SELECT</a> mouse binding(s) (default is Shift + left button). Use <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> to change this. 
</div>
</div><p>
<a class="anchor" name="f2ed82c063635ce439d9c73223e20fd6"></a><!-- doxytag: member="QGLViewer::select" ref="f2ed82c063635ce439d9c73223e20fd6" args="(const QPoint &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select           </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method performs a selection in the scene from pixel coordinates.<p>
It is called when the user clicks on the <a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f1697a91b22c2369eb2ba427c2d193329">SELECT</a> <a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">QGLViewer::ClickAction</a> binded button(s) (default is Shift + LeftButton).<p>
This method successively calls four other methods: <div class="fragment"><pre class="fragment"><a class="code" href="classQGLViewer.html#f0a48cc50f194926bad38d4924162116">beginSelection</a>(point);
<a class="code" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames</a>();
<a class="code" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection</a>(point);
<a class="code" href="classQGLViewer.html#3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection</a>(point);
</pre></div><p>
The default implementation of these methods is as follows (see the methods' documentation for more details):<p>
<ul>
<li><a class="el" href="classQGLViewer.html#f0a48cc50f194926bad38d4924162116">beginSelection()</a> sets the <code>GL_SELECT</code> mode with the appropriate picking matrices. A rectangular frustum (of size defined by <a class="el" href="classQGLViewer.html#16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a> and <a class="el" href="classQGLViewer.html#db0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>) centered on <code>point</code> is created.</li>
</ul>
<ul>
<li><a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> is empty and should be overloaded. It draws each selectable object of the scene, enclosed by calls to <code>glPushName()</code> / <code>glPopName()</code> to tag the object with an integer id.</li>
</ul>
<ul>
<li><a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> then restores <code>GL_RENDER</code> mode and analyzes the <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> to set in <a class="el" href="classQGLViewer.html#0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> the id of the object that was drawn in the region. If several object are in the region, the closest one in the depth buffer is chosen. If no object has been drawn under cursor, <a class="el" href="classQGLViewer.html#0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> is set to -1.</li>
</ul>
<ul>
<li><a class="el" href="classQGLViewer.html#3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection()</a> is empty and can be overloaded for possible signal/display/interface update.</li>
</ul>
See the <code>glSelectBuffer()</code> man page for details on this <code>GL_SELECT</code> mechanism.<p>
This default implementation is quite limited: only the closer object is selected, and only one level of names can be pushed. However, this reveals sufficient in many cases and you usually only have to overload <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> to implement a simple object selection process. See the <a href="../examples/select.html">select example</a> for an illustration.<p>
If you need a more complex selection process (such as a point, edge or triangle selection, which is easier with a 2 or 3 levels <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> heap, and which requires a finer depth sorting to privilege point over edge and edges over triangles), overload the <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> method. Use <a class="el" href="classQGLViewer.html#0bfc48a72feefc6c90bd187280853911">setSelectRegionWidth()</a>, <a class="el" href="classQGLViewer.html#e830757057c41db506410fd3c332d7dd">setSelectRegionHeight()</a> and <a class="el" href="classQGLViewer.html#e8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize()</a> to tune the select buffer configuration. See the <a href="../examples/multiSelect.html">multiSelect example</a> for an illustration.<p>
<code>point</code> is the center pixel (origin in the upper left corner) of the selection region. Use <a class="el" href="classqglviewer_1_1Camera.html#706d401cffa41e0e30864e59007f005f">qglviewer::Camera::convertClickToLine()</a> to transform these coordinates in a 3D ray if you want to perform an analytical intersection.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd><code>GL_SELECT</code> mode seems to report wrong results when used in conjunction with backface culling. If you encounter problems try to <code>glDisable(GL_CULL_FACE)</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e8af6dc4a89202211b764647caf3d1f3"></a><!-- doxytag: member="QGLViewer::setSelectBufferSize" ref="e8af6dc4a89202211b764647caf3d1f3" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectBufferSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#13e131ca92b021fb8946a9af0b0c269d">selectBufferSize()</a>.<p>
The previous <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> is deleted and a new one is created. 
</div>
</div><p>
<a class="anchor" name="0bfc48a72feefc6c90bd187280853911"></a><!-- doxytag: member="QGLViewer::setSelectRegionWidth" ref="0bfc48a72feefc6c90bd187280853911" args="(int width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectRegionWidth           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a>. 
</div>
</div><p>
<a class="anchor" name="e830757057c41db506410fd3c332d7dd"></a><!-- doxytag: member="QGLViewer::setSelectRegionHeight" ref="e830757057c41db506410fd3c332d7dd" args="(int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectRegionHeight           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#db0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>. 
</div>
</div><p>
<a class="anchor" name="eaa1327270d0bcdf991874e7d741afd5"></a><!-- doxytag: member="QGLViewer::setSelectedName" ref="eaa1327270d0bcdf991874e7d741afd5" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectedName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the <a class="el" href="classQGLViewer.html#0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> value.<p>
Used in <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> during a selection. You should only call this method if you overload the <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> method. 
</div>
</div><p>
<a class="anchor" name="f0a48cc50f194926bad38d4924162116"></a><!-- doxytag: member="QGLViewer::beginSelection" ref="f0a48cc50f194926bad38d4924162116" args="(const QPoint &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beginSelection           </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method should prepare the selection. It is called by <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> before <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>.<p>
The default implementation uses the <code>GL_SELECT</code> mode to perform a selection. It uses <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> and <a class="el" href="classQGLViewer.html#13e131ca92b021fb8946a9af0b0c269d">selectBufferSize()</a> to define a <code>glSelectBuffer()</code>. The <code>GL_PROJECTION</code> is then set using <code>gluPickMatrix()</code>, with a window selection size defined by <a class="el" href="classQGLViewer.html#16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a> and <a class="el" href="classQGLViewer.html#db0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>. Finally, the <code>GL_MODELVIEW</code> matrix is set to the world coordinate system using <a class="el" href="classqglviewer_1_1Camera.html#81053f822008b76bff7b1a41dceedf53">qglviewer::Camera::loadModelViewMatrix()</a>. See the gluPickMatrix() documentation for details.<p>
You should not need to redefine this method (if you use the <code>GL_SELECT</code> mode to perform your selection), since this code is fairly classical and can be tuned. You are more likely to overload <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> if you want to use a more complex select buffer structure. 
</div>
</div><p>
<a class="anchor" name="528b238068a87472df8ac3a5b2481c55"></a><!-- doxytag: member="QGLViewer::drawWithNames" ref="528b238068a87472df8ac3a5b2481c55" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drawWithNames           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called by <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> and should draw selectable entities.<p>
Default implementation is empty. Overload and draw the different elements of your scene you want to be able to select. The default <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> implementation relies on the <code>GL_SELECT</code>, and requires that each selectable element is drawn within a <code>glPushName()</code> - <code>glPopName()</code> block. A typical usage would be (see the <a href="../examples/select.html">select example</a>): <div class="fragment"><pre class="fragment">        <span class="keywordtype">void</span> Viewer::drawWithNames()
        {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbObjects; ++i)
        {
        glPushName(i);
        object(i)-&gt;draw();
        glPopName();
        }
        }
</pre></div><p>
The resulting selected name is computed by <a class="el" href="classQGLViewer.html#0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a>, which <a class="el" href="classQGLViewer.html#eaa1327270d0bcdf991874e7d741afd5">setSelectedName()</a> to the integer id pushed by this method (a value of -1 means no selection). Use <a class="el" href="classQGLViewer.html#0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> to update your selection, probably in the <a class="el" href="classQGLViewer.html#3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection()</a> method.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>If your selected objects are points, do not use <code>glBegin(GL_POINTS)</code>; and <code>glVertex3fv()</code> in the above <code><a class="el" href="classQGLViewer.html#bc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a></code> method (not compatible with raster mode): use <code>glRasterPos3fv()</code> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d164809a99bbe6ff2fc0dee33fe0e91"></a><!-- doxytag: member="QGLViewer::endSelection" ref="0d164809a99bbe6ff2fc0dee33fe0e91" args="(const QPoint &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void endSelection           </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called by <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> after scene elements were drawn by <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>. It should analyze the selection result to determine which object is actually selected.<p>
The default implementation relies on <code>GL_SELECT</code> mode (see <a class="el" href="classQGLViewer.html#f0a48cc50f194926bad38d4924162116">beginSelection()</a>). It assumes that names were pushed and popped in <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>, and analyzes the <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> to find the name that corresponds to the closer (z min) object. It then <a class="el" href="classQGLViewer.html#eaa1327270d0bcdf991874e7d741afd5">setSelectedName()</a> to this value, or to -1 if the <a class="el" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer()</a> is empty (no object drawn in selection region). Use <a class="el" href="classQGLViewer.html#0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> (probably in the <a class="el" href="classQGLViewer.html#3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection()</a> method) to retrieve this value and update your data structure accordingly.<p>
This default implementation, although sufficient for many cases is however limited and you may have to overload this method. This will be the case if <a class="el" href="classQGLViewer.html#528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> uses several push levels in the name heap. A more precise depth selection, for instance privileging points over edges and triangles to avoid z precision problems, will also require an overloading. A typical implementation will look like: <div class="fragment"><pre class="fragment">glFlush();

<span class="comment">// Get the number of objects that were seen through the pick matrix frustum.</span>
<span class="comment">// Resets GL_RENDER mode.</span>
GLint nbHits = glRenderMode(GL_RENDER);

<span class="keywordflow">if</span> (nbHits &lt;= 0)
<a class="code" href="classQGLViewer.html#eaa1327270d0bcdf991874e7d741afd5">setSelectedName</a>(-1);
<span class="keywordflow">else</span>
{
<span class="comment">// Interpret results: each object created values in the selectBuffer().</span>
<span class="comment">// See the glSelectBuffer() man page for details on the buffer structure.</span>
<span class="comment">// The following code depends on your selectBuffer() structure.</span>
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbHits; ++i)
<span class="keywordflow">if</span> ((<a class="code" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer</a>())[i*4+1] &lt; zMin)
<a class="code" href="classQGLViewer.html#eaa1327270d0bcdf991874e7d741afd5">setSelectedName</a>((<a class="code" href="classQGLViewer.html#87015f560fd54b358d185482ae82eec3">selectBuffer</a>())[i*4+3])
}
</pre></div><p>
See the <a href="../examples/multiSelect.html">multiSelect example</a> for a multi-object selection implementation of this method. 
</div>
</div><p>
<a class="anchor" name="3dc0d3b212e04bcafd63e9c3eb214a6c"></a><!-- doxytag: member="QGLViewer::postSelection" ref="3dc0d3b212e04bcafd63e9c3eb214a6c" args="(const QPoint &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void postSelection           </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called at the end of the <a class="el" href="classQGLViewer.html#3b20e4da96e6d8c038a08c7d34d182c6">select()</a> procedure. It should finalize the selection process and update the data structure/interface/computation/display... according to the newly selected entity.<p>
The default implementation is empty. Overload this method if needed, and use <a class="el" href="classQGLViewer.html#0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> to retrieve the selected entity name (returns -1 if no object was selected). See the <a href="../examples/select.html">select example</a> for an illustration. 
</div>
</div><p>
<a class="anchor" name="b6dd5b47ea7d89e1f86c05c58d25c11d"></a><!-- doxytag: member="QGLViewer::shortcut" ref="b6dd5b47ea7d89e1f86c05c58d25c11d" args="(KeyboardAction action) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shortcut           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the keyboard shortcut associated to a given <a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a>.<p>
Result is an <code>int</code> defined using Qt enumerated values, as in <code>Qt::Key_Q</code> or <code>Qt::CTRL+QtKey_X</code>. Use Qt::MODIFIER_MASK to separate the key from the state keys. Returns <code>0</code> if the KeyboardAction is disabled (not binded). Set using <a class="el" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut()</a>.<p>
If you want to define keyboard shortcuts for custom actions (say, open a scene file), overload <a class="el" href="classQGLViewer.html#2cc4c898ca007c7cc0ebb7791aa3e5b3">keyPressEvent()</a> and then <a class="el" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription()</a>.<p>
These shortcuts and their descriptions are automatically included in the <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Keyboard</code> tab.<p>
See the <a href="../keyboard.html">keyboard page</a> for details and default values and the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for a practical illustration. 
</div>
</div><p>
<a class="anchor" name="dfe21e109b45f8c79f2c360bf35fb835"></a><!-- doxytag: member="QGLViewer::pathKey" ref="dfe21e109b45f8c79f2c360bf35fb835" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Qt::Key pathKey           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the keyboard key associated to camera Key Frame path <code>index</code>.<p>
Default values are F1..F12 for indexes 1..12.<p>
<a class="el" href="classQGLViewer.html#7c91f5b77f92266cff3fe4ef99847b93">addKeyFrameKeyboardModifiers()</a> (resp. <a class="el" href="classQGLViewer.html#02cb4ab51746a7bb14d1fab077e94ea7">playPathKeyboardModifiers()</a>) define the state key(s) that must be pressed with this key to add a KeyFrame to (resp. to play) the associated Key Frame path. If you quickly press twice the <a class="el" href="classQGLViewer.html#dfe21e109b45f8c79f2c360bf35fb835">pathKey()</a>, the path is reset (resp. deleted).<p>
Use <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;keyFrameInterpolator( <code>index</code> ) to retrieve the KeyFrameInterpolator that defines the path.<p>
If several keys are binded to a given <code>index</code> (see <a class="el" href="classQGLViewer.html#da7e68536b6593f8a8bde9a746c99c13">setPathKey()</a>), one of them is returned. Returns <code>0</code> if no key is associated with this index.<p>
See also the <a href="../keyboard.html">keyboard page</a>. 
</div>
</div><p>
<a class="anchor" name="7c91f5b77f92266cff3fe4ef99847b93"></a><!-- doxytag: member="QGLViewer::addKeyFrameKeyboardModifiers" ref="7c91f5b77f92266cff3fe4ef99847b93" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Qt::KeyboardModifiers addKeyFrameKeyboardModifiers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the keyboard modifiers that must be pressed with a <a class="el" href="classQGLViewer.html#dfe21e109b45f8c79f2c360bf35fb835">pathKey()</a> to add the current camera position to a KeyFrame path.<p>
It can be <code>Qt::NoModifier</code>, <code>Qt::ControlModifier</code>, <code>Qt::ShiftModifier</code>, <code>Qt::AltModifier</code>, <code>Qt::MetaModifier</code> or a combination of these (using the bitwise '|' operator).<p>
Default value is Qt::AltModifier. Defined using <a class="el" href="classQGLViewer.html#a9a5108680fffd096a3e086a3b8b45d4">setAddKeyFrameKeyboardModifiers()</a>.<p>
See also <a class="el" href="classQGLViewer.html#02cb4ab51746a7bb14d1fab077e94ea7">playPathKeyboardModifiers()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you use Qt version 2 or 3, the <code>Qt::KeyboardModifiers</code> is actually a <code>Qt::ButtonState</code>. The <code>Modifier</code> postfix is replaced by <code>Button</code> in the enums' names (<code>Qt::ControlButton</code>, <code>Qt::AltButton</code>, ...). </dd></dl>

</div>
</div><p>
<a class="anchor" name="02cb4ab51746a7bb14d1fab077e94ea7"></a><!-- doxytag: member="QGLViewer::playPathKeyboardModifiers" ref="02cb4ab51746a7bb14d1fab077e94ea7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Qt::KeyboardModifiers playPathKeyboardModifiers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the keyboard modifiers that must be pressed with a <a class="el" href="classQGLViewer.html#dfe21e109b45f8c79f2c360bf35fb835">pathKey()</a> to play a camera KeyFrame path.<p>
It can be <code>Qt::NoModifier</code>, <code>Qt::ControlModifier</code>, <code>Qt::ShiftModifier</code>, <code>Qt::AltModifier</code>, <code>Qt::MetaModifier</code> or a combination of these (using the bitwise '|' operator).<p>
Default value is Qt::NoModifier. Defined using <a class="el" href="classQGLViewer.html#7c941d66cf641971ef0bb99e998290dc">setPlayPathKeyboardModifiers()</a>.<p>
See also <a class="el" href="classQGLViewer.html#7c91f5b77f92266cff3fe4ef99847b93">addKeyFrameKeyboardModifiers()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you use Qt version 2 or 3, the <code>Qt::KeyboardModifiers</code> is actually a <code>Qt::ButtonState</code>. The <code>Modifier</code> postfix is replaced by <code>Button</code> in the enums' names (<code>Qt::ControlButton</code>, <code>Qt::AltButton</code>, ...). </dd></dl>

</div>
</div><p>
<a class="anchor" name="910dc7fa27de6f4d8e9e8ed7fa7a1667"></a><!-- doxytag: member="QGLViewer::setShortcut" ref="910dc7fa27de6f4d8e9e8ed7fa7a1667" args="(KeyboardAction action, int key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setShortcut           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the <a class="el" href="classQGLViewer.html#b6dd5b47ea7d89e1f86c05c58d25c11d">shortcut()</a> that triggers a given <a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a>.<p>
Here are some examples: <div class="fragment"><pre class="fragment"><span class="comment">// Press 'Q' to exit application</span>
<a class="code" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut</a>(<a class="code" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c17ff2639b181c08e5d9196a0303a72cd1">EXIT_VIEWER</a>, Qt::Key_Q);

<span class="comment">// Alt+M toggles camera mode</span>
<a class="code" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut</a>(<a class="code" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c191b759170cb0389695a3c219a9a69073">CAMERA_MODE</a>, Qt::ALT+Qt::Key_M);

<span class="comment">// The DISPLAY_FPS action is disabled</span>
<a class="code" href="classQGLViewer.html#910dc7fa27de6f4d8e9e8ed7fa7a1667">setShortcut</a>(<a class="code" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c17522d8401eb437769071ba3b1562ca97">DISPLAY_FPS</a>, 0);
</pre></div><p>
Only one shortcut can be assigned to a given <a class="el" href="classQGLViewer.html#7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a> (new bindings replace previous ones). If several KeyboardAction are binded to the same shortcut, only one of them is active. 
</div>
</div><p>
<a class="anchor" name="9e97204faca448653fad94a37024a488"></a><!-- doxytag: member="QGLViewer::setKeyDescription" ref="9e97204faca448653fad94a37024a488" args="(int key, QString description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setKeyDescription           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&nbsp;</td>
          <td class="paramname"> <em>description</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines a custom keyboard shortcut description, that will be displayed in the <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Keyboard</code> tab.<p>
The <code>key</code> definition is given as an <code>int</code> using Qt enumerated values. Set an empty <code>description</code> to remove a shortcut description: <div class="fragment"><pre class="fragment"><a class="code" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription</a>(Qt::Key_W, <span class="stringliteral">"Toggles wireframe display"</span>);
<a class="code" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription</a>(Qt::CTRL+Qt::Key_L, <span class="stringliteral">"Loads a new scene"</span>);
<span class="comment">// Removes a description</span>
<a class="code" href="classQGLViewer.html#9e97204faca448653fad94a37024a488">setKeyDescription</a>(Qt::CTRL+Qt::Key_C, <span class="stringliteral">""</span>);
</pre></div><p>
See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse example</a> for illustration and the <a href="../keyboard.html">keyboard page</a> for details. 
</div>
</div><p>
<a class="anchor" name="da7e68536b6593f8a8bde9a746c99c13"></a><!-- doxytag: member="QGLViewer::setPathKey" ref="da7e68536b6593f8a8bde9a746c99c13" args="(int key, int index=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPathKey           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#dfe21e109b45f8c79f2c360bf35fb835">pathKey()</a> associated with the camera Key Frame path <code>index</code>.<p>
Several keys can be binded to the same <code>index</code>. Use a negated <code>key</code> value to delete the binding (the <code>index</code> value is then ignored): <div class="fragment"><pre class="fragment"><span class="comment">// Press 'space' to play/pause/add/delete camera path of index 0.</span>
<a class="code" href="classQGLViewer.html#da7e68536b6593f8a8bde9a746c99c13">setPathKey</a>(Qt::Key_Space, 0);

<span class="comment">// Remove this binding</span>
<a class="code" href="classQGLViewer.html#da7e68536b6593f8a8bde9a746c99c13">setPathKey</a>(-Qt::Key_Space);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="7c941d66cf641971ef0bb99e998290dc"></a><!-- doxytag: member="QGLViewer::setPlayPathKeyboardModifiers" ref="7c941d66cf641971ef0bb99e998290dc" args="(Qt::KeyboardModifiers modifiers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPlayPathKeyboardModifiers           </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&nbsp;</td>
          <td class="paramname"> <em>modifiers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#02cb4ab51746a7bb14d1fab077e94ea7">playPathKeyboardModifiers()</a> value. 
</div>
</div><p>
<a class="anchor" name="a9a5108680fffd096a3e086a3b8b45d4"></a><!-- doxytag: member="QGLViewer::setAddKeyFrameKeyboardModifiers" ref="a9a5108680fffd096a3e086a3b8b45d4" args="(Qt::KeyboardModifiers modifiers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAddKeyFrameKeyboardModifiers           </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&nbsp;</td>
          <td class="paramname"> <em>modifiers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="classQGLViewer.html#7c91f5b77f92266cff3fe4ef99847b93">addKeyFrameKeyboardModifiers()</a> value. 
</div>
</div><p>
<a class="anchor" name="3bc7b6c4d3ca76c0faecfdbfd2ede69a"></a><!-- doxytag: member="QGLViewer::mouseAction" ref="3bc7b6c4d3ca76c0faecfdbfd2ede69a" args="(int state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a> mouseAction           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the MouseAction associated with the <code>state</code> mouse button(s) and keyboard modifiers. Returns <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753b20d5f27f63af5ea6e5b6af1112ecf8">NO_MOUSE_ACTION</a> if no action is associated.<p>
For instance, to know which motion corresponds to Alt+LeftButton, do: <div class="fragment"><pre class="fragment"><a class="code" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a> ma = <a class="code" href="classQGLViewer.html#3bc7b6c4d3ca76c0faecfdbfd2ede69a">mouseAction</a>(Qt::ALT + Qt::LeftButton);
<span class="keywordflow">if</span> (ma != <a class="code" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753b20d5f27f63af5ea6e5b6af1112ecf8">NO_MOUSE_ACTION</a>) ...
</pre></div><p>
Use <a class="el" href="classQGLViewer.html#3d400c0d0a5824e70d36b01f9b7211c1">mouseHandler()</a> to know which object (<a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a> or <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>) will perform this action. 
</div>
</div><p>
<a class="anchor" name="3d400c0d0a5824e70d36b01f9b7211c1"></a><!-- doxytag: member="QGLViewer::mouseHandler" ref="3d400c0d0a5824e70d36b01f9b7211c1" args="(int state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mouseHandler           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the MouseHandler associated with the <code>state</code>. If no action is associated, returns <code>-1</code>.<p>
For instance, to know which handler receives the Alt+LeftButton, do: <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> mh = <a class="code" href="classQGLViewer.html#3d400c0d0a5824e70d36b01f9b7211c1">mouseHandler</a>(Qt::ALT + Qt::LeftButton);
<span class="keywordflow">if</span> (mh == <a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a>) ...
</pre></div><p>
Use <a class="el" href="classQGLViewer.html#3bc7b6c4d3ca76c0faecfdbfd2ede69a">mouseAction()</a> to know which action (see the MouseAction enum) will be perform on this handler. 
</div>
</div><p>
<a class="anchor" name="5e9d4c07afc73f5c8a0926641e1428ac"></a><!-- doxytag: member="QGLViewer::mouseButtonState" ref="5e9d4c07afc73f5c8a0926641e1428ac" args="(MouseHandler handler, MouseAction action, bool withConstraint=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mouseButtonState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>withConstraint</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mouse buttons and keyboard modifiers (if any) that have to be used to activate <code>action</code> on <code>handler</code> (with constraint or not).<p>
If no state triggers the action, returns Qt::NoButton which is an impossible case since at least one mouse button has to be specified in <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a>.<p>
To know which keys and mouse buttons have to be pressed to translate the camera, use tests like: <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> bs = <a class="code" href="classQGLViewer.html#5e9d4c07afc73f5c8a0926641e1428ac">mouseButtonState</a>(<a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a>, <a class="code" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875bc6501410409b0638909b580970b35f7">TRANSLATE</a>);
<span class="keywordflow">if</span> (bs &amp; Qt::RightButton) ... <span class="comment">// Right button needed to translate the camera</span>
<span class="keywordflow">if</span> (bs &amp; Qt::AltModifier)   ... <span class="comment">// Alt key needed (use AltModifier with Qt version 2 or 3)</span>
<span class="keywordflow">if</span> (bs &amp; Qt::KeyboardModifierMask == Qt::NoButton) ... <span class="comment">// No keyboard modifier needed</span>
</pre></div><p>
Note that mouse bindings are displayed in the 'Mouse' help window tab.<p>
See also <a class="el" href="classQGLViewer.html#3bc7b6c4d3ca76c0faecfdbfd2ede69a">mouseAction()</a> and <a class="el" href="classQGLViewer.html#3d400c0d0a5824e70d36b01f9b7211c1">mouseHandler()</a>. 
</div>
</div><p>
<a class="anchor" name="77651b87caa33aaa234457b1ef784e2a"></a><!-- doxytag: member="QGLViewer::clickAction" ref="77651b87caa33aaa234457b1ef784e2a" args="(int state, bool doubleClick, Qt::MouseButtons buttonsBefore) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">QGLViewer::ClickAction</a> clickAction           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doubleClick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&nbsp;</td>
          <td class="paramname"> <em>buttonsBefore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#3bc7b6c4d3ca76c0faecfdbfd2ede69a">mouseAction()</a>, but for the ClickAction set using <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a>. 
</div>
</div><p>
<a class="anchor" name="0fbf5d9d33985397f382ee2706c5898b"></a><!-- doxytag: member="QGLViewer::getClickButtonState" ref="0fbf5d9d33985397f382ee2706c5898b" args="(ClickAction action, int &amp;state, bool &amp;doubleClick, Qt::MouseButtons &amp;buttonsBefore) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getClickButtonState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">ClickAction</a>&nbsp;</td>
          <td class="paramname"> <em>ca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>doubleClick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons &amp;&nbsp;</td>
          <td class="paramname"> <em>buttonsBefore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="classQGLViewer.html#5e9d4c07afc73f5c8a0926641e1428ac">mouseButtonState()</a>, but for ClickAction.<p>
The results of the query are returned in the <code>state</code>, <code>doubleClick</code> and <code>buttonsBefore</code> parameters. If the ClickAction is not associated to any mouse button, <code>Qt::NoButton</code> is returned in <code>state</code>. If several mouse buttons trigger in the ClickAction, one of them is returned. 
</div>
</div><p>
<a class="anchor" name="aeb802e1db589dad89db8300e82454f4"></a><!-- doxytag: member="QGLViewer::wheelAction" ref="aeb802e1db589dad89db8300e82454f4" args="(Qt::KeyboardModifiers modifiers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a> wheelAction           </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&nbsp;</td>
          <td class="paramname"> <em>modifiers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#3bc7b6c4d3ca76c0faecfdbfd2ede69a">mouseAction()</a>, but for the wheel action.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you use Qt version 2 or 3, <code>modifiers</code> is actually a <code>Qt::ButtonState</code>. The <code>Modifier</code> postfix is replaced by <code>Button</code> in the enums' names (<code>Qt::ControlButton</code>, <code>Qt::AltButton</code>, Qt::ShiftButton, Qt::MetaButton). </dd></dl>

</div>
</div><p>
<a class="anchor" name="24751ec23d337eb0fb9851e8cb140502"></a><!-- doxytag: member="QGLViewer::wheelHandler" ref="24751ec23d337eb0fb9851e8cb140502" args="(Qt::KeyboardModifiers modifiers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wheelHandler           </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&nbsp;</td>
          <td class="paramname"> <em>modifiers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#3d400c0d0a5824e70d36b01f9b7211c1">mouseHandler()</a> but for the wheel action. See also <a class="el" href="classQGLViewer.html#aeb802e1db589dad89db8300e82454f4">wheelAction()</a>. 
</div>
</div><p>
<a class="anchor" name="253566e1950c2c0cfe69bdb6c42258d6"></a><!-- doxytag: member="QGLViewer::wheelButtonState" ref="253566e1950c2c0cfe69bdb6c42258d6" args="(MouseHandler handler, MouseAction action, bool withConstraint=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wheelButtonState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>withConstraint</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classQGLViewer.html#5e9d4c07afc73f5c8a0926641e1428ac">mouseButtonState()</a>, but for the wheel.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Returns -1 when no Qt::ButtonState was associated with this <code>handler/</code> <code>action/</code> <code>withConstraint</code> combination (<a class="el" href="classQGLViewer.html#5e9d4c07afc73f5c8a0926641e1428ac">mouseButtonState()</a> would return Qt::NoButton instead). </dd></dl>

</div>
</div><p>
<a class="anchor" name="218f2279fd64d5841b5ae2fc67d74274"></a><!-- doxytag: member="QGLViewer::setMouseBinding" ref="218f2279fd64d5841b5ae2fc67d74274" args="(int state, MouseHandler handler, MouseAction action, bool withConstraint=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBinding           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>withConstraint</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associates a MouseAction to any mouse button and keyboard modifiers <code>state</code> combination. The receiver of the mouse events is a MouseHandler (<a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a> or <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>).<p>
The parameters should read: when the <code>state</code> mouse button and keyboard modifiers are pressed, activate <code>action</code> on <code>handler</code>. If <code>withConstraint</code> is <code>true</code> (default), the <a class="el" href="classqglviewer_1_1Frame.html#0974dfe336ed84a20adb8c6cdf8dedd9">qglviewer::Frame::constraint()</a> associated with the Frame will be enforced during motion.<p>
Use the '|' bitwise operator or '+' to combine keys and buttons: <div class="fragment"><pre class="fragment"><span class="comment">// Left and right buttons together make a camera zoom: emulates a mouse third button if needed.</span>
<a class="code" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding</a>(Qt::LeftButton + Qt::RightButton, <a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a>, <a class="code" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201">ZOOM</a>);

<span class="comment">// Alt + Shift + Left button rotates the manipulatedFrame().</span>
<a class="code" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding</a>(Qt::ALT + Qt::SHIFT + Qt::LeftButton, <a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>, <a class="code" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753dcfe0046eb5876e287dbf0914819b16">ROTATE</a>);
</pre></div><p>
The list of all possible MouseAction, some binding examples and default bindings are provided in the <a href="../mouse.html">mouse page</a>.<p>
See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for an illustration.<p>
If no mouse button is specified in <code>state</code>, the binding is ignored. If an action was previously associated with this <code>state</code>, it is silently overwritten (use <a class="el" href="classQGLViewer.html#3bc7b6c4d3ca76c0faecfdbfd2ede69a">mouseAction()</a> before to know if the <code>state</code> is already binded).<p>
To remove a specific mouse binding, use code like: <div class="fragment"><pre class="fragment"><a class="code" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding</a>(myButtonAndModifiersCombo, myHandler, <a class="code" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef8753b20d5f27f63af5ea6e5b6af1112ecf8">NO_MOUSE_ACTION</a>);
</pre></div><p>
See also setMouseBinding(int, ClickAction, bool, int) and <a class="el" href="classQGLViewer.html#4198b3b668c342e39752bade04f78c64">setWheelBinding()</a>. 
</div>
</div><p>
<a class="anchor" name="3225418600cc93fb968e11ce195bee2d"></a><!-- doxytag: member="QGLViewer::setMouseBinding" ref="3225418600cc93fb968e11ce195bee2d" args="(int state, ClickAction action, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBinding           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#85fe75121d351785616b75b2c5661d8f">ClickAction</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doubleClick</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&nbsp;</td>
          <td class="paramname"> <em>buttonsBefore</em> = <code>Qt::NoButton</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associates a ClickAction to any mouse buttons and keyboard modifiers combination.<p>
The parameters should read: when the <code>state</code> mouse button(s) is (are) pressed (possibly with Alt, Control or Shift modifiers or any combination of these), and possibly with a <code>doubleClick</code>, perform <code>action</code>.<p>
If <code>buttonsBefore</code> is specified (valid only when <code>doubleClick</code> is <code>true</code>), then this mouse button(s) has to be pressed <em>before</em> the double click occurs in order to perform <code>action</code>.<p>
The list of all possible ClickAction, some binding examples and default bindings are listed in the <a href="../mouse.html">mouse page</a>. See also the <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> documentation.<p>
See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse example</a> for an illustration.<p>
The binding is ignored if no mouse button is specified in <code>state</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you use Qt version 2 or 3, the <code>buttonsBefore</code> is actually a Qt::ButtonState. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e1e005bde20f65b7269e2dd4e978306"></a><!-- doxytag: member="QGLViewer::setMouseBindingDescription" ref="2e1e005bde20f65b7269e2dd4e978306" args="(int state, QString description, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBindingDescription           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&nbsp;</td>
          <td class="paramname"> <em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doubleClick</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&nbsp;</td>
          <td class="paramname"> <em>buttonsBefore</em> = <code>Qt::NoButton</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides a custom mouse binding description, displayed in the <a class="el" href="classQGLViewer.html#97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window Mouse tab.<p>
<code>state</code> is a combination of Qt::KeyboardModifiers (<code>Qt::ControlModifier</code>, <code>Qt::AltModifier</code>, <code>Qt::ShiftModifier</code>, <code>Qt::MetaModifier</code>) and Qt::MouseButtons (<code>Qt::LeftButton</code>, <code>Qt::MidButton</code> and <code>Qt::RightButton</code>), combined using the <code>"|"</code> bitwise operator or simply "+". One can also use the shorter <code>Qt::ALT</code>, <code>Qt::CTRL</code>, <code>Qt::SHIFT</code> or <code>QT::META</code>.<p>
<code>doubleClick</code> indicates whether or not the user has to double click this button to perform the described action.<p>
Set an empty <code>description</code> to <em>remove</em> a mouse binding description.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Left and Right button together simulate a middle button</span>
<a class="code" href="classQGLViewer.html#2e1e005bde20f65b7269e2dd4e978306">setMouseBindingDescription</a>(Qt::LeftButton + Qt::RightButton, <span class="stringliteral">"Emulates a middle button"</span>);

<span class="comment">// A left button double click toggles full screen</span>
<a class="code" href="classQGLViewer.html#2e1e005bde20f65b7269e2dd4e978306">setMouseBindingDescription</a>(Qt::LeftButton, <span class="stringliteral">"Toggles full screen mode"</span>, <span class="keyword">true</span>);

<span class="comment">// Removes the description of Ctrl+Right button</span>
<a class="code" href="classQGLViewer.html#2e1e005bde20f65b7269e2dd4e978306">setMouseBindingDescription</a>(Qt::ControlModifier + Qt::RightButton, <span class="stringliteral">""</span>);
</pre></div><p>
Overload <a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> and friends to implement your custom mouse behavior (see the <a class="el" href="classQGLViewer.html#88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> documentation for an example). See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse example</a> for an illustration.<p>
Use <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#4198b3b668c342e39752bade04f78c64">setWheelBinding()</a> to change the standard mouse action bindings.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you use Qt version 2 or 3, the <code>Modifier</code> postfix should be replaced by <code>Button</code> in the examples above (<code>Qt::ControlButton</code>, <code>Qt::AltButton</code>, ...).<p>
If you use Qt version 2 or 3, the <code>buttonsBefore</code> parameter type is actually a Qt::ButtonState. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4198b3b668c342e39752bade04f78c64"></a><!-- doxytag: member="QGLViewer::setWheelBinding" ref="4198b3b668c342e39752bade04f78c64" args="(Qt::KeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool withConstraint=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setWheelBinding           </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&nbsp;</td>
          <td class="paramname"> <em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875">MouseAction</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>withConstraint</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associates a MouseAction and a MouseHandler to a mouse wheel event.<p>
This method is very similar to <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a>, but specific to the wheel.<p>
In the current implementation only <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201">ZOOM</a> can be associated with <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>, while <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a> can receive <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201">ZOOM</a> and <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef87599906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a>.<p>
The difference between <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201">ZOOM</a> and <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef87599906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a> is that <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef875604adefe799fe794cab6b76ed1108201">ZOOM</a> speed depends on the distance to the object, while <a class="el" href="classQGLViewer.html#ded669cb17515ea2b5971496f9aef87599906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a> moves at a constant speed defined by <a class="el" href="classqglviewer_1_1Camera.html#c1758b72dab0895b9340fa833e62b802">qglviewer::Camera::flySpeed()</a>. 
</div>
</div><p>
<a class="anchor" name="0f709bcb22461a4e9df78de2821b9c80"></a><!-- doxytag: member="QGLViewer::setHandlerKeyboardModifiers" ref="0f709bcb22461a4e9df78de2821b9c80" args="(MouseHandler handler, Qt::KeyboardModifiers modifiers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setHandlerKeyboardModifiers           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&nbsp;</td>
          <td class="paramname"> <em>modifiers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associates keyboard modifiers to MouseHandler <code>handler</code>.<p>
The <code>modifiers</code> parameter is <code>Qt::AltModifier</code>, <code>Qt::ShiftModifier</code>, <code>Qt::ControlModifier</code>, <code>Qt::MetaModifier</code> or a combination of these using the '|' bitwise operator. Some shorter names are also available: <code>Qt::ALT</code>, <code>Qt::CTRL</code>, <code>Qt::SHIFT</code> or <code>QT::META</code>.<p>
<em>All</em> the <code>handler's</code> associated bindings will then need the specified <code>modifiers</code> key(s) to be activated.<p>
With this code, <div class="fragment"><pre class="fragment"><a class="code" href="classQGLViewer.html#0f709bcb22461a4e9df78de2821b9c80">setHandlerKeyboardModifiers</a>(<a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a>, Qt::AltModifier);
<a class="code" href="classQGLViewer.html#0f709bcb22461a4e9df78de2821b9c80">setHandlerKeyboardModifiers</a>(<a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>,  Qt::NoModifier);
</pre></div> you will have to press the <code>Alt</code> key while pressing mouse buttons in order to move the <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a>, while no key will be needed to move the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>.<p>
This method has a very basic implementation: every action binded to <code>handler</code> has its keyboard modifier replaced by <code>modifiers</code>. If <code>handler</code> had some actions binded to different modifiers, these settings will be lost. You should hence consider using <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a> for finer tuning.<p>
The default binding associates <code>Qt::ControlModifier</code> to all the <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a> actions and <code>Qt::NoModifier</code> to all <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a> actions. See <a href="../mouse.html">mouse page</a> for details.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>This method calls <a class="el" href="classQGLViewer.html#218f2279fd64d5841b5ae2fc67d74274">setMouseBinding()</a>, which ensures that only one action is binded to a given modifiers. If you want to <em>swap</em> the <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a> and <a class="el" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a> keyboard modifiers, you have to use a temporary dummy modifier (as if you were swapping two variables) or else the first call will overwrite the previous settings: <div class="fragment"><pre class="fragment"><span class="comment">// Associate FRAME with Alt (temporary value)</span>
<a class="code" href="classQGLViewer.html#0f709bcb22461a4e9df78de2821b9c80">setHandlerKeyboardModifiers</a>(<a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>, Qt::AltModifier);
<span class="comment">// Control is associated with CAMERA</span>
<a class="code" href="classQGLViewer.html#0f709bcb22461a4e9df78de2821b9c80">setHandlerKeyboardModifiers</a>(<a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325dda31f516cdf218b68b790fb31e8a6956">CAMERA</a>, Qt::ControlModifier);
<span class="comment">// And finally, FRAME can be associated with NoModifier</span>
<a class="code" href="classQGLViewer.html#0f709bcb22461a4e9df78de2821b9c80">setHandlerKeyboardModifiers</a>(<a class="code" href="classQGLViewer.html#5b90ab220b7700ca28db5ecf3217325d200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>, Qt::NoModifier);
</pre></div></dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you use Qt version 2 or 3, <code>modifiers</code> is actually a <code>Qt::ButtonState</code>. The <code>Modifier</code> sufix is replaced by <code>Button</code> in the enums' names (<code>Qt::ControlButton</code>, <code>Qt::AltButton</code>, <code>Qt::ShiftButton</code> and <code>Qt::MetaButton</code>). </dd></dl>

</div>
</div><p>
<a class="anchor" name="62b572fd9b9afecb2ac055a24ca9dfa0"></a><!-- doxytag: member="QGLViewer::stateFileName" ref="62b572fd9b9afecb2ac055a24ca9dfa0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString stateFileName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the state file name. Default value is <code></code>.qglviewer.xml.<p>
This is the name of the XML file where <a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> saves the viewer state (camera state, widget geometry, display flags... see <a class="el" href="classQGLViewer.html#48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>) on exit. Use <a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> to restore this state later (usually in your <a class="el" href="classQGLViewer.html#9339772ec5ac9fa929938109207f2863">init()</a> method).<p>
Setting this value to <code>QString::null</code> will disable the automatic state file saving that normally occurs on exit.<p>
If more than one viewer are created by the application, this function will return a numbered file name (as in ".qglviewer1.xml", ".qglviewer2.xml"... using <a class="el" href="classQGLViewer.html#9570ddcbaab08bce6f121e69db4fb903">QGLViewer::QGLViewerIndex()</a>) for extra viewers. Each viewer will then read back its own information in <a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>, provided that the viewers are created in the same order, which is usually the case. 
</div>
</div><p>
<a class="anchor" name="48e0e2dd26cd96418c8b889ceabe80f6"></a><!-- doxytag: member="QGLViewer::domElement" ref="48e0e2dd26cd96418c8b889ceabe80f6" args="(const QString &amp;name, QDomDocument &amp;document) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDomElement domElement           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QDomDocument &amp;&nbsp;</td>
          <td class="paramname"> <em>document</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an XML <code>QDomElement</code> that represents the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>.<p>
Used by <a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a>. <a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> uses <a class="el" href="classQGLViewer.html#cd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement()</a> to restore the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> state from the resulting <code>QDomElement</code>.<p>
<code>name</code> is the name of the QDomElement tag. <code>doc</code> is the <code>QDomDocument</code> factory used to create QDomElement.<p>
The created QDomElement contains state values (<a class="el" href="classQGLViewer.html#7d38e6f11078e886f7978525def15797">axisIsDrawn()</a>, <a class="el" href="classQGLViewer.html#4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>, <a class="el" href="classQGLViewer.html#129c439f36bb669672148192abc8ffed">isFullScreen()</a>...), viewer geometry, as well as <a class="el" href="classQGLViewer.html#27a9e97573822d296b48e1c408b74042">camera()</a> (see <a class="el" href="classqglviewer_1_1Camera.html#48e0e2dd26cd96418c8b889ceabe80f6">qglviewer::Camera::domElement()</a>) and <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> (if defined, see <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#48e0e2dd26cd96418c8b889ceabe80f6">qglviewer::ManipulatedFrame::domElement()</a>) states.<p>
Overload this method to add your own attributes to the state file: <div class="fragment"><pre class="fragment">QDomElement Viewer::domElement(<span class="keyword">const</span> QString&amp; name, QDomDocument&amp; document)<span class="keyword"> const</span>
<span class="keyword"></span>{
<span class="comment">// Creates a custom node for a light</span>
QDomElement de = document.createElement(<span class="stringliteral">"Light"</span>);
de.setAttribute(<span class="stringliteral">"state"</span>, (lightIsOn()?<span class="stringliteral">"on"</span>:<span class="stringliteral">"off"</span>));
<span class="comment">// Note the include of the ManipulatedFrame domElement method.</span>
de.appendChild(lightManipulatedFrame()-&gt;domElement(<span class="stringliteral">"LightFrame"</span>, document));

<span class="comment">// Get default state domElement and append custom node</span>
QDomElement res = <a class="code" href="classQGLViewer.html#48e0e2dd26cd96418c8b889ceabe80f6">QGLViewer::domElement</a>(name, document);
res.appendChild(de);
<span class="keywordflow">return</span> res;
}
</pre></div> See <a class="el" href="classQGLViewer.html#cd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement()</a> for the associated restoration code.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>For the <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>, <a class="el" href="classqglviewer_1_1Frame.html#0974dfe336ed84a20adb8c6cdf8dedd9">qglviewer::Frame::constraint()</a> and <a class="el" href="classqglviewer_1_1Frame.html#9794b079db5f492e8804631d3d23baec">qglviewer::Frame::referenceFrame()</a> are not saved. See <a class="el" href="classqglviewer_1_1Frame.html#48e0e2dd26cd96418c8b889ceabe80f6">qglviewer::Frame::domElement()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd13d2ddeca530cb9f26ead47f7d25d3"></a><!-- doxytag: member="QGLViewer::initFromDOMElement" ref="cd13d2ddeca530cb9f26ead47f7d25d3" args="(const QDomElement &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initFromDOMElement           </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restores the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> state from a <code>QDomElement</code> created by <a class="el" href="classQGLViewer.html#48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>.<p>
Used by <a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> to restore the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> state from a file.<p>
Overload this method to retrieve custom attributes from the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> state file. This code corresponds to the one given in the <a class="el" href="classQGLViewer.html#48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a> documentation: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Viewer::initFromDOMElement(<span class="keyword">const</span> QDomElement&amp; element)
{
<span class="comment">// Restore standard state</span>
<a class="code" href="classQGLViewer.html#cd13d2ddeca530cb9f26ead47f7d25d3">QGLViewer::initFromDOMElement</a>(element);

QDomElement child=element.firstChild().toElement();
<span class="keywordflow">while</span> (!child.isNull())
{
<span class="keywordflow">if</span> (child.tagName() == <span class="stringliteral">"Light"</span>)
{
<span class="keywordflow">if</span> (child.hasAttribute(<span class="stringliteral">"state"</span>))
setLightOn(child.attribute(<span class="stringliteral">"state"</span>).lower() == <span class="stringliteral">"on"</span>);

<span class="comment">// Assumes there is only one child. Otherwise you need to parse child's children recursively.</span>
QDomElement lf = child.firstChild().toElement();
<span class="keywordflow">if</span> (!lf.isNull() &amp;&amp; lf.tagName() == <span class="stringliteral">"LightFrame"</span>)
lightManipulatedFrame()-&gt;initFromDomElement(lf);
}
child = child.nextSibling().toElement();
}
}
</pre></div><p>
See also <a class="el" href="classqglviewer_1_1Camera.html#cd13d2ddeca530cb9f26ead47f7d25d3">qglviewer::Camera::initFromDOMElement()</a>, <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#cd13d2ddeca530cb9f26ead47f7d25d3">qglviewer::ManipulatedFrame::initFromDOMElement()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> <em>pointer</em> is not modified by this method. If defined, its state is simply set from the <code>element</code> values. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aec9168a5f41b3b7fa4211523535ceaa"></a><!-- doxytag: member="QGLViewer::saveStateToFile" ref="aec9168a5f41b3b7fa4211523535ceaa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saveStateToFile           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves in <a class="el" href="classQGLViewer.html#62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> an XML representation of the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> state, obtained from <a class="el" href="classQGLViewer.html#48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>.<p>
Use <a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> to restore this viewer state.<p>
This method is automatically called when a viewer is closed (using Escape or using the window's upper right <code>x</code> close button). <a class="el" href="classQGLViewer.html#68737cce3d7301701bca6e4270a5a34e">setStateFileName()</a> to <code>QString::null</code> to prevent this. 
</div>
</div><p>
<a class="anchor" name="212f6b7b669463c2151688f629d72a81"></a><!-- doxytag: member="QGLViewer::restoreStateFromFile" ref="212f6b7b669463c2151688f629d72a81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool restoreStateFromFile           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restores the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> state from the <a class="el" href="classQGLViewer.html#62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> file using <a class="el" href="classQGLViewer.html#cd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement()</a>.<p>
States are saved using <a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a>, which is automatically called on viewer exit.<p>
Returns <code>true</code> when the restoration is successful. Possible problems are an non existing or unreadable <a class="el" href="classQGLViewer.html#62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> file, an empty <a class="el" href="classQGLViewer.html#62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> or an XML syntax error.<p>
A <a class="el" href="classQGLViewer.html#ba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> should be defined <em>before</em> calling this method, so that its state can be restored. Initialization code put <em>after</em> this function will override saved values: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Viewer::init()
{
<span class="comment">// Default initialization goes here (including the declaration of a possible manipulatedFrame).</span>

<span class="keywordflow">if</span> (!restoreStateFromFile())
showEntireScene(); <span class="comment">// Previous state cannot be restored: fit camera to scene.</span>

<span class="comment">// Specific initialization that overrides file savings goes here.</span>
}
</pre></div> 
</div>
</div><p>
<a class="anchor" name="68737cce3d7301701bca6e4270a5a34e"></a><!-- doxytag: member="QGLViewer::setStateFileName" ref="68737cce3d7301701bca6e4270a5a34e" args="(const QString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setStateFileName           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the <a class="el" href="classQGLViewer.html#62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> used by <a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> and <a class="el" href="classQGLViewer.html#212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>.<p>
The file name can have an optional prefix directory (no prefix meaning current directory). If the directory does not exist, it will be created by <a class="el" href="classQGLViewer.html#aec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a>.<p>
<div class="fragment"><pre class="fragment">                <span class="comment">// Name depends on the displayed 3D model. Saved in current directory.</span>
                <a class="code" href="classQGLViewer.html#68737cce3d7301701bca6e4270a5a34e">setStateFileName</a>(3DModelName() + <span class="stringliteral">".xml"</span>);

                <span class="comment">// Files are stored in a dedicated directory under user's home directory.</span>
                <a class="code" href="classQGLViewer.html#68737cce3d7301701bca6e4270a5a34e">setStateFileName</a>(QDir::homeDirPath + <span class="stringliteral">"/.config/myApp.xml"</span>);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="32d7a506084c50fd97a24f94d9ca4864"></a><!-- doxytag: member="QGLViewer::QGLViewerPool" ref="32d7a506084c50fd97a24f94d9ca4864" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const QList&lt;QGLViewer*&gt;&amp; QGLViewerPool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <code>QList</code> (see Qt documentation) that contains pointers to all the created QGLViewers. Note that this list may contain <code>NULL</code> pointers if the associated viewer has been deleted.<p>
Can be useful to apply a method or to connect a signal to all the viewers.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>With Qt version 3, this method returns a <code>QPtrList</code> instead. Use a <code>QPtrListIterator</code> to iterate on the list: <div class="fragment"><pre class="fragment">        QPtrListIterator&lt;QGLViewer&gt; it(<a class="code" href="classQGLViewer.html#32d7a506084c50fd97a24f94d9ca4864">QGLViewer::QGLViewerPool</a>());
        <span class="keywordflow">for</span> (<a class="code" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a>* viewer; (viewer = it.current()) != NULL; ++it)
        connect(myObject, SIGNAL(mySignal), viewer, SLOT(<a class="code" href="classQGLViewer.html#e12b7378efbffabc24a133ca1deb19ae">updateGL</a>()));
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9570ddcbaab08bce6f121e69db4fb903"></a><!-- doxytag: member="QGLViewer::QGLViewerIndex" ref="9570ddcbaab08bce6f121e69db4fb903" args="(const QGLViewer *const viewer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int QGLViewerIndex           </td>
          <td>(</td>
          <td class="paramtype">const QGLViewer *const &nbsp;</td>
          <td class="paramname"> <em>viewer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> <code>viewer</code> in the <a class="el" href="classQGLViewer.html#32d7a506084c50fd97a24f94d9ca4864">QGLViewerPool()</a>. This index in unique and can be used to identify the different created QGLViewers (see <a class="el" href="classQGLViewer.html#62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> for an application example).<p>
When a <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> is deleted, the following QGLViewers' indexes are shifted down. Returns -1 if the <a class="el" href="classQGLViewer.html" title="A versatile 3D OpenGL viewer based on QGLWidget.">QGLViewer</a> could not be found (which should not be possible). 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>libQGLViewer 2.3.1 documentation generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
