namespace eeigen {

/** \eigenManualPage TopicStlContainers Using STL Containers with eeigen

\eigenAutoToc

\section StlContainers_summary Executive summary

Using STL containers on \ref TopicFixedSizeVectorizable "fixed-size vectorizable eeigen types", or classes having members of such types, requires taking the following two steps:

\li A 16-byte-aligned allocator must be used. eeigen does provide one ready for use: aligned_allocator.
\li If you want to use the std::vector container, you need to \#include <eeigen/StdVector>.

These issues arise only with \ref TopicFixedSizeVectorizable "fixed-size vectorizable eeigen types" and \ref TopicStructHavingEigenMembers "structures having such eeigen objects as member". For other eeigen types, such as Vector3f or MatrixXd, no special care is needed when using STL containers.

\section allocator Using an aligned allocator

STL containers take an optional template parameter, the allocator type. When using STL containers on \ref TopicFixedSizeVectorizable "fixed-size vectorizable eeigen types", you need tell the container to use an allocator that will always allocate memory at 16-byte-aligned locations. Fortunately, eeigen does provide such an allocator: eeigen::aligned_allocator.

For example, instead of
\code
std::map<int, eeigen::Vector4f>
\endcode
you need to use
\code
std::map<int, eeigen::Vector4f, std::less<int>, 
         eeigen::aligned_allocator<std::pair<const int, eeigen::Vector4f> > >
\endcode
Note that the third parameter "std::less<int>" is just the default value, but we have to include it because we want to specify the fourth parameter, which is the allocator type.

\section StlContainers_vector The case of std::vector

The situation with std::vector was even worse (explanation below) so we had to specialize it for the eeigen::aligned_allocator type. In practice you \b must use the eeigen::aligned_allocator (not another aligned allocator), \b and \#include <eeigen/StdVector>.

Here is an example:
\code
#include<eeigen/StdVector>
/* ... */
std::vector<eeigen::Vector4f,eeigen::aligned_allocator<eeigen::Vector4f> >
\endcode

\subsection vector_spec An alternative - specializing std::vector for eeigen types

As an alternative to the recommended approach described above, you have the option to specialize std::vector for eeigen types requiring alignment. 
The advantage is that you won't need to declare std::vector all over with eeigen::allocator. One drawback on the other hand side is that
the specialization needs to be defined before all code pieces in which e.g. std::vector<Vector2d> is used. Otherwise, without knowing the specialization
the compiler will compile that particular instance with the default std::allocator and you program is most likely to crash.

Here is an example:
\code
#include<eeigen/StdVector>
/* ... */
EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION(Matrix2d)
std::vector<eeigen::Vector2d>
\endcode

<span class="note">\b Explanation: The resize() method of std::vector takes a value_type argument (defaulting to value_type()). So with std::vector<eeigen::Vector4f>, some eeigen::Vector4f objects will be passed by value, which discards any alignment modifiers, so a eeigen::Vector4f can be created at an unaligned location. In order to avoid that, the only solution we saw was to specialize std::vector to make it work on a slight modification of, here, eeigen::Vector4f, that is able to deal properly with this situation.
</span>

*/

}
