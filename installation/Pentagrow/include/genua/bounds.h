
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 
#ifndef GENUA_BOUNDS_H
#define GENUA_BOUNDS_H

#include "point.h"
#include "line.h"

class MeshFields;

/** Axis-oriented Rectangle.

  Bounding object for 2D regions, oriented along cartesian axes.

  This is a legacy class kept for compatibility of old tools. For new
  code, use the more general k-DOP implementation in kdop.h (Dop2d2).

  \deprecated
  \ingroup geometry
  \sa BSearchTree, Triangulation, Dop2d2
*/
class BndRect
{
  public:

    /// empty construction
    BndRect() {}

    /// construction from corners
    BndRect(const Vct2 & a, const Vct2 & b);

    /// construction from coordinates
    BndRect(Real p1x, Real p1y, Real p2x, Real p2y);

    /// equality
    bool operator== (const BndRect & b) const
      {return (p1 == b.p1 and p2 == b.p2);}

    /// modify corner coordinates
    void setCorners(Real lox, Real loy, Real hix, Real hiy);

    /// create from point grid
    void findBndRect(const PointList<2> & pg);

    /// lower corner
    const Vct2 & lower() const
      { return p1; }

    /// upper corner
    const Vct2 & upper() const
      { return p2; }

    /// lower right corner
    Vct2 right() const
      { return vct(p2[0], p1[1]); }

    /// upper left corner
    Vct2 left() const
      { return vct(p1[0], p2[1]); }

    /// return center point
    Vct2 center() const
      {return 0.5*(p1+p2);}

    /// compute area
    Real area() const
      {return fabs((p2(1)-p1(1))*(p2(0)-p1(0)));}

    /// size in x-direction
    Real width() const
      {return p2[0]-p1[0];}

    /// size in y-direction
    Real height() const
      {return p2[1]-p1[1];}
    
    /// diagonal
    Real diagonal() const {
      return norm(p2-p1);
    }

    /// test if point is inside
    bool isInside(const Vct2 & pt) const {
      if (pt[0] < p1[0])
        return false;
      else if (pt[0] > p2[0])
        return false;
      else if (pt[1] < p1[1])
        return false;
      else if (pt[1] > p2[1])
        return false;
      else
        return true;
    }

    /// test if rectangle is completely enclosed
    bool isInside(const BndRect & rct) const;

    /// test for intersection with other rectangle
    bool intersects(const BndRect & other) const;

    /// tests if rectangles touch
    bool touches(const BndRect & other) const;

    /// return rectangle generated by intersection
    BndRect intersection(const BndRect & other) const;

    /// tests if an edge intersects box 
    bool intersects(const Vct2 & a, const Vct2 & b) const {
      if (a[0] < p1[0] and b[0] < p1[0])
        return false;
      else if (a[0] > p2[0] and b[0] > p2[0])
        return false;
      else if (a[1] < p1[1] and b[1] < p1[1])
        return false;
      else if (a[1] > p2[1] and b[1] > p2[1])
        return false;
    
      Vct2 p[4];
      p[0] = p1;
      p[1] = vct(p2[0], p1[1]);
      p[2] = p2;
      p[3] = vct(p1[0], p2[1]);
      Line<2> lab(a,b);
      for (uint k=0; k<4; ++k) {
        Line<2> line( p[k], p[(k+1)%4] );
        LnIts<2> its = line.intersection( lab );
        if (its.internal())
          return true;
      }
      return false;
    }
    
    /// change size
    void expand(Real w, Real h);
    
    /// compute distance vector (point to its projection on box)
    Vct2 distance(const Vct2 & pt) const {
      Vct2 ds;
      for (uint i=0; i<2; ++i) {
        if (pt[i] < p1[i])
          ds[i] = p1[i] - pt[i];
        else if (pt[i] > p2[i])
          ds[i] = pt[i] - p2[i];
      }
      return ds;
    }
    
    /// expand rectangle to contain point p, if necessary
    void enclose(const Vct2 p) {
      p1[0] = std::min(p1[0], p[0]);
      p1[1] = std::min(p1[1], p[1]);
      
      p2[0] = std::max(p2[0], p[0]);
      p2[1] = std::max(p2[1], p[1]);
    }
    
  private:

    // diagonally opposed corners
    Vct2 p1, p2;
};

/** Bounding box.

  Main purpose of this class is the provision of bounding box functionality.
  A box can be instatiated with two arbitrary corners or a collection of
  points, via findBbox(). If a collection is given, the bounding box to all
  points in that collection is computed.

  Use Dop3d3 instead.

  \deprecated
  \ingroup geometry
  \sa BSearchTree, Triangulation, Dop3d3

*/
class BndBox
{
  public:

    /// empty construction
    BndBox() {}

    /// build from two points
    BndBox(const Vct3 & a, const Vct3 & b);

    /// reset to undefined box
    void reset() {
      p1 = std::numeric_limits<Real>::max();
      p2 = -p1;
    }

    /// lower point
    const Vct3 & lower() const {return p1;}

    /// upper point
    const Vct3 & upper() const {return p2;}

    /// make box larger by dst in each direction
    void expand(Real dst) {
      p1[0] -= dst; p1[1] -= dst; p1[2] -= dst;
      p2[0] += dst; p2[1] += dst; p2[2] += dst;
    }
    
    /// return center point
    Vct3 center() const
      {return 0.5*(p1+p2);}

    /// return x-size
    Real length() const
      {return p2[0]-p1[0];}

    /// return y-size
    Real width() const
      {return p2[1]-p1[1];}

    /// return z-size
    Real height() const
      {return p2[2]-p1[2];}

    /// compute length of diagonal
    Real diagonal() const
      {return norm(p2-p1);}

    /// find bounding box of all points in grid
    void findBbox(const PointGrid<3> & pg) {
      findBbox(pg.begin(), pg.end());
    }

    /// find bounding box of all points in list
    void findBbox(const PointList<3> & pg) {
      findBbox(pg.begin(), pg.end());
    }
    
    /// find bounding box
    template <class InputIterator>
    void findBbox(InputIterator first, InputIterator last) {
      p1 = point(huge, huge, huge);
      p2 = point(-huge, -huge, -huge);
      while (first++ != last) {
        const Vct3 & pt(*first);
        for (uint i=0; i<3; i++) {
          p1[i] = std::min(p1[i], pt[i]);
          p2[i] = std::max(p2[i], pt[i]);
        }
      }
    }

    /// test if point is inside
    bool isInside(const Vct3 & p) const {
      for (int i=0; i<3; i++) {
        if (p[i] < p1[i] or p[i] > p2[i])
          return false;
      }
      return true;
    }

    /// test if boxes intersect
    bool intersects(const BndBox & other) const;

    /// return intersection box
    BndBox intersection(const BndBox & other) const;

    /// compute distance vector (point to its projection on box)
    Vct3 distance(const Vct3 & pt) const {
      Vct3 ds;
      for (uint i=0; i<3; ++i) {
        if (pt[i] < p1[i])
          ds[i] = p1[i] - pt[i];
        else if (pt[i] > p2[i])
          ds[i] = pt[i] - p2[i];
      }
      return ds;
    }

    /// expand box to contain point p, if necessary
    void enclose(const Vct3 p) {
      p1[0] = std::min(p1[0], p[0]);
      p1[1] = std::min(p1[1], p[1]);
      p1[2] = std::min(p1[2], p[2]);
      
      p2[0] = std::max(p2[0], p[0]);
      p2[1] = std::max(p2[1], p[1]);
      p2[2] = std::max(p2[2], p[2]);
    }
    
    /// visualization
    void writeQuads(std::ostream & os) const;

    /// visualization 
    void addQuads(MeshFields & mvz) const;
    
  private:

    /// lower left forward and upper right backward corner
    Vct3 p1, p2;
};

std::string str(const BndBox & bb);

#endif


