
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 

// mathematical operators for  DVector<NumType>
// file generated by genua/tools/opsprint.py

template <class NumType>
inline DVector<NumType> operator+ (const DVector<NumType> & a, const DVector<NumType> & b)
{
  assert(a.size() == b.size());
  DVector<NumType> c(a);
  for (size_t i=0; i<a.size(); ++i)
    c[i] += b[i];
  return c;
}

template <class NumType>
inline DVector<NumType> & operator+= (DVector<NumType> & a, const DVector<NumType> & b)
{
  assert(a.size() == b.size());
  for (size_t i=0; i<a.size(); ++i)
    a[i] += b[i];
  return a;
}

template <class NumType>
inline DVector<NumType> operator+ (const DVector<NumType> & a, NumType b)
{
  DVector<NumType> c(a);
  for (size_t i=0; i<a.size(); ++i)
    c[i] += b;
  return c;
}

template <class NumType>
inline DVector<NumType> & operator+= (DVector<NumType> & a, NumType b)
{
  for (size_t i=0; i<a.size(); ++i)
    a[i] += b;
  return a;
}

template <class NumType>
inline DVector<NumType> operator+ (NumType a, const DVector<NumType> & b)
{
  DVector<NumType> c(b.size());
  for (size_t i=0; i<b.size(); ++i)
    c[i] = a + b[i];
  return c;
}

template <class NumType>
inline DVector<NumType> operator- (const DVector<NumType> & a, const DVector<NumType> & b)
{
  assert(a.size() == b.size());
  DVector<NumType> c(a);
  for (size_t i=0; i<a.size(); ++i)
    c[i] -= b[i];
  return c;
}

template <class NumType>
inline DVector<NumType> & operator-= (DVector<NumType> & a, const DVector<NumType> & b)
{
  assert(a.size() == b.size());
  for (size_t i=0; i<a.size(); ++i)
    a[i] -= b[i];
  return a;
}

template <class NumType>
inline DVector<NumType> operator- (const DVector<NumType> & a, NumType b)
{
  DVector<NumType> c(a);
  for (size_t i=0; i<a.size(); ++i)
    c[i] -= b;
  return c;
}

template <class NumType>
inline DVector<NumType> & operator-= (DVector<NumType> & a, NumType b)
{
  for (size_t i=0; i<a.size(); ++i)
    a[i] -= b;
  return a;
}

template <class NumType>
inline DVector<NumType> operator- (NumType a, const DVector<NumType> & b)
{
  DVector<NumType> c(b.size());
  for (size_t i=0; i<b.size(); ++i)
    c[i] = a - b[i];
  return c;
}

template <class NumType>
inline DVector<NumType> operator* (const DVector<NumType> & a, NumType b)
{
  DVector<NumType> c(a);
  for (size_t i=0; i<a.size(); ++i)
    c[i] *= b;
  return c;
}

template <class NumType>
inline DVector<NumType> & operator*= (DVector<NumType> & a, NumType b)
{
  for (size_t i=0; i<a.size(); ++i)
    a[i] *= b;
  return a;
}

template <class NumType>
inline DVector<NumType> operator* (NumType a, const DVector<NumType> & b)
{
  DVector<NumType> c(b.size());
  for (size_t i=0; i<b.size(); ++i)
    c[i] = a * b[i];
  return c;
}

template <class NumType>
inline DVector<NumType> operator/ (const DVector<NumType> & a, NumType b)
{
  DVector<NumType> c(a);
  NumType ib(1.0/b);
  for (size_t i=0; i<a.size(); ++i)
    c[i] *= ib;
  return c;
}

template <class NumType>
inline DVector<NumType> & operator/= (DVector<NumType> & a, NumType b)
{
  NumType ib(1.0/b);
  for (size_t i=0; i<a.size(); ++i)
    a[i] *= ib;
  return a;
}

template <class NumType>
inline DVector<NumType> operator/ (NumType a, const DVector<NumType> & b)
{
  DVector<NumType> c(b.size());
  for (size_t i=0; i<b.size(); ++i)
    c[i] = a / b[i];
  return c;
}

template <class NumType>
inline DVector<NumType> sin(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = sin(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> cos(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = cos(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> tan(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = tan(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> asin(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = asin(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> acos(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = acos(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> atan(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = atan(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> exp(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = exp(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> log(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = log(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> sqrt(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = sqrt(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> ceil(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = ceil(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> floor(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = floor(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> sinh(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = sinh(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> cosh(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = cosh(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> tanh(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = tanh(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> fabs(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = fabs(a[i]);
  return b;
}

template <class NumType>
inline DVector<NumType> log10(const DVector<NumType> & a)
{
  DVector<NumType> b(a.size());
  for (size_t i=0; i<a.size(); ++i)
    b[i] = log10(a[i]);
  return b;
}

