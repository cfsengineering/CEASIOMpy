
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 
#ifndef GENUA_ENUMOBJECT_H
#define GENUA_ENUMOBJECT_H

#include "defines.h"

/** Base class for mapping enums to strings.

  Child classes are typically autogenerated. Example:

  \code
  class Direction : EnumObject<5> {
  public:

    enum Code {None, North, East, South, West};

    Direction() : code(Direction::None) {}

    bool parse(const string & s) {
      const char *begin = s.c_str();
      const char *end = begin + s.size();
      uint ikey = EnumObject<5>::findKey(begin, end, keylist);
      if (ikey != NotFound)
        code = (Direction::Code) ikey;
      return (ikey != NotFound);
    }

    const char* str() const { return keylist[(int) code]; }

 private:
    Direction::Code code;
    static const char *keylist[];
  };

  // implementation
  const char *Direction::keylist[] = {".NONE.", ".NORTH.", ...};
  \endcode

  \ingroup utility
*/
template <int N>
class EnumObject
{
public:

  /// number of keys defined
  static int nkeys() {return N;}  // constexpr

private:

  /// test whether the bounded range [begin,end[ matches [key,key+end-begin[
  static bool equalSequence(const char *begin, const char *end, const char *key) {
    const char *itr;
    for (itr = begin; itr != end; ++itr, ++key) {
      if (*key == '\0') // begin-end starts with key but continues
        return false;
      if (*itr != *key)
        return false;
    }
    return true;
  }

protected:

  /// return the index of the key in keylist which is contained in (begin,end)
  static uint findKey(const char *begin, const char *end,
                      const char *keylist[])
  {
    for (int i=0; i<N; ++i) {
      if (EnumObject<N>::equalSequence(begin, end, keylist[i]))
        return i;
    }
    return NotFound;
  }

  static int parse(const char *pkeylist[], const std::string &s) {
    const char *begin = s.c_str();
    const char *end = begin + s.size();
    uint ikey = EnumObject<N>::findKey(begin, end, pkeylist);
    if (ikey != NotFound)
      return ikey;
    return -1;
  }

protected:

  // child classes define a static list of keys
  // static const char *keylist[N];
};

#endif // ENUMOBJECT_H
