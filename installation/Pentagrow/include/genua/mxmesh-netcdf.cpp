
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 *
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */

#if !defined(HAVE_NETCDF)
#error "netCDF support required for TAU mesh support."
#endif

#include "mxmesh.h"
#include <genua/xcept.h>
#include <genua/dbprint.h>
#include <netcdf.h>
#include <string>

using namespace std;

// used to indicate that a dimension does not exist
const int NoID = std::numeric_limits<int>::max();

// raise exception on netCDF error
static void handle_error( int stat, const char *tag = nullptr )
{
  if (stat != NC_NOERR) {
    string msg = string("netCDF reports error: ");
    msg += str(stat) + " -> " + nc_strerror(stat);
    if (tag != nullptr)
      msg += string(" tag: '") + string(tag) + "'";
    throw Error(msg);
  }
}

void MxMesh::writeTau(const std::string & fname) const
{
  // reorganize coordinate data to fit taumesh file format
  const int nn = nnodes();
  DVector<double> xc(nn), yc(nn), zc(nn);
  for (int i=0; i<nn; ++i) {
    xc[i] = vtx[i][0];
    yc[i] = vtx[i][1];
    zc[i] = vtx[i][2];
  }

  // count elements which can be stored in taumesh format
  const int nsec = nsections();
  int ntet(0), ntri(0), nprism(0);
  for (int i=0; i<nsec; ++i) {
    Mx::ElementType et = section(i).elementType();
    if (et == Mx::Tri3) {
      ntri += section(i).nelements();
    } else if (et == Mx::Tet4) {
      ntet += section(i).nelements();
    } else if (et == Mx::Penta6) {
      nprism += section(i).nelements();
    }
  }

  // merge all 4-node tetraeder sections and all 3-node triangle sections
  // into flat arrays (do not transpose)
  DVector<int> tets, tris, prisms, bdm;
  tets.reserve( 4*ntet );
  tris.reserve( 3*ntri );
  prisms.reserve( 6*nprism );

  Indices triMap( nelements(), NotFound );
  uint triOffset = 0;
  for (int i=0; i<nsec; ++i) {
    const int ne = section(i).nelements();
    const uint *v = section(i).element(0);
    Mx::ElementType et = section(i).elementType();
    if (et == Mx::Tri3) {
      tris.insert(tris.end(), v, v+3*ne);
      const uint off = section(i).indexOffset();
      for (int j=0; j<ne; ++j)
        triMap[off+j] = triOffset + j;
      triOffset += ne;
    } else if (et == Mx::Tet4) {
      tets.insert(tets.end(), v, v+4*ne);
    } else if (et == Mx::Penta6) {
      prisms.insert(prisms.end(), v, v+6*ne);
    }
  }

  // boundary markers
  int nbd = nbocos();
  DVector<int> mrk(nbd);
  bdm.resize( ntri );
  for (int j=0; j<nbd; ++j) {
    mrk[j] = j+1;
    Indices elx;
    boco(j).elements(elx);
    const int ne = elx.size();
    for (int i=0; i<ne; ++i) {
      bdm[ triMap[elx[i]] ] = j+1;
    }
  }

  // netCDF API calls, generated by using
  // ncgen -lc on an example mesh file

  int  stat;  /* netCDF return status */
  int  ncid;  /* netCDF id */

  /* dimension ids */
  int no_of_markers_dim;
  int no_of_tetraeders_dim;
  int no_of_prisms_dim;
  int points_per_tetraeder_dim;
  int points_per_prism_dim;
  int no_of_points_dim;
  int no_of_elements_dim;
  int no_of_surfacetriangles_dim;
  int no_of_surfaceelements_dim;
  int points_per_surfacetriangle_dim;

  /* dimension lengths */
  size_t no_of_markers_len = nbd;
  size_t no_of_tetraeders_len = ntet;
  size_t no_of_prisms_len = nprism;
  size_t points_per_tetraeder_len = 4;
  size_t points_per_prism_len = 6;
  size_t no_of_points_len = nn;
  size_t no_of_elements_len = ntet + nprism;
  size_t no_of_surfacetriangles_len = ntri;
  size_t no_of_surfaceelements_len = ntri;
  size_t points_per_surfacetriangle_len = 3;

  /* variable ids */
  int marker_id;
  // int centaur_key_id;
  int points_of_tetraeders_id;
  int points_of_prisms_id;
  int points_xc_id;
  int points_yc_id;
  int points_zc_id;
  int boundarymarker_of_surfaces_id;
  int points_of_surfacetriangles_id;

  /* rank (number of dimensions) for each variable */
#   define RANK_marker 1
  // #   define RANK_centaur_key 1
#   define RANK_points_of_tetraeders 2
#   define RANK_points_of_prisms 2
#   define RANK_points_xc 1
#   define RANK_points_yc 1
#   define RANK_points_zc 1
#   define RANK_boundarymarker_of_surfaces 1
#   define RANK_points_of_surfacetriangles 2

  /* variable shapes */
  int marker_dims[RANK_marker];
  // int centaur_key_dims[RANK_centaur_key];
  int points_of_tetraeders_dims[RANK_points_of_tetraeders];
  int points_of_prisms_dims[RANK_points_of_prisms];
  int points_xc_dims[RANK_points_xc];
  int points_yc_dims[RANK_points_yc];
  int points_zc_dims[RANK_points_zc];
  int boundarymarker_of_surfaces_dims[RANK_boundarymarker_of_surfaces];
  int points_of_surfacetriangles_dims[RANK_points_of_surfacetriangles];

  /* enter define mode */
  stat = nc_create(fname.c_str(), NC_CLOBBER, &ncid);
  handle_error( stat );

  /* define dimensions */
  stat = nc_def_dim(ncid, "no_of_markers",
                    no_of_markers_len, &no_of_markers_dim);
  handle_error( stat );

  if (ntet > 0) {
    stat = nc_def_dim(ncid, "no_of_tetraeders",
                      no_of_tetraeders_len, &no_of_tetraeders_dim);
    handle_error( stat );
    stat = nc_def_dim(ncid, "points_per_tetraeder",
                      points_per_tetraeder_len, &points_per_tetraeder_dim);
    handle_error( stat );
  }

  if (nprism > 0) {
    stat = nc_def_dim(ncid, "no_of_prisms",
                      no_of_prisms_len, &no_of_prisms_dim);
    handle_error( stat );
    stat = nc_def_dim(ncid, "points_per_prism",
                      points_per_prism_len, &points_per_prism_dim);
    handle_error( stat );
  }

  stat = nc_def_dim(ncid, "no_of_points",
                    no_of_points_len, &no_of_points_dim);
  handle_error( stat );
  stat = nc_def_dim(ncid, "no_of_elements",
                    no_of_elements_len, &no_of_elements_dim);
  handle_error( stat );
  stat = nc_def_dim(ncid, "no_of_surfacetriangles",
                    no_of_surfacetriangles_len, &no_of_surfacetriangles_dim);
  handle_error( stat );
  stat = nc_def_dim(ncid, "no_of_surfaceelements",
                    no_of_surfaceelements_len, &no_of_surfaceelements_dim);
  handle_error( stat );
  stat = nc_def_dim(ncid, "points_per_surfacetriangle",
                    points_per_surfacetriangle_len,
                    &points_per_surfacetriangle_dim);
  handle_error( stat );

  /* define variables */

  marker_dims[0] = no_of_markers_dim;
  stat = nc_def_var(ncid, "marker", NC_INT, RANK_marker,
                    marker_dims, &marker_id);
  handle_error( stat );

  if (ntet > 0) {
    points_of_tetraeders_dims[0] = no_of_tetraeders_dim;
    points_of_tetraeders_dims[1] = points_per_tetraeder_dim;
    stat = nc_def_var(ncid, "points_of_tetraeders", NC_INT,
                      RANK_points_of_tetraeders,
                      points_of_tetraeders_dims,
                      &points_of_tetraeders_id);
    handle_error( stat );
  }

  if (nprism > 0) {
    points_of_prisms_dims[0] = no_of_prisms_dim;
    points_of_prisms_dims[1] = points_per_prism_dim;
    stat = nc_def_var(ncid, "points_of_prisms", NC_INT,
                      RANK_points_of_prisms,
                      points_of_prisms_dims,
                      &points_of_prisms_id);
    handle_error( stat );
  }

  points_xc_dims[0] = no_of_points_dim;
  stat = nc_def_var(ncid, "points_xc", NC_DOUBLE, RANK_points_xc,
                    points_xc_dims, &points_xc_id);
  handle_error( stat );

  points_yc_dims[0] = no_of_points_dim;
  stat = nc_def_var(ncid, "points_yc", NC_DOUBLE, RANK_points_yc,
                    points_yc_dims, &points_yc_id);
  handle_error( stat );

  points_zc_dims[0] = no_of_points_dim;
  stat = nc_def_var(ncid, "points_zc", NC_DOUBLE, RANK_points_zc,
                    points_zc_dims, &points_zc_id);
  handle_error( stat );

  boundarymarker_of_surfaces_dims[0] = no_of_surfaceelements_dim;
  stat = nc_def_var(ncid, "boundarymarker_of_surfaces", NC_INT,
                    RANK_boundarymarker_of_surfaces,
                    boundarymarker_of_surfaces_dims,
                    &boundarymarker_of_surfaces_id);
  handle_error( stat );

  points_of_surfacetriangles_dims[0] = no_of_surfacetriangles_dim;
  points_of_surfacetriangles_dims[1] = points_per_surfacetriangle_dim;
  stat = nc_def_var(ncid, "points_of_surfacetriangles", NC_INT,
                    RANK_points_of_surfacetriangles,
                    points_of_surfacetriangles_dims,
                    &points_of_surfacetriangles_id);
  handle_error( stat );

  /* assign global attributes */
  for (int j=0; j<nbd; ++j) {
    const string & bcName = boco(j).name();
    string markerStr = "marker_" + str(j+1);
    stat = nc_put_att_text(ncid, NC_GLOBAL, markerStr.c_str(),
                           bcName.length(), bcName.c_str());
    handle_error( stat );
  }

  // leave define mode
  stat = nc_enddef(ncid);
  handle_error(stat);

  // write coordinate data
  stat = nc_put_var_double( ncid, points_xc_id, xc.pointer() );
  handle_error( stat );
  stat = nc_put_var_double( ncid, points_yc_id, yc.pointer() );
  handle_error( stat );
  stat = nc_put_var_double( ncid, points_zc_id, zc.pointer() );
  handle_error( stat );

  // write element vertex indices
  if (ntet > 0) {
    stat = nc_put_var_int(ncid, points_of_tetraeders_id, tets.pointer());
    handle_error( stat );
  }
  if (nprism > 0) {
    stat = nc_put_var_int(ncid, points_of_prisms_id, prisms.pointer());
    handle_error( stat );
  }
  if (ntri > 0) {
    stat = nc_put_var_int(ncid, points_of_surfacetriangles_id, tris.pointer());
    handle_error( stat );
  }

  // write boundary markers
  stat = nc_put_var_int(ncid, marker_id, mrk.pointer());
  handle_error( stat );
  stat = nc_put_var_int(ncid, boundarymarker_of_surfaces_id, bdm.pointer());
  handle_error( stat );

  stat = nc_close(ncid);
  handle_error( stat );
}

void MxMesh::readTau(const string &fname)
{
  clear();

  // try to open file
  int stat, ncid;
  stat = nc_open(fname.c_str(), 0, &ncid);
  handle_error( stat );

  // fetch dimensions
  int no_of_points_id(NoID), no_of_tetraeders_id(NoID), no_of_surfacetriangles_id(NoID);
  int no_of_prisms_id(NoID),  no_of_surfaceelements_id(NoID);
  stat = nc_inq_dimid(ncid, "no_of_points", &no_of_points_id);
  handle_error( stat, "no_of_points" );

  stat = nc_inq_dimid(ncid, "no_of_tetraeders", &no_of_tetraeders_id);
  if (stat != NC_EBADDIM)
    handle_error( stat, "no_of_tetraeders" );
  else
    no_of_tetraeders_id = NoID;

  stat = nc_inq_dimid(ncid, "no_of_prisms", &no_of_prisms_id);
  if (stat != NC_EBADDIM)
    handle_error( stat, "no_of_prisms" );
  else
    no_of_prisms_id = NoID;

  stat = nc_inq_dimid(ncid, "no_of_surfacetriangles",
                      &no_of_surfacetriangles_id);
  if (stat != NC_EBADDIM)
    handle_error( stat, "no_of_surfacetriangles" );
  else
    no_of_surfacetriangles_id = NoID;

  stat = nc_inq_dimid(ncid, "no_of_surfaceelements",
                      &no_of_surfaceelements_id);
  if (stat != NC_EBADDIM)
    handle_error( stat, "no_of_surfacetriangles" );
  else
    no_of_surfaceelements_id = NoID;

  size_t no_of_points = 0;
  size_t no_of_tetraeders = 0;
  size_t no_of_prisms = 0;
  size_t no_of_surfacetriangles = 0;
  size_t no_of_surfaceelements = 0;

  if (no_of_points_id != NoID) {
    stat = nc_inq_dimlen(ncid, no_of_points_id, &no_of_points);
    handle_error( stat );
  }

  if (no_of_tetraeders_id != NoID) {
    stat = nc_inq_dimlen(ncid, no_of_tetraeders_id, &no_of_tetraeders);
    handle_error( stat );
  }

  if (no_of_prisms_id != NoID) {
    stat = nc_inq_dimlen(ncid, no_of_prisms_id, &no_of_prisms);
    handle_error( stat );
  }

  if (no_of_surfacetriangles_id != NoID) {
    stat = nc_inq_dimlen(ncid, no_of_surfacetriangles_id,
                         &no_of_surfacetriangles);
    handle_error( stat );
  }

  if (no_of_surfaceelements_id != NoID) {
    stat = nc_inq_dimlen(ncid, no_of_surfaceelements_id,
                         &no_of_surfaceelements);
    handle_error( stat );
  }

  // fetch variable ids
  int points_xc_id(NoID), points_yc_id(NoID), points_zc_id(NoID);
  int points_of_surfacetriangles_id(NoID), points_of_tetraeders_id(NoID);
  int points_of_prisms_id(NoID), boundarymarker_of_surfaces_id(NoID);
  stat = nc_inq_varid(ncid, "points_xc", &points_xc_id);
  handle_error( stat, "points_xc" );
  stat = nc_inq_varid(ncid, "points_yc", &points_yc_id);
  handle_error( stat, "points_yc" );
  stat = nc_inq_varid(ncid, "points_zc", &points_zc_id);
  handle_error( stat, "points_zc" );

  stat = nc_inq_varid(ncid, "points_of_tetraeders", &points_of_tetraeders_id);
  if (stat != NC_ENOTVAR)
    handle_error( stat, "points_of_tetraeders" );
  else
    points_of_tetraeders_id = NoID;

  stat = nc_inq_varid(ncid, "points_of_prisms", &points_of_prisms_id);
  if (stat != NC_ENOTVAR)
    handle_error( stat, "points_of_prisms" );
  else
    points_of_prisms_id = NoID;

  stat = nc_inq_varid(ncid, "points_of_surfacetriangles",
                      &points_of_surfacetriangles_id);
  if (stat != NC_ENOTVAR)
    handle_error( stat, "points_of_surfacetriangles" );
  else
    points_of_surfacetriangles_id = NoID;

  stat = nc_inq_varid(ncid, "boundarymarker_of_surfaces",
                      &boundarymarker_of_surfaces_id);
  if (stat != NC_ENOTVAR)
    handle_error( stat, "boundarymarker_of_surfaces" );
  else
    boundarymarker_of_surfaces_id = NoID;

  // access coordinate data and shuffle into node list
  {
    DVector<double> xc(no_of_points), yc(no_of_points), zc(no_of_points);
    stat = nc_get_var_double(ncid, points_xc_id, xc.pointer());
    handle_error( stat );
    stat = nc_get_var_double(ncid, points_yc_id, yc.pointer());
    handle_error( stat );
    stat = nc_get_var_double(ncid, points_zc_id, zc.pointer());
    handle_error( stat );

    vtx.resize( no_of_points );
    for (size_t i=0; i<no_of_points; ++i) {
      vtx[i][0] = xc[i];
      vtx[i][1] = yc[i];
      vtx[i][2] = zc[i];
    }
  }

  // access triangle element indices
  uint triSection(NotFound), tetSection(NotFound);
  if (points_of_surfacetriangles_id != NoID) {
    DVector<int> elix;
    elix.allocate( 3*no_of_surfacetriangles );
    stat = nc_get_var_int(ncid, points_of_surfacetriangles_id, elix.pointer());
    handle_error( stat );

    Indices ulix( elix.size() );
    std::copy(elix.begin(), elix.end(), ulix.begin());
    triSection = appendSection(Mx::Tri3, ulix);
    section(triSection).rename( "TriBoundaries" );
  }

  // create boundary conditions from surface markers
  if (triSection != NotFound) {
    DVector<int> bdm( no_of_surfaceelements );
    stat = nc_get_var_int(ncid, boundarymarker_of_surfaces_id, bdm.pointer());
    handle_error( stat );

    Indices marker;
    for (size_t i=0; i<no_of_surfaceelements; ++i) {
      const int mi = bdm[i];
      Indices::iterator pos = std::find(marker.begin(), marker.end(), mi);
      uint iboco = std::distance(marker.begin(), pos);
      if (pos == marker.end()) {
        marker.push_back(mi);
        iboco = appendBoco( MxMeshBoco(Mx::BcWall) );
        boco(iboco).tag( mi );
        boco(iboco).rename( "marker_"+str(mi) );
      }
      if (i < section(triSection).nelements())
        boco(iboco).appendElement( i );
    }

    for (uint j=0; j<nbocos(); ++j)
      boco(j).sort();
  }

  // access tetraeder element indices
  if (no_of_tetraeders > 0) {
    DVector<int> elix;
    elix.allocate( 4*no_of_tetraeders );
    stat = nc_get_var_int(ncid, points_of_tetraeders_id, elix.pointer());
    handle_error( stat );

    Indices ulix( elix.size() );
    std::copy(elix.begin(), elix.end(), ulix.begin());
    tetSection = appendSection(Mx::Tet4, ulix);
    section( tetSection ).rename( "TetDomain" );
  }

  // access pentahedra element indices
  if (no_of_prisms > 0) {
    DVector<int> elix;
    elix.allocate( 6*no_of_prisms );
    stat = nc_get_var_int(ncid, points_of_prisms_id, elix.pointer());
    handle_error( stat );

    Indices ulix( elix.size() );
    std::copy(elix.begin(), elix.end(), ulix.begin());
    tetSection = appendSection(Mx::Penta6, ulix);
    section( tetSection ).rename( "PentaDomain" );
  }

  // recover boundary/element group names
  const int nbc = nbocos();
  for (int i=0; i<nbc; ++i) {
    MxMeshBoco & bc( boco(i) );
    string mid = "marker_" + str(bc.tag());
    size_t attrLen(0);
    stat = nc_inq_attlen(ncid, NC_GLOBAL, mid.c_str(), &attrLen);
    handle_error(stat);
    string attrib(attrLen, ' ');
    stat = nc_get_att_text(ncid, NC_GLOBAL, mid.c_str(), &attrib[0]);
    handle_error(stat);
    bc.rename(attrib);
  }

  stat = nc_close(ncid);
  handle_error( stat );
}
