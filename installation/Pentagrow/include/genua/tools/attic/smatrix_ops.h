// mathematical operators for  SMatrix<M,N,NumType>
// file generated by genua/tools/opsprint.py

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator+ (const SMatrix<M,N,NumType> & a, const SMatrix<M,N,NumType> & b)
{
  assert(a.size() == b.size());
  typename SMatrix<M,N,NumType> c(a);
  for (uint i=0; i<a.size(); ++i)
    c[i] += b[i];
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> & operator+= (SMatrix<M,N,NumType> & a, const SMatrix<M,N,NumType> & b)
{
  assert(a.size() == b.size());
  for (uint i=0; i<a.size(); ++i)
    a[i] += b[i];
  return a;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator+ (const SMatrix<M,N,NumType> & a, NumType b)
{
  typename SMatrix<M,N,NumType> c(a);
  for (uint i=0; i<a.size(); ++i)
    c[i] += b;
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> & operator+= (SMatrix<M,N,NumType> & a, NumType b)
{
  for (uint i=0; i<a.size(); ++i)
    a[i] += b;
  return a;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator+ (NumType a, const SMatrix<M,N,NumType> & b)
{
  typename SMatrix<M,N,NumType> c(b.size());
  for (uint i=0; i<b.size(); ++i)
    c[i] = a + b[i];
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator- (const SMatrix<M,N,NumType> & a, const SMatrix<M,N,NumType> & b)
{
  assert(a.size() == b.size());
  typename SMatrix<M,N,NumType> c(a);
  for (uint i=0; i<a.size(); ++i)
    c[i] -= b[i];
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> & operator-= (SMatrix<M,N,NumType> & a, const SMatrix<M,N,NumType> & b)
{
  assert(a.size() == b.size());
  for (uint i=0; i<a.size(); ++i)
    a[i] -= b[i];
  return a;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator- (const SMatrix<M,N,NumType> & a, NumType b)
{
  typename SMatrix<M,N,NumType> c(a);
  for (uint i=0; i<a.size(); ++i)
    c[i] -= b;
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> & operator-= (SMatrix<M,N,NumType> & a, NumType b)
{
  for (uint i=0; i<a.size(); ++i)
    a[i] -= b;
  return a;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator- (NumType a, const SMatrix<M,N,NumType> & b)
{
  typename SMatrix<M,N,NumType> c(b.size());
  for (uint i=0; i<b.size(); ++i)
    c[i] = a - b[i];
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator* (const SMatrix<M,N,NumType> & a, NumType b)
{
  typename SMatrix<M,N,NumType> c(a);
  for (uint i=0; i<a.size(); ++i)
    c[i] *= b;
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> & operator*= (SMatrix<M,N,NumType> & a, NumType b)
{
  for (uint i=0; i<a.size(); ++i)
    a[i] *= b;
  return a;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator* (NumType a, const SMatrix<M,N,NumType> & b)
{
  typename SMatrix<M,N,NumType> c(b.size());
  for (uint i=0; i<b.size(); ++i)
    c[i] = a * b[i];
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator/ (const SMatrix<M,N,NumType> & a, NumType b)
{
  typename SMatrix<M,N,NumType> c(a);
  NumType ib(1.0/b);
  for (uint i=0; i<a.size(); ++i)
    c[i] *= ib;
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> & operator/= (SMatrix<M,N,NumType> & a, NumType b)
{
  typename NumType ib(1.0/b);
  for (uint i=0; i<a.size(); ++i)
    a[i] *= ib;
  return a;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> operator/ (NumType a, const SMatrix<M,N,NumType> & b)
{
  typename SMatrix<M,N,NumType> c(b.size());
  for (uint i=0; i<b.size(); ++i)
    c[i] = a / b[i];
  return c;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> sin(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = sin(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> cos(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = cos(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> tan(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = tan(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> asin(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = asin(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> acos(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = acos(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> atan(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = atan(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> exp(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = exp(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> log(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = log(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> sqrt(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = sqrt(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> ceil(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = ceil(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> floor(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = floor(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> sinh(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = sinh(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> cosh(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = cosh(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> tanh(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = tanh(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> fabs(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = fabs(a[i]);
  return b;
}

template <uint M, uint N, class NumType>
inline SMatrix<M,N,NumType> log10(const SMatrix<M,N,NumType> & a)
{
  typename SMatrix<M,N,NumType> b(a.size());
  for (uint i=0; i<a.size(); ++i)
    b[i] = log10(a[i]);
  return b;
}

