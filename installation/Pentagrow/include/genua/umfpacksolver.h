#ifndef GENUA_UMFPACKSOLVER_H
#define GENUA_UMFPACKSOLVER_H

#include "forward.h"
#include "abstractlinearsolver.h"
#include "cholmodsolver.h"

/** Context for calling UMFPACK.
 *
 * This is an internal helper class to facilitate the use of the UMFPACK
 * library for solving unsymmetric sparse linear systems.
 *
 * Not implemented yet:
 * - Adapt solve() for single-precision arguments.
 * - Interface for MPC/constraint handling
 *
 * \internal
 * \ingroup numerics
 * \sa CholmodContext, UmfpackSolver, AbstractLinearSolverTpl
 */
class UmfpackContext : public CholmodContext
{
public:

  using CholmodContext::index_t;

  /// set default values
  UmfpackContext(bool useComplex = false);

  /// release memory
  ~UmfpackContext();

  /// configure solver settings
  void configure(const ConfigParser &cfg);

  /// symbolic factorization
  bool factorizeSymbolic();

  /// numeric factorization
  bool factorizeNumeric();

  /// interface for real-valued solve routine
  bool solve(bool transposed, const double b[], double x[]);

  /// interface for real-valued solve routine
  bool solve(bool transposed, const std::complex<double> b[],
             std::complex<double> x[]);

  /// peak memory used (or estimate)
  double peakMemory() const;

  /// release memory
  void release();

  /// error or warning message
  const char *lastMessage() const;

private:

  /// control parameters
  double m_control[128];

  /// information
  double m_info[128];

  /// opaque solver objects
  void *m_psymbolic = nullptr;

  /// opaque solver objects
  void *m_pnumeric = nullptr;

  /// use complex calls?
  bool m_iscomplex = false;
};

/** Interface to direct sparse solver UMFPACK.
  *
  *
  *
  * \ingroup numerics
  * \sa CholmodSolver, SpqrSolver, AbstractLinearSolverTpl
  */
template <typename FloatType>
class UmfpackSolver : public AbstractLinearSolverTpl<FloatType>
{
public:

  typedef AbstractLinearSolverTpl<FloatType> Base;

  /// create solver object with type flag
  UmfpackSolver(uint typeFlag = SpMatrixFlag::RealUnsymmetric)
    : Base(typeFlag), m_context( SpMatrixFlag::isComplex(typeFlag) )
  {
    Base::m_implName = "SuiteSparse/UMFPACK";
  }

  /// load configuration settings
  void configure(const ConfigParser &cfg) {
    m_context.configure(cfg);
  }

  /// full factorization (minimum interface)
  bool factor(const CsrMatrix<FloatType,1> *pa) {
    ScopeTimer timer( AbstractLinearSolverTpl<FloatType>::m_factorTime );
    ++Base::m_factorCount;
    m_context.assimilate(pa);
    bool stat = m_context.factorizeSymbolic();
    Base::m_maxMemory = m_context.peakMemory();
    if (not stat)
      return false;
    stat = m_context.factorizeNumeric();
    Base::m_maxMemory = m_context.peakMemory();
    return stat;
  }

  /// numerical factorization only (if supported)
  bool refactor(const CsrMatrix<FloatType,1> *pa) {
    ScopeTimer timer( AbstractLinearSolverTpl<FloatType>::m_factorTime );
    ++Base::m_factorCount;
    m_context.assimilate(pa);
    bool ok = m_context.factorizeNumeric();
    Base::m_maxMemory = m_context.peakMemory();
    return ok;
  }

  /// UMFPACK doesn't do multiple RHS in one call ...
  bool solve(const DMatrix<FloatType> &b, DMatrix<FloatType> &x) {
    ScopeTimer timer( AbstractLinearSolverTpl<FloatType>::m_solveTime );
    ++Base::m_solveCount;

    bool ok = true;
    for (size_t j=0; j<b.ncols(); ++j)
      ok &= m_context.solve(Base::m_solveTransposed,
                            b.colpointer(j), x.colpointer(j));
    return ok;
  }

  /// solve single RHS (by default implemented in terms of the above)
  bool solve(const DVector<FloatType> &b, DVector<FloatType> &x) {
    ScopeTimer timer( AbstractLinearSolverTpl<FloatType>::m_solveTime );
    ++Base::m_solveCount;
    return m_context.solve(Base::m_solveTransposed, b.pointer(), x.pointer());
  }

  /// access last message generated by error
  const char *lastMessage() const {return m_context.lastMessage();}

private:

  /// solver context
  UmfpackContext m_context;
};

#endif // UMFPACKSOLVER_H
