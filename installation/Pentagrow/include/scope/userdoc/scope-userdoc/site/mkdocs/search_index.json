{
    "docs": [
        {
            "location": "/index.html", 
            "text": "scope user manual\n\n\nScope displays meshes for computational fluid dynamics (CFD), structural \nanalysis and is meant to support many common operations in the fields of\nflight dynamics and aeroelasticity.\n\n\nBasic Concepts\n\n\nScope loads a variety of \nmesh file formats\n; all of these files \ncontain discretized information, that is, data defined in terms of nodes \n(grid points) and elements; scope does not handle continuous geometry, such as,\nfor example, surfaces defined in CAD systems adn stored in IGES or STEP files.\n\n\nMeshes analysis\n functions allow to generate sectional views through volume meshes. Quality criteria can be evaluated in order to locate and highlight low-quality elements.\n\n\nIn many cases, scope will also import data fields associated with these meshes. \nScalar fields\n can be displayed as color contours; vector fields can be turned into \nsurface streamlines\n. Sectioning tools permit to generate XY-plots of surface data. \n\n\nOriginally, scope was implemented to support \nresearch\n in the field of aeroelasticity. It has since been used as a visualization and post-processing back-end for \nanother solver\n and to support work on \nautomatic mesh generation\n.\n\n\nExamples\n\n\nMap mesh deformation\n\n\nAeroelastic analyses regularly require that deformations of a structural model are translated to the wetted surface of a dissimilar aerodynamic mesh. Scope implements \ndifferent algorithms\n which can deal with many industrially relevant cases with complex geometry and discontinuous displacements.\n\n\nGenerate flight loads\n\n\nDifferent types of \nstructural loads\n can be generated from one or a collection of aerodynamic solutions. \n\n\nConvert mesh formats\n\n\nScope can be use simply to convert between \nmesh formats\n (say, from the format used for the DLR TAU solver to Stanford\ns SU2 solver format), without the need to go through a commercial tool.\n\n\nScope is not Paraview\n\n\nScope does not attempt to replace \nParaview\n, which is far more flexible and most likely more suitable for many applications. Instead, Scope will often be able to convert your analysis results to a \nfile format\n readable by Paraview for further postprocessing.\n\n\nState of Documentation\n\n\nThis user manual makes no claim to completeness; with time, some sections may become outdated or inaccurate. \nContact\n the author if you would like to fund improved documentation.\n\n\nLicense\n\n\nScope is available in source code form under the terms of the \nGNU Public License\n. Compiled versions are regularly updated for use on Mac OS X, Windows and some Linux distibutions.", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#scope-user-manual", 
            "text": "Scope displays meshes for computational fluid dynamics (CFD), structural \nanalysis and is meant to support many common operations in the fields of\nflight dynamics and aeroelasticity.", 
            "title": "scope user manual"
        }, 
        {
            "location": "/index.html#basic-concepts", 
            "text": "Scope loads a variety of  mesh file formats ; all of these files \ncontain discretized information, that is, data defined in terms of nodes \n(grid points) and elements; scope does not handle continuous geometry, such as,\nfor example, surfaces defined in CAD systems adn stored in IGES or STEP files.  Meshes analysis  functions allow to generate sectional views through volume meshes. Quality criteria can be evaluated in order to locate and highlight low-quality elements.  In many cases, scope will also import data fields associated with these meshes.  Scalar fields  can be displayed as color contours; vector fields can be turned into  surface streamlines . Sectioning tools permit to generate XY-plots of surface data.   Originally, scope was implemented to support  research  in the field of aeroelasticity. It has since been used as a visualization and post-processing back-end for  another solver  and to support work on  automatic mesh generation .", 
            "title": "Basic Concepts"
        }, 
        {
            "location": "/index.html#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/index.html#map-mesh-deformation", 
            "text": "Aeroelastic analyses regularly require that deformations of a structural model are translated to the wetted surface of a dissimilar aerodynamic mesh. Scope implements  different algorithms  which can deal with many industrially relevant cases with complex geometry and discontinuous displacements.", 
            "title": "Map mesh deformation"
        }, 
        {
            "location": "/index.html#generate-flight-loads", 
            "text": "Different types of  structural loads  can be generated from one or a collection of aerodynamic solutions.", 
            "title": "Generate flight loads"
        }, 
        {
            "location": "/index.html#convert-mesh-formats", 
            "text": "Scope can be use simply to convert between  mesh formats  (say, from the format used for the DLR TAU solver to Stanford s SU2 solver format), without the need to go through a commercial tool.", 
            "title": "Convert mesh formats"
        }, 
        {
            "location": "/index.html#scope-is-not-paraview", 
            "text": "Scope does not attempt to replace  Paraview , which is far more flexible and most likely more suitable for many applications. Instead, Scope will often be able to convert your analysis results to a  file format  readable by Paraview for further postprocessing.", 
            "title": "Scope is not Paraview"
        }, 
        {
            "location": "/index.html#state-of-documentation", 
            "text": "This user manual makes no claim to completeness; with time, some sections may become outdated or inaccurate.  Contact  the author if you would like to fund improved documentation.", 
            "title": "State of Documentation"
        }, 
        {
            "location": "/index.html#license", 
            "text": "Scope is available in source code form under the terms of the  GNU Public License . Compiled versions are regularly updated for use on Mac OS X, Windows and some Linux distibutions.", 
            "title": "License"
        }, 
        {
            "location": "/formats/index.html", 
            "text": "Supported File Formats\n\n\nScope has built-in support for many file formats. \n\n\nMesh Data\n\n\nMesh files in the following formats can be imported into scope:\n\n\n\n\nNative .zml files (see below)\n\n\nCGNS\n version 2.53 based on ADF (not HDF)\n\n\nSU2\n mesh files (.su2)\n\n\nNASTRAN bulk data files (most, but not all, element types)\n\n\nTAU\n mesh files (tetrahedral and hybrid, .taumesh)\n\n\nLegacy VTK format files (.vtk)\n\n\nTetGen meshes (.node/.element/.faces)\n\n\nEDGE mesh files (.bmesh)\n\n\nSTL mesh files, both binary and plain text format\n\n\nLimited support for Abaqus input files (.inp)\n\n\n\n\nComputational Results\n\n\nMesh files in the following formats can be imported into scope:\n\n\n\n\nNative .zml files (see below)\n\n\nCGNS\n version 2.53 based on ADF (not HDF)\n\n\nSU2\n mesh files (.su2)\n\n\nNASTRAN punch files (.pch)\n\n\nLegacy VTK format files (.vtk)\n\n\nEDGE fluid data and boundary deformation data (.bout, .bdis)\n\n\nAEREL\n results from AERELPLOT \nformat files\n\n\nData can be written to the \nEnsight Gold\n file format which is most convenient for importing data into \nParaview\n. \n\n\n\n\nMass import\n\n\nThere are many situations where a certain mesh file is used for a large number of simulations (or \nsubcases\n). Some simulation software directly supports writing a single output file containing these many subcases, while others (such as EDGE or SU2) write one output file for each case. With scope, it is possible to load arbitrarily many such result files, optionally \nreduce file size\n by eliminating volume elements, and store the merged mesh and results in a single native file.\n\n\nIn order to import multiple result runs into a single native file, load first the corresponding mesh \ngeometry\n, e.g. a .bmsh file. Once the mesh is available, scope will permit the selection multiple files in the file selection dialog opened by the \nLoad\n function.\n\n\nWhen an automated approach is preferred for use in scripting, the small command-line utility program \nmergefields\n can be called upon to join multiple solution files into a single one. An example command-line call used to merge multiple SU2 solution files (for different angles of attack) in VTK format would look as follows:\n\n\nmergefields run1.vtk=\nAlpha=+1\n run3.vtk=\nAlpha=+3\n run5.vtk=\nAlpha=+5\n\n\n\n\n\nThis call would generate a new file named \nmerged.zml\n that contains three subcases with all fields from the three separate solution files. Such a merged file is especially useful when structural loads are to be generated for all of these solutions.\n\n\nFinally, note that merged CFD files can become very large indeed. Loading and saving such files can be rather slow when accessing mapped network drives on Windows 7, XP, 2008, 2012. This is an inherent limitation of the operating system functions which needs to be \nresolved\n by system administration.    \n\n\nNative Format\n\n\nScope also supports a fairly efficient native binary file format, for which the extension .zml is used. Binary files are compressed (currently using \nLZ4\n or \nzlib\n, but that may change) and can be converted to a human-readable and editable plain text XML format, either from within scope (Menu \nFile\n, option \nExport\n, select \nPlain XML\n) or using the command-line utility \nzml2xml\n. Another command-line utility named \nzmlprint\n can be used to inspect the data structure of a native format file. Typical output of this utility looks like this:\n\n\nRecognized GBF file format; summary: \nNode: MxMesh\nBlock: 0\n2 attributes: \n[0] gbf_format_generator = XmlElement\n[1] gbf_format_payload_type = Empty\n  Node: MxNote\n  Block: 0\n  2 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] gbf_format_payload_type = Empty\n    Node: NastranGID\n    Block: 62872\n    5 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] bdata_bytes = 62872\n    [2] bdata_type = Int32\n    [3] count = 15718\n    [4] gbf_format_payload_type = Int32\n    End of Node: [NastranGID]\n  End of Node: [MxNote]\n  Node: MxSolutionTree\n  Block: 0\n  4 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] children = 2\n  [2] name = Results\n  [3] gbf_format_payload_type = Empty\n    Node: MxNote\n    Block: 0\n    2 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] gbf_format_payload_type = Empty\n    End of Node: [MxNote]\n    Node: MxSolutionTree\n    Block: 0\n    4 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] children = 0\n    [2] name = Displacements\n    [3] gbf_format_payload_type = Empty\n      Node: MxNote\n      Block: 0\n      2 attributes: \n      [0] gbf_format_generator = XmlElement\n      [1] gbf_format_payload_type = Empty\n      End of Node: [MxNote]\n      Node: Fields\n      Block: 256\n      5 attributes: \n      [0] gbf_format_generator = XmlElement\n      [1] bdata_bytes = 256\n      [2] bdata_type = Int32\n      [3] count = 64\n      [4] gbf_format_payload_type = Int32\n      End of Node: [Fields]\n    End of Node: [MxSolutionTree]\n[...]\n Node: MxMeshField\n  Block: 754464\n  9 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] bdata_bytes = 754464\n  [2] bdata_type = Float64\n  [3] class = displacement\n  [4] dimension = 6\n  [5] name = Displacement 11\n  [6] nodal_field = true\n  [7] solution_index = 0\n  [8] gbf_format_payload_type = Float64\n    Node: MxNote\n    Block: 0\n    2 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] gbf_format_payload_type = Empty\n    End of Node: [MxNote]\n  End of Node: [MxMeshField]\n  Node: MxMeshField\n  Block: 754464\n  9 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] bdata_bytes = 754464\n  [2] bdata_type = Float64\n  [3] class = displacement\n  [4] dimension = 6\n  [5] name = Displacement 12\n  [6] nodal_field = true\n  [7] solution_index = 0\n  [8] gbf_format_payload_type = Float64\n    Node: MxNote\n    Block: 0\n    2 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] gbf_format_payload_type = Empty\n    End of Node: [MxNote]\n  End of Node: [MxMeshField]\n[...]", 
            "title": "File Formats"
        }, 
        {
            "location": "/formats/index.html#supported-file-formats", 
            "text": "Scope has built-in support for many file formats.", 
            "title": "Supported File Formats"
        }, 
        {
            "location": "/formats/index.html#mesh-data", 
            "text": "Mesh files in the following formats can be imported into scope:   Native .zml files (see below)  CGNS  version 2.53 based on ADF (not HDF)  SU2  mesh files (.su2)  NASTRAN bulk data files (most, but not all, element types)  TAU  mesh files (tetrahedral and hybrid, .taumesh)  Legacy VTK format files (.vtk)  TetGen meshes (.node/.element/.faces)  EDGE mesh files (.bmesh)  STL mesh files, both binary and plain text format  Limited support for Abaqus input files (.inp)", 
            "title": "Mesh Data"
        }, 
        {
            "location": "/formats/index.html#computational-results", 
            "text": "Mesh files in the following formats can be imported into scope:   Native .zml files (see below)  CGNS  version 2.53 based on ADF (not HDF)  SU2  mesh files (.su2)  NASTRAN punch files (.pch)  Legacy VTK format files (.vtk)  EDGE fluid data and boundary deformation data (.bout, .bdis)  AEREL  results from AERELPLOT \nformat files  Data can be written to the  Ensight Gold  file format which is most convenient for importing data into  Paraview .", 
            "title": "Computational Results"
        }, 
        {
            "location": "/formats/index.html#mass-import", 
            "text": "There are many situations where a certain mesh file is used for a large number of simulations (or  subcases ). Some simulation software directly supports writing a single output file containing these many subcases, while others (such as EDGE or SU2) write one output file for each case. With scope, it is possible to load arbitrarily many such result files, optionally  reduce file size  by eliminating volume elements, and store the merged mesh and results in a single native file.  In order to import multiple result runs into a single native file, load first the corresponding mesh  geometry , e.g. a .bmsh file. Once the mesh is available, scope will permit the selection multiple files in the file selection dialog opened by the  Load  function.  When an automated approach is preferred for use in scripting, the small command-line utility program  mergefields  can be called upon to join multiple solution files into a single one. An example command-line call used to merge multiple SU2 solution files (for different angles of attack) in VTK format would look as follows:  mergefields run1.vtk= Alpha=+1  run3.vtk= Alpha=+3  run5.vtk= Alpha=+5   This call would generate a new file named  merged.zml  that contains three subcases with all fields from the three separate solution files. Such a merged file is especially useful when structural loads are to be generated for all of these solutions.  Finally, note that merged CFD files can become very large indeed. Loading and saving such files can be rather slow when accessing mapped network drives on Windows 7, XP, 2008, 2012. This is an inherent limitation of the operating system functions which needs to be  resolved  by system administration.", 
            "title": "Mass import"
        }, 
        {
            "location": "/formats/index.html#native-format", 
            "text": "Scope also supports a fairly efficient native binary file format, for which the extension .zml is used. Binary files are compressed (currently using  LZ4  or  zlib , but that may change) and can be converted to a human-readable and editable plain text XML format, either from within scope (Menu  File , option  Export , select  Plain XML ) or using the command-line utility  zml2xml . Another command-line utility named  zmlprint  can be used to inspect the data structure of a native format file. Typical output of this utility looks like this:  Recognized GBF file format; summary: \nNode: MxMesh\nBlock: 0\n2 attributes: \n[0] gbf_format_generator = XmlElement\n[1] gbf_format_payload_type = Empty\n  Node: MxNote\n  Block: 0\n  2 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] gbf_format_payload_type = Empty\n    Node: NastranGID\n    Block: 62872\n    5 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] bdata_bytes = 62872\n    [2] bdata_type = Int32\n    [3] count = 15718\n    [4] gbf_format_payload_type = Int32\n    End of Node: [NastranGID]\n  End of Node: [MxNote]\n  Node: MxSolutionTree\n  Block: 0\n  4 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] children = 2\n  [2] name = Results\n  [3] gbf_format_payload_type = Empty\n    Node: MxNote\n    Block: 0\n    2 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] gbf_format_payload_type = Empty\n    End of Node: [MxNote]\n    Node: MxSolutionTree\n    Block: 0\n    4 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] children = 0\n    [2] name = Displacements\n    [3] gbf_format_payload_type = Empty\n      Node: MxNote\n      Block: 0\n      2 attributes: \n      [0] gbf_format_generator = XmlElement\n      [1] gbf_format_payload_type = Empty\n      End of Node: [MxNote]\n      Node: Fields\n      Block: 256\n      5 attributes: \n      [0] gbf_format_generator = XmlElement\n      [1] bdata_bytes = 256\n      [2] bdata_type = Int32\n      [3] count = 64\n      [4] gbf_format_payload_type = Int32\n      End of Node: [Fields]\n    End of Node: [MxSolutionTree]\n[...]\n Node: MxMeshField\n  Block: 754464\n  9 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] bdata_bytes = 754464\n  [2] bdata_type = Float64\n  [3] class = displacement\n  [4] dimension = 6\n  [5] name = Displacement 11\n  [6] nodal_field = true\n  [7] solution_index = 0\n  [8] gbf_format_payload_type = Float64\n    Node: MxNote\n    Block: 0\n    2 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] gbf_format_payload_type = Empty\n    End of Node: [MxNote]\n  End of Node: [MxMeshField]\n  Node: MxMeshField\n  Block: 754464\n  9 attributes: \n  [0] gbf_format_generator = XmlElement\n  [1] bdata_bytes = 754464\n  [2] bdata_type = Float64\n  [3] class = displacement\n  [4] dimension = 6\n  [5] name = Displacement 12\n  [6] nodal_field = true\n  [7] solution_index = 0\n  [8] gbf_format_payload_type = Float64\n    Node: MxNote\n    Block: 0\n    2 attributes: \n    [0] gbf_format_generator = XmlElement\n    [1] gbf_format_payload_type = Empty\n    End of Node: [MxNote]\n  End of Node: [MxMeshField]\n[...]", 
            "title": "Native Format"
        }, 
        {
            "location": "/display/index.html", 
            "text": "Data Display\n\n\nInspecting Meshes\n\n\nEven when only a mesh file (i.e. no computed data) is loaded, scope can still be useful for visualisation. Sections through volume meshes are a quick way to obtain a rough impression of overall mesh quality. For example, the image below shows a two-plane section through a RANS mesh which immediately shows the mesh refinement level in the vicinity of the aircraft body.\n\n\n\n\nFurthermore, an initial check of element quality is possible using the \nMesh quality\n entry in the \nView\n menu. This function highlights tangled (self-intersecting) volume elements and optionally can locate low-quality tetrahedra as defined by the dihedral angle between faces. \n\n\n\n\nIn the example shown, only a moderate number of low-quality tetrahedra are present. Furthermore, these elements do not appear to be located in regions where their presence would be suspected to cause difficulties.\n\n\nScalar Field Data\n\n\nContour Plot\n\n\nThe screenshot below shows a color contour plot of the surface skin friction coefficient computed for the DLR F4 wind tunnel model with forced transition near the leading edges. By default, blue indicates small values and red large magnitudes.\n\n\n \n\n\nOverlayed as thin black lines are surface velocity streamlines on both the body and the wake surfaces which are explicitly present in this particular mesh. \n\n\nPlane sections\n\n\nSectional data can be extracted from meshes using the \nSurface Slice\n function. A plane rectangle is defined in terms of an origin and two direction vectors. Then, data on all mesh surfaces intersected by this rectangle can be shown as a curve plot.   \n\n\nTwo different fields can be shown at the same time. The blue graphs always corresponds to the left y-axis which by default is independent of the red graph (right y-axis). However, when the \nRescale y-axis\n checkbox is activated, then both axes are locked to the selected range. This option is useful for the comparison of different solution (flight conditions, frequencies, \n) stored in one and the same file.\n\n\n\n\nIn order to generate a section plot, a plane must be defined first. Often, a one of the coordinate planes is desired, for which one of the top three buttons can be used. Limits of the plane rectangle used for slicing the mesh are then computed from the bounding volume of all visible surfaces. Sometimes, these limits are not appropriate for the intended section, in which case the option \nUser-defined plane\n can be selected. Here, the slicing rectangle is defined manually as its origin and two direction vectors.\n\n\n\n\nTip\n\n\nA file containing very many subcases can hold hundreds of fields with the same name, \ne.g. pressure fields for many different flight conditions. To switch between these \nfields, move the UI focus to the field selection combo box (e.g. \nLeft Axis\n). \nNow, whenever you click one of the field names in the left-hand side tree view holding\nthe subcases, the corresponding field will be selected for slicing. In this way, it is \neasy to navigate files containing very many solutions. \n\n\n\n\nCurves shown in the plot window can also be exported. Export to PDF or image formats stores just the plot as an image, while the matlab and plain text options store the plotted data to a file. Note, however, that the data is generated by computing slices of surface elements. Hence, the visible data is not always a single continuous curve, but may consist of multiple segments. \n\n\nStreamlines\n\n\nVector fields with at least three components can be displayed as continuous lines on any mesh surface where they are defined. The image below shows skin friction lines generated from the friction coefficient vector stored in a CFD solution file.\n\n\n\n\nHedgehog Vector Plot\n\n\nAny three-component vector field can also be displayed as a set of simple lines originating at the node where they are defined. This can be useful to check the orientation and magnitude of nodal forces, for which an example is shown in the picture below.\n\n\n\n\nThis type of vector display is named \nhedgehog plot\n and can be configured using the options in the dialog shown here. For each nodal vector, a thin line (called \nneedle\n) is drawn. The length of these lines can either be the same everywhere or adjusted to the local mesh size for the case where only the direction is of interest. Otherwise, the needle length may also be scaled by the magnitude of the corresponding vectors as was done in the screenshot above.\n\n\n\n\nMesh Deformation\n\n\nVector fields can also represent deformation fields. When files are imported from structural analyses, such fields are automatically tagged as containing static deformation or eigenvector fields. The mesh deformation dialog allows to display either the deformed mesh by applying a linear scaling factor to the stored deformation field, or to animate the deformed shape. Static deformations are animated as ramping up from the undeformed state to the fully deflected configuration, while modeshapes are displayed as continuous  oscillations.\n\n\n\n\nFlutter Modes\n\n\nFlutter modes are stored in \nnative format\n (.zml) files as a special case of periodic trajectories. Since the format is meant to be rather general, flutter modes are therefore stored as short flight path segments of an elastic aircraft which happens remain at rest. For this reason, they can be displayed by the \nTrajectory animation\n option in the \nDeformation\n display dialog. \n\n\n\n\nAs mode shapes are usually normalized in some more or less useful manner, it is very common that the visualization of a deformation shape with default scaling (1.0) looks very exaggerated or does not appear to deform at all. Change the \nDeformation scale\n factor in order to alleviate this problem. As flutter modes are periodic, the animation feature with the *\nLoop\n option active is recommended. \n\n\nManual Mode Definition\n\n\nEven when a flutter problem is solved using an externally provided software, the solution can be displayed with scope. To do so, use the entry \nManually define flutter mode\n in the \nLoads\n menu. In the dialog windows that opens, first name the mode; this is important whenever you want to define multiple modeshapes. Then enter the real and imaginary parts of the complex eigenvalue (in radian per second). Finally, define the modal participation coefficients. This can be done either by filling complex values in a table, or by pasting text from the output of another software as in the second screenshot below.  \n\n\n\n\nWhen using the text option, scope expects that the participation factors are given in the same sequence as the eigenmodes and as pairs of real and imaginary values. In the above example, the participation factor for the first eigenmode is hence (3.197e-5 - 5.621e-6 i), the second is (-9.603e-4 - 7.263e-5 i), and so on.", 
            "title": "Data Display"
        }, 
        {
            "location": "/display/index.html#data-display", 
            "text": "", 
            "title": "Data Display"
        }, 
        {
            "location": "/display/index.html#inspecting-meshes", 
            "text": "Even when only a mesh file (i.e. no computed data) is loaded, scope can still be useful for visualisation. Sections through volume meshes are a quick way to obtain a rough impression of overall mesh quality. For example, the image below shows a two-plane section through a RANS mesh which immediately shows the mesh refinement level in the vicinity of the aircraft body.   Furthermore, an initial check of element quality is possible using the  Mesh quality  entry in the  View  menu. This function highlights tangled (self-intersecting) volume elements and optionally can locate low-quality tetrahedra as defined by the dihedral angle between faces.    In the example shown, only a moderate number of low-quality tetrahedra are present. Furthermore, these elements do not appear to be located in regions where their presence would be suspected to cause difficulties.", 
            "title": "Inspecting Meshes"
        }, 
        {
            "location": "/display/index.html#scalar-field-data", 
            "text": "", 
            "title": "Scalar Field Data"
        }, 
        {
            "location": "/display/index.html#contour-plot", 
            "text": "The screenshot below shows a color contour plot of the surface skin friction coefficient computed for the DLR F4 wind tunnel model with forced transition near the leading edges. By default, blue indicates small values and red large magnitudes.     Overlayed as thin black lines are surface velocity streamlines on both the body and the wake surfaces which are explicitly present in this particular mesh.", 
            "title": "Contour Plot"
        }, 
        {
            "location": "/display/index.html#plane-sections", 
            "text": "Sectional data can be extracted from meshes using the  Surface Slice  function. A plane rectangle is defined in terms of an origin and two direction vectors. Then, data on all mesh surfaces intersected by this rectangle can be shown as a curve plot.     Two different fields can be shown at the same time. The blue graphs always corresponds to the left y-axis which by default is independent of the red graph (right y-axis). However, when the  Rescale y-axis  checkbox is activated, then both axes are locked to the selected range. This option is useful for the comparison of different solution (flight conditions, frequencies,  ) stored in one and the same file.   In order to generate a section plot, a plane must be defined first. Often, a one of the coordinate planes is desired, for which one of the top three buttons can be used. Limits of the plane rectangle used for slicing the mesh are then computed from the bounding volume of all visible surfaces. Sometimes, these limits are not appropriate for the intended section, in which case the option  User-defined plane  can be selected. Here, the slicing rectangle is defined manually as its origin and two direction vectors.   Tip  A file containing very many subcases can hold hundreds of fields with the same name, \ne.g. pressure fields for many different flight conditions. To switch between these \nfields, move the UI focus to the field selection combo box (e.g.  Left Axis ). \nNow, whenever you click one of the field names in the left-hand side tree view holding\nthe subcases, the corresponding field will be selected for slicing. In this way, it is \neasy to navigate files containing very many solutions.    Curves shown in the plot window can also be exported. Export to PDF or image formats stores just the plot as an image, while the matlab and plain text options store the plotted data to a file. Note, however, that the data is generated by computing slices of surface elements. Hence, the visible data is not always a single continuous curve, but may consist of multiple segments.", 
            "title": "Plane sections"
        }, 
        {
            "location": "/display/index.html#streamlines", 
            "text": "Vector fields with at least three components can be displayed as continuous lines on any mesh surface where they are defined. The image below shows skin friction lines generated from the friction coefficient vector stored in a CFD solution file.", 
            "title": "Streamlines"
        }, 
        {
            "location": "/display/index.html#hedgehog-vector-plot", 
            "text": "Any three-component vector field can also be displayed as a set of simple lines originating at the node where they are defined. This can be useful to check the orientation and magnitude of nodal forces, for which an example is shown in the picture below.   This type of vector display is named  hedgehog plot  and can be configured using the options in the dialog shown here. For each nodal vector, a thin line (called  needle ) is drawn. The length of these lines can either be the same everywhere or adjusted to the local mesh size for the case where only the direction is of interest. Otherwise, the needle length may also be scaled by the magnitude of the corresponding vectors as was done in the screenshot above.", 
            "title": "Hedgehog Vector Plot"
        }, 
        {
            "location": "/display/index.html#mesh-deformation", 
            "text": "Vector fields can also represent deformation fields. When files are imported from structural analyses, such fields are automatically tagged as containing static deformation or eigenvector fields. The mesh deformation dialog allows to display either the deformed mesh by applying a linear scaling factor to the stored deformation field, or to animate the deformed shape. Static deformations are animated as ramping up from the undeformed state to the fully deflected configuration, while modeshapes are displayed as continuous  oscillations.", 
            "title": "Mesh Deformation"
        }, 
        {
            "location": "/display/index.html#flutter-modes", 
            "text": "Flutter modes are stored in  native format  (.zml) files as a special case of periodic trajectories. Since the format is meant to be rather general, flutter modes are therefore stored as short flight path segments of an elastic aircraft which happens remain at rest. For this reason, they can be displayed by the  Trajectory animation  option in the  Deformation  display dialog.    As mode shapes are usually normalized in some more or less useful manner, it is very common that the visualization of a deformation shape with default scaling (1.0) looks very exaggerated or does not appear to deform at all. Change the  Deformation scale  factor in order to alleviate this problem. As flutter modes are periodic, the animation feature with the * Loop  option active is recommended.", 
            "title": "Flutter Modes"
        }, 
        {
            "location": "/display/index.html#manual-mode-definition", 
            "text": "Even when a flutter problem is solved using an externally provided software, the solution can be displayed with scope. To do so, use the entry  Manually define flutter mode  in the  Loads  menu. In the dialog windows that opens, first name the mode; this is important whenever you want to define multiple modeshapes. Then enter the real and imaginary parts of the complex eigenvalue (in radian per second). Finally, define the modal participation coefficients. This can be done either by filling complex values in a table, or by pasting text from the output of another software as in the second screenshot below.     When using the text option, scope expects that the participation factors are given in the same sequence as the eigenmodes and as pairs of real and imaginary values. In the above example, the participation factor for the first eigenmode is hence (3.197e-5 - 5.621e-6 i), the second is (-9.603e-4 - 7.263e-5 i), and so on.", 
            "title": "Manual Mode Definition"
        }, 
        {
            "location": "/edit/index.html", 
            "text": "Editing Meshes\n\n\nCoordinate Transformation\n\n\nAll mesh data can be freely transformed into different coordinate systems using the \nTransform nodes\n entry in the \nEdit\n menu.\n\n\n\n\n\n\nAbsolute\n indicates that the transformation defined in this dialog is applied to the original, saved geometry, while the \nIncremental\n settings allows to chain transformations.\n\n\nA \nScaling\n factor can be defined in order to convert node coordinates between unit systems (scope itself is not aware of units). Note that any secondary data which may be contained in a mesh file, such as material data or boundary condition specification, are not affected by scaling node coordinates.\n\n\nA rigid-body \nRotation\n around a set \nPivot\n combined with a \nTranslation\n can also be defined here. As a convention, the rotation is performed in the order RX-RY-RZ, floolowed by the translation.\n\n\nFinally, it is possible to apply the transformation either to mesh nodes, displacement and eigenvector fields, or both. \n\n\n\n\n\n\nTip\n\n\nUse the scaling factor and select displacement/eigenmode fields only in order \nchange the scaling of an eigenvector field.\n\n\n\n\nMesh Size Reduction\n\n\nIn many cases, result files obtained from computational fluid dynamics are very large. Users concerned with flight mechanics, computation of loads, structural analysis or aeroelasticicty are frequently only interested in a very small subset of this data, namely the values of pressure and friction coefficients or local Mach numbers on the surface. Therefore, volume data can often be erased leading to far smaller files, faster load times and much faster workflow.\n\n\nFrom the \nComponents\n dialog, mesh sections which are not needed (e.g. all sections containig volume elements) can be erased. Note that this eliminates only the corresponding elements, but neither the nodes associated with these elements nor any field values.\n\n\nThe menu entry \nRemove unsused nodes\n in the \nEdit\n menu searches for nodes that are not referenced by any element and eliminates all of these nodes and all field values belonging to them.", 
            "title": "Mesh Editing"
        }, 
        {
            "location": "/edit/index.html#editing-meshes", 
            "text": "", 
            "title": "Editing Meshes"
        }, 
        {
            "location": "/edit/index.html#coordinate-transformation", 
            "text": "All mesh data can be freely transformed into different coordinate systems using the  Transform nodes  entry in the  Edit  menu.    Absolute  indicates that the transformation defined in this dialog is applied to the original, saved geometry, while the  Incremental  settings allows to chain transformations.  A  Scaling  factor can be defined in order to convert node coordinates between unit systems (scope itself is not aware of units). Note that any secondary data which may be contained in a mesh file, such as material data or boundary condition specification, are not affected by scaling node coordinates.  A rigid-body  Rotation  around a set  Pivot  combined with a  Translation  can also be defined here. As a convention, the rotation is performed in the order RX-RY-RZ, floolowed by the translation.  Finally, it is possible to apply the transformation either to mesh nodes, displacement and eigenvector fields, or both.     Tip  Use the scaling factor and select displacement/eigenmode fields only in order \nchange the scaling of an eigenvector field.", 
            "title": "Coordinate Transformation"
        }, 
        {
            "location": "/edit/index.html#mesh-size-reduction", 
            "text": "In many cases, result files obtained from computational fluid dynamics are very large. Users concerned with flight mechanics, computation of loads, structural analysis or aeroelasticicty are frequently only interested in a very small subset of this data, namely the values of pressure and friction coefficients or local Mach numbers on the surface. Therefore, volume data can often be erased leading to far smaller files, faster load times and much faster workflow.  From the  Components  dialog, mesh sections which are not needed (e.g. all sections containig volume elements) can be erased. Note that this eliminates only the corresponding elements, but neither the nodes associated with these elements nor any field values.  The menu entry  Remove unsused nodes  in the  Edit  menu searches for nodes that are not referenced by any element and eliminates all of these nodes and all field values belonging to them.", 
            "title": "Mesh Size Reduction"
        }, 
        {
            "location": "/mapping/index.html", 
            "text": "Mapping Mesh Deformation\n\n\nScope can be used to map surface deformations from a structural model to boundary surfaces of an aerodynamic mesh. Typically, this operation is a step needed to allow an aerodynamic solver to handle deforming bodies.\n\n\nOn the aerodynamic side, there are two fundamentally different approaches to handling surface deformation. The simpler method is to approximate the effect of surface displacement by defining a transpiration mass flow through the surface which, in the infinitesimal limit, has the same effect as the boundary displacement itself. This method is often very robust, but can only be used for small deformations. For instance, it is usually accurate for the modelling of elastic deformation, but may not be suitable to account for the effect of a landing flap deflection.\n\n\n\n\nNote\n\n\nTranspiration boundary conditions imply a linearization and should \n\ntherefore be insensitive to scaling - solving an aerodynamic problem \nperturbed by small transpiration term is intrinsically linear and should\ntherefore be a numerically \neasier\n task with better convergence\nproperties. \n\n\n\n\nThe second approach is to account for the full body deformation during an aerodynamic analysis, that is, by updating the aerodynamic mesh according to either some prescribed motion or a coupled analysis. This method often relies on surface deformation fields as a stepping stone to compute displacements of nodes in the fluid domain. Scope does not compute volume mesh deformations itself, but only surface mesh deformations.\n\n\nPrerequisites\n\n\nIn order to map mesh deformations correctly, both the structural and the aerodynamic mesh need to be defined in the same coordinate system. See the topic on \nMesh Transformation\n on how this can be accomplished.\n\n\n\n\nNote\n\n\nIt is very common that structural (mm) and aerodynamic models (m) are\ndefined in different units. It is suggested to load the structural model \ninto scope first and store the unit-converted file in the \n\nnative file format\n, which has the added \nadvantage of shorter load times than NASTRAN result files.\n\n\n\n\nWhen importing modal data from NASTRAN, it is recommended to use output in punch file format (.pch files). Often, .f06 files can also be imported, but the punch file format is more robust and will likely work better. To write out eigenvector shapes into a PUNCH format file, use the following commands in the case control section:\n\n\nDISPLACEMENT(PUNCH) = ALL\nECHO(PUNCH) = SORTED\n\n\n\n\nBasic Usage\n\n\nOnce the two meshes are available in compatible units and coordinate systems, the deformation mapping process can be performed as follows:\n\n\n\n\n\n\nLoad the aerodynamic mesh first. This is the mesh for which the surface motions will be computed.\n\n\nSelect the menu item \nMap structural deformation\n in the \nLoads\n menu.\n\n\nIn the dialog (shown below), select the structural mesh file. This can be a NASTRAN result file (punch file .pch preferred) or a native format file (.zml).\nThe structural mesh will \nnot\n be shown in the main window.\n\n\nDecide how many eigenmodes to map. This can be specified as a number of modes or a frequency range of interest.\n\n\nOptionally change the \nscaling of the deformation modes\n. \n\n\nFor structural models defined by shell and solid elements, use the shell projection method; for beam models, use interpolation by radial basis functions.\n\n\nSelect which aerodynamic boundaries will be treated as deforming (moving) and which are to be held fixed. Aerodynamic meshes which contain well-defined boundary conditions (CGNS, native format) will try to guess which aerodynamic boundaries are to be deformed. \n\n\nOptionally, adjust internal algorithm settings on the \nSettings\n page.\n\n\nStart the interpolation process by clicking \nInterpolate\n.\n\n\n\n\n\n\nTip\n\n\nWhen using very large meshes, try out the process with a few modes first to\ncheck whether results are acceptable. Processing of hundreds of modes on\nlarge meshes can take a long time. (Large meshes are thoise with many\nnodes on the aerodynamic surfaces.)\n\n\n\n\nOne the interpolation has been completed, the tree view on the left-hand side shows additional entries for the new deformation fields which are now present in the aerodynamic mesh currently in memory. You can now review the quality of the deformed meshes by using the \ndeformation display\n option.\n\n\nAcceptable mesh deformation fields can be exported to the aerodynamic solver either by saving the current mesh (which now contains new fields) in a format which is understood on its own, or storing the deformation fields as separate files. A common application is the computation of boundary displacement files (.bdis) for the EDGE flow solver - one file per mode. These .bdis files can be created directly from the \nExport\n button in the deformation mapping dialog \n\n\n\n\nTip\n\n\nSave the aerodynamic mesh including boundary deformations in the native file format (.zml) for later reference. It is always possible to extract the .bdis files from this format at a later time.\n\n\n\n\nAdvanced Usage\n\n\nAdvanced settings can be acessed on the \nSettings\n page to he right of the intially opened \nMapping\n tab. Because of the different algorithms, these settings differ between the mapping methods (projection or RBF). In any case, scope attempts to select reasonable default values which depend on the dimensions of the aerodynamic mesh.\n\n\nIn both cases, any settings adapted here can be stored to a file which is compatible with the \nsurfmap\n command-line utility. Alternatively, advanced settings can also be imported from such a file using the \nLoad Settings\n button on the second page.\n\n\nProjection\n\n\nThe shell projection method works by iterating over aerodynamic surface nodes and finding the nearest structural element. This method is strongly recommended for\napplications in aeroelasticity because it generates aerodynamic mesh deformations\nwhich are much closer to the structural model behavior.\n\n\n\n\nThe first field permits to define a set of elements property IDs (PIDs) which should be included in or excluded from the set of structural elements used for projection. This option is useful to excluding structural components which are not relevent for aerodynamic modeling. \n\n\nThe remaining options all concern the detection and handling of discontinuous deformations:\n\n\n\n\nGlobal smoothing iterations\n\n\nApply \nn\n Laplacian smoothing iterations on the entire aerodynamic surface. \n   This indiscriminately smoothes all deformation gradients is therefore\n   disabled by default.\n\n\nSelective smoothing\n\n\nEnable identification of aerodynamic elements which are located near a \n   possible discontinuity. Deformation fields will only be smoothed out over \n   these specific elements, which is much more selective than the global option\n   described above. Leaving this option as \nDirect Solution\n will not \n   perform iterative Laplacian smoothing, but rather solve a sparse linear\n   system to obtain the displacement of aerodynamic nodes near structural\n   discontinuities.\n\n\nSmoothed neighborhood ring\n\n\nThis specifies the size of the topological neighborhood to include in the \n   smoothing set. Switching this option off will apply the smoothing only to \n   aerodynamic nodes which are par of elements that stretch a discontinuity.\n   Selecting \n1\n will include all immediate neighbor nodes, \n2\n will also \n   include the neighbors of neighbors, and so on.\n\n\nSmoothing radius\n\n\nSince aerodynamic surface elements can be extremely small in some regions\n   such as sharp leading edges, it is also possible to specify the size of the \n   neighborhood of a discontinuity to be smoothed in terms of a distance. If \n   both this and the topological ring are active, then the boolean union of both\n   sets is included in the smoothing procedure.\n\n\nConcavity criterion\n\n\nRather often, discontinuities in structural displacements occur along seams\n   where two or more structural components are joined by means of some number of\n   fastening elements. Between fasteners or attachment fittings, the  structural\n   parts are free to move against (or even, in linear analyses, through) each \n   other. Aerodynamic fairings, flexible tape or putty that covers such seams is\n   usually not included in structural models. The concavity criterion is used to\n   to automatically identify aerodynamic elements which stradle such seams in\n   structural model (regions of concave surface curvature). Selecting a smaller \n   value will mark more aerodynamic elements. A value near 1.0 will almost \n   certainly include the entire aerodynamic mesh in this set.\n\n\n\n\nRadial Basis Functions\n\n\nThe RBF method works in a fundamentally different manner. Instead of using structural element information, a set of globally defined interpolation functions is defined. These value of these functions depends only on the radial distance of a node to all of the RBF center points. RBF have therefore a rather strong smoothing effect and can unfortunately generate grossly unrealistic displacements for aerodynamic nodes which are far from a structural nodes selected as RBF centers. \n\n\nRBF centers are always obtained from the structural model. In regions without structural nodes, there will be no RBF centers and accuracy may degrade considerably. \n\n\n\n\n\n\nRBF Type\n\n\nHere, the \ntype of radial basis function\n \n  can be selected. The inverse multiquadric RBF has earlier \n  been found to show satisfactory properties for use with beam models.\n\n\nRBF shape parameter\n\n\nSome types of RBF contain a free parameter (called epsilon or beta) which can\n  be set here. Sometimes, the degree of smoothing generated by a certain form of\n  RBF is influenced by this parameter.\n\n\nCenter merge threshold\n\n\nMost structural models contain duplicate nodes, but duplicate RBF centers serve\n  no purpose. The value selected here is used to fuse near-coincident structural \n  nodes in order to improve the conditioning of the RBF construction problem.\n\n\nRBF center selection\n\n\nThe RBF interpolation method is most useful for simple structural models with \n  some hundreds of beam elements. Such models are topologically dissimilar from \n  aerodynamic meshes and hence require some sort of extrapolation in any case. \n  However, this option permits to create RBF interpolations even from models \n  containing shell elements.\n\n\nNode subset\n\n\nBy default, each and every structural node which is part of of the selected \n  element types will be turned into a RBF center. This results in an RBF set which\n  exactly interpolates the strcutural deformation fields in the structural nodes\n  and has good accuracy near those nodes. However, constructing the RBF \n  representation requires the factorization of a large dense matrix, which becomes\n  rather time- and memory-consuming when exceeding about 4000 RBF centers. For \n  such cases, it is therefore better to select only a subset of nodes, the \n  size of which is defined here, and solve a least-squares problem instead. With\n  very large structural models containing millions of nodes, the number of RBF \n  nodes must be reduced to around 1000 or below.\n\n\n\n\nDeformation Scaling\n\n\nDepending on the aerodynamic solver or its preprocessing facilities, it may be necessary to select some small scaling factor in order to prevent mesh deformations becoming too large. Sometimes, large surface mesh deformations may in themselves be acceptable, but lead to problems such as ill-defined deformed volume elements at a later stage of the analysis.\n\n\nAn overall scaling factor for all modeshapes can be chosen in the dialog shown in the section on \nBasic Usage\n above. Select a scaling factor of 1.0 to obtain aerodynamic deformation fields which have the same amplitude as structural modes - this is usually a good choice for aerodynamic solvers which use the transpiration method.  \n\n\nCommand-Line Tool\n\n\nAll deformation mapping operations which are available in the graphical user interface from within acope can also be accessed through the command line utility \nsurfmap\n. In this case, the algorithm parameters are set by means of a plain text configuration file. A simple example is shown here:\n\n\n#  The case name is optional. If given, output files will be named with the case\n#  name as prefix.  \nCase = config-3c\n\n#  Mandatory file names\nStructuralMesh = plate.zml\nAeroMesh = afine.zml\n\n#  Select interpolation method, options are RBF, a radial basis function \n#  interpolation or Projection, meaning projection on shell elements \nMethod = Projection\nGalerkinAveraging = true\nOutputFormat = zml\n\n#  A list of names of moving mesh boundaries.\nMovingBoundaries = Fuselage, Canopy, MainWing, Stabilizer, Fin\n\n#  A list of sliding boundaries.\nSlidingBoundaries = XZSymmetryPlane\n\n#  Eigenmode selection.\nMaxFrequency = 85.0\nMaxModeCount = 200\n\n#  Let surfmap determine scaling factors\nAutomaticScaling = true\n\n#  Algorithm options for projection method\nExcludePID = 37 38 39 42 77 78 79 87 88 89 90 12 4 14 91\nWriteProjectionSurface = false\nPostSmoothing = -1\nSmoothingRadius = 0.01\nSmoothingRing = 1\n\n\n\n\nIn the following sections, all available configuration parameters for surfmap are listed with a short explanation. \n\n\nCommon options\n\n\n\n\nCase\n\n\nThe case name is optional. If given, output files will be named with the case\n   name as prefix. Without a case name, the default output file name is \nmapped\n\n   plus a corresponding suffix.\n\n\nMethod\n\n\nSelect interpolation method, options are \nRBF\n, a radial basis function \n   interpolation, or \nProjection\n, meaning projection on shell elements.\n   Setting this entry to \nApplyH\n loads a previously generated H-matrix from \n   a file and re-applies that matrix to the meshes a specified below. Naturally,\n   the file containing the matrix must be specified with \nHMapFile\n described \n   below.\n\n\nOutputFormat\n\n\nOptionally, select format for the output. zml means that one native format\n   file is written for visualization in scope; bdis means that one surface\n   displacement file is written for each mode, for use with the EDGE \n   aeroelastic toolchain. Multiple formats can be given.\n\n\nStructuralMesh\n\n\nFile containing the structural mesh and modal displacement data. This can \n   be a zml file written by (e.g.) scope or a NASTRAN punch data file for a modal \n   solution (SOL 103).\n\n\nAeroMesh :  File containing the aerodynamic mesh.\n\n\nThis can be either a zml file written by scope or sumo, or a bmesh file for \n   use with EDGE. If a bmesh file is given, then bdis output is \n   enabled automatically.\n\n\nMovingBoundaries:  A list of names of moving mesh boundaries.\n\n\nThe boundaries named below are treated as lying on surfaces which should move\n   in accordance to structural displacements. Nodes on these boundaries will \n   be displaced. If this list is not provided, then all boundaries marked with \n   wall boundary conditions are selected automatically. Since bmesh files do not\n   contain boundary condition specifications, this entry is required for bmesh\n   files.\n\n\nSlidingBoundaries: A list of sliding boundaries.\n\n\nNodes on these boundaries are restricted to move in the plane defined by the \n   first element of each boundary. Hence, listing a sliding boundary is only \n   useful for boundaries which are entirely plane, making it useful only for\n   symmetry planes.\n\n\nMaxModeCount, MinFrequency, MaxFrequency\n\n\nIf the displacement mapping is to be performed for a subset of modes only,\n   this subset can be defined by specifying a frequency interval and a maximum\n   number of eigenmodes to use. If not given, then all eigenmodes present in \n   the structural input will be processed.\n\n\nAutomaticScaling\n\n\nWhen switched on, surfmap attempts to determine displacement scaling factors\n   so that the deformed aerodynamic surface mesh does not contain any degenerate\n   (badly rotated, inverted) triangles. Due to the algorithm used in this test,\n   only triangular aerodynamic surface elements are considered. Note that the\n   factors found in this way are not a guarantee that a volume mesh deformation\n   procedure will successfully complete.\n   Default is \nfalse\n.\n\n\n\n\nOptions for the projection method\n\n\n\n\nIncludePID:  List of shell PIDs to include.\n\n\nElements with these shell property IDs will be used as the set of elements on\n   which to project aerodynamic nodes for interpolation. Often, it is more useful\n   to specify the opposite, namely PIDs to exclude from the projection set. If \n   this option is not given, then projection on all shell elements in the \n   structural model is permitted. \n\n\nExcludePID\n\n\nElements with any of these property IDs will \nnot\n be used to define the \n   projection surface. This list can be employed to address problems occurring\n   when aerodynamic nodes happen to be projected on shell elements which are \n   part of some internal structure or reinforcement. The use of the\n   options ExcludePID and IncludePID is mutually exclusive.\n\n\nWriteProjectionSurface : Write the projection surface to file.\n\n\nSetting this to true will generate a file (for use in scope) which contains\n   only the structural shell elements used to define the projection surface. It \n   is a good idea to enable this option when the PID-based selection described \n   above is active, so that the list of active shell elements can be verified.\n\n\nHMapFile : Store/load mapping from file\n\n\nWhen \nMethod\n is set to \nApplyH\n, then the H-matrix to be used is loaded\n   from the file named here. If \nMethod\n is \nProjection\n, then the H-matrix\n   is computed and stored in this file. \n\n\n\n\nHandling of discontinuities.\n\n\n\n\nPostSmoothing\n\n\nSetting PostSmoothing to \nzero\n disables any postprocessing of interpolated \n   deformation, which is useful when surface deformations for transpiration \n   boundary conditions are needed. \n   A positive number for PostSmoothing enables approximate smoothing by means of\n   a number of discrete Jacobi iterations, where the value of PostSmoothing \n   (say 4 to 30) indicates the number of iterations to perform. Note that this\n   method is most appropriate if the size of aerodynamic elements in the vicinity\n   of discontinuities is approximately equal.\n   Set PostSmoothing to -1 to replace the iterative smoothing method with the \n   exact solution of a diffusion problem, where the deformations for all elements\n   recognised as being near a discontinuity are determined from interpolated \n   deformations in the region around those elements. This approach works well \n   even with significant size differences between aerodynamic elements in the \n   discontinuous displacement region.   \n\n\nSmoothingRadius : Catch radius around discontinuities.\n\n\nFirst, all aerodynamic elements which stretch across structural component\n   boundaries (where structural deformations can be non-smooth) are found. It is,\n   however, possible that some of these elements, e.g. at the leading edge, are \n   very small. Smoothing deformations over just these few small elements may \n   therefore still generate undesirable mesh irregularities. Setting the \n   smoothing radius to non-zero values includes all aerodynamic nodes which are\n   within this distance from any of the already identified candidate nodes in the\n   set of nodes to which the smoothing defined by PostSmoothing is applied.\n\n\nSmoothingRing : Topological ring around discontinuities.\n\n\nAn alternative way of including more aerodynamic elements in the smoothed set\n   is to specify a topological neighbourhood. Setting this option to 0 disables,\n   1 means all neighbour elements, 2 neighbours-of-neighbours and so on.\n\n\n\n\nOptions used for RBF interpolation only\n\n\n\n\nUsePoints, UseBeams, UseShells : Structural node selection options.\n\n\nThese three options allow to specify which structural nodes are to be \n   used to define center points for the radial basis functions. Structural \n   displacements will be interpolated exactly at these center points. The \n   computational work required to define the RBF basis increases very quickly \n   with the number of centers, so that more than a few thousand centers should\n   usually be avoided. In particular, the RBF method is not suitable for use\n   with detailed shell models with many nodes. The default is to collect only \n   nodes on beam elements.\n\n\nMergeThreshold : Center merge tolerance.\n\n\nThe RBF method can fail for models which contain multiple nodes at the same\n   geometric location, which is common in structural models with mechanisms. This\n   option can be used to merge closely spaced RBF centers so as to improve the\n   robustness of the method. The default value is 1e-12.", 
            "title": "Deformation Mapping"
        }, 
        {
            "location": "/mapping/index.html#mapping-mesh-deformation", 
            "text": "Scope can be used to map surface deformations from a structural model to boundary surfaces of an aerodynamic mesh. Typically, this operation is a step needed to allow an aerodynamic solver to handle deforming bodies.  On the aerodynamic side, there are two fundamentally different approaches to handling surface deformation. The simpler method is to approximate the effect of surface displacement by defining a transpiration mass flow through the surface which, in the infinitesimal limit, has the same effect as the boundary displacement itself. This method is often very robust, but can only be used for small deformations. For instance, it is usually accurate for the modelling of elastic deformation, but may not be suitable to account for the effect of a landing flap deflection.   Note  Transpiration boundary conditions imply a linearization and should  \ntherefore be insensitive to scaling - solving an aerodynamic problem \nperturbed by small transpiration term is intrinsically linear and should\ntherefore be a numerically  easier  task with better convergence\nproperties.    The second approach is to account for the full body deformation during an aerodynamic analysis, that is, by updating the aerodynamic mesh according to either some prescribed motion or a coupled analysis. This method often relies on surface deformation fields as a stepping stone to compute displacements of nodes in the fluid domain. Scope does not compute volume mesh deformations itself, but only surface mesh deformations.", 
            "title": "Mapping Mesh Deformation"
        }, 
        {
            "location": "/mapping/index.html#prerequisites", 
            "text": "In order to map mesh deformations correctly, both the structural and the aerodynamic mesh need to be defined in the same coordinate system. See the topic on  Mesh Transformation  on how this can be accomplished.   Note  It is very common that structural (mm) and aerodynamic models (m) are\ndefined in different units. It is suggested to load the structural model \ninto scope first and store the unit-converted file in the  native file format , which has the added \nadvantage of shorter load times than NASTRAN result files.   When importing modal data from NASTRAN, it is recommended to use output in punch file format (.pch files). Often, .f06 files can also be imported, but the punch file format is more robust and will likely work better. To write out eigenvector shapes into a PUNCH format file, use the following commands in the case control section:  DISPLACEMENT(PUNCH) = ALL\nECHO(PUNCH) = SORTED", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/mapping/index.html#basic-usage", 
            "text": "Once the two meshes are available in compatible units and coordinate systems, the deformation mapping process can be performed as follows:    Load the aerodynamic mesh first. This is the mesh for which the surface motions will be computed.  Select the menu item  Map structural deformation  in the  Loads  menu.  In the dialog (shown below), select the structural mesh file. This can be a NASTRAN result file (punch file .pch preferred) or a native format file (.zml).\nThe structural mesh will  not  be shown in the main window.  Decide how many eigenmodes to map. This can be specified as a number of modes or a frequency range of interest.  Optionally change the  scaling of the deformation modes .   For structural models defined by shell and solid elements, use the shell projection method; for beam models, use interpolation by radial basis functions.  Select which aerodynamic boundaries will be treated as deforming (moving) and which are to be held fixed. Aerodynamic meshes which contain well-defined boundary conditions (CGNS, native format) will try to guess which aerodynamic boundaries are to be deformed.   Optionally, adjust internal algorithm settings on the  Settings  page.  Start the interpolation process by clicking  Interpolate .    Tip  When using very large meshes, try out the process with a few modes first to\ncheck whether results are acceptable. Processing of hundreds of modes on\nlarge meshes can take a long time. (Large meshes are thoise with many\nnodes on the aerodynamic surfaces.)   One the interpolation has been completed, the tree view on the left-hand side shows additional entries for the new deformation fields which are now present in the aerodynamic mesh currently in memory. You can now review the quality of the deformed meshes by using the  deformation display  option.  Acceptable mesh deformation fields can be exported to the aerodynamic solver either by saving the current mesh (which now contains new fields) in a format which is understood on its own, or storing the deformation fields as separate files. A common application is the computation of boundary displacement files (.bdis) for the EDGE flow solver - one file per mode. These .bdis files can be created directly from the  Export  button in the deformation mapping dialog    Tip  Save the aerodynamic mesh including boundary deformations in the native file format (.zml) for later reference. It is always possible to extract the .bdis files from this format at a later time.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/mapping/index.html#advanced-usage", 
            "text": "Advanced settings can be acessed on the  Settings  page to he right of the intially opened  Mapping  tab. Because of the different algorithms, these settings differ between the mapping methods (projection or RBF). In any case, scope attempts to select reasonable default values which depend on the dimensions of the aerodynamic mesh.  In both cases, any settings adapted here can be stored to a file which is compatible with the  surfmap  command-line utility. Alternatively, advanced settings can also be imported from such a file using the  Load Settings  button on the second page.", 
            "title": "Advanced Usage"
        }, 
        {
            "location": "/mapping/index.html#projection", 
            "text": "The shell projection method works by iterating over aerodynamic surface nodes and finding the nearest structural element. This method is strongly recommended for\napplications in aeroelasticity because it generates aerodynamic mesh deformations\nwhich are much closer to the structural model behavior.   The first field permits to define a set of elements property IDs (PIDs) which should be included in or excluded from the set of structural elements used for projection. This option is useful to excluding structural components which are not relevent for aerodynamic modeling.   The remaining options all concern the detection and handling of discontinuous deformations:   Global smoothing iterations  Apply  n  Laplacian smoothing iterations on the entire aerodynamic surface. \n   This indiscriminately smoothes all deformation gradients is therefore\n   disabled by default.  Selective smoothing  Enable identification of aerodynamic elements which are located near a \n   possible discontinuity. Deformation fields will only be smoothed out over \n   these specific elements, which is much more selective than the global option\n   described above. Leaving this option as  Direct Solution  will not \n   perform iterative Laplacian smoothing, but rather solve a sparse linear\n   system to obtain the displacement of aerodynamic nodes near structural\n   discontinuities.  Smoothed neighborhood ring  This specifies the size of the topological neighborhood to include in the \n   smoothing set. Switching this option off will apply the smoothing only to \n   aerodynamic nodes which are par of elements that stretch a discontinuity.\n   Selecting  1  will include all immediate neighbor nodes,  2  will also \n   include the neighbors of neighbors, and so on.  Smoothing radius  Since aerodynamic surface elements can be extremely small in some regions\n   such as sharp leading edges, it is also possible to specify the size of the \n   neighborhood of a discontinuity to be smoothed in terms of a distance. If \n   both this and the topological ring are active, then the boolean union of both\n   sets is included in the smoothing procedure.  Concavity criterion  Rather often, discontinuities in structural displacements occur along seams\n   where two or more structural components are joined by means of some number of\n   fastening elements. Between fasteners or attachment fittings, the  structural\n   parts are free to move against (or even, in linear analyses, through) each \n   other. Aerodynamic fairings, flexible tape or putty that covers such seams is\n   usually not included in structural models. The concavity criterion is used to\n   to automatically identify aerodynamic elements which stradle such seams in\n   structural model (regions of concave surface curvature). Selecting a smaller \n   value will mark more aerodynamic elements. A value near 1.0 will almost \n   certainly include the entire aerodynamic mesh in this set.", 
            "title": "Projection"
        }, 
        {
            "location": "/mapping/index.html#radial-basis-functions", 
            "text": "The RBF method works in a fundamentally different manner. Instead of using structural element information, a set of globally defined interpolation functions is defined. These value of these functions depends only on the radial distance of a node to all of the RBF center points. RBF have therefore a rather strong smoothing effect and can unfortunately generate grossly unrealistic displacements for aerodynamic nodes which are far from a structural nodes selected as RBF centers.   RBF centers are always obtained from the structural model. In regions without structural nodes, there will be no RBF centers and accuracy may degrade considerably.     RBF Type  Here, the  type of radial basis function  \n  can be selected. The inverse multiquadric RBF has earlier \n  been found to show satisfactory properties for use with beam models.  RBF shape parameter  Some types of RBF contain a free parameter (called epsilon or beta) which can\n  be set here. Sometimes, the degree of smoothing generated by a certain form of\n  RBF is influenced by this parameter.  Center merge threshold  Most structural models contain duplicate nodes, but duplicate RBF centers serve\n  no purpose. The value selected here is used to fuse near-coincident structural \n  nodes in order to improve the conditioning of the RBF construction problem.  RBF center selection  The RBF interpolation method is most useful for simple structural models with \n  some hundreds of beam elements. Such models are topologically dissimilar from \n  aerodynamic meshes and hence require some sort of extrapolation in any case. \n  However, this option permits to create RBF interpolations even from models \n  containing shell elements.  Node subset  By default, each and every structural node which is part of of the selected \n  element types will be turned into a RBF center. This results in an RBF set which\n  exactly interpolates the strcutural deformation fields in the structural nodes\n  and has good accuracy near those nodes. However, constructing the RBF \n  representation requires the factorization of a large dense matrix, which becomes\n  rather time- and memory-consuming when exceeding about 4000 RBF centers. For \n  such cases, it is therefore better to select only a subset of nodes, the \n  size of which is defined here, and solve a least-squares problem instead. With\n  very large structural models containing millions of nodes, the number of RBF \n  nodes must be reduced to around 1000 or below.", 
            "title": "Radial Basis Functions"
        }, 
        {
            "location": "/mapping/index.html#deformation-scaling", 
            "text": "Depending on the aerodynamic solver or its preprocessing facilities, it may be necessary to select some small scaling factor in order to prevent mesh deformations becoming too large. Sometimes, large surface mesh deformations may in themselves be acceptable, but lead to problems such as ill-defined deformed volume elements at a later stage of the analysis.  An overall scaling factor for all modeshapes can be chosen in the dialog shown in the section on  Basic Usage  above. Select a scaling factor of 1.0 to obtain aerodynamic deformation fields which have the same amplitude as structural modes - this is usually a good choice for aerodynamic solvers which use the transpiration method.", 
            "title": "Deformation Scaling"
        }, 
        {
            "location": "/mapping/index.html#command-line-tool", 
            "text": "All deformation mapping operations which are available in the graphical user interface from within acope can also be accessed through the command line utility  surfmap . In this case, the algorithm parameters are set by means of a plain text configuration file. A simple example is shown here:  #  The case name is optional. If given, output files will be named with the case\n#  name as prefix.  \nCase = config-3c\n\n#  Mandatory file names\nStructuralMesh = plate.zml\nAeroMesh = afine.zml\n\n#  Select interpolation method, options are RBF, a radial basis function \n#  interpolation or Projection, meaning projection on shell elements \nMethod = Projection\nGalerkinAveraging = true\nOutputFormat = zml\n\n#  A list of names of moving mesh boundaries.\nMovingBoundaries = Fuselage, Canopy, MainWing, Stabilizer, Fin\n\n#  A list of sliding boundaries.\nSlidingBoundaries = XZSymmetryPlane\n\n#  Eigenmode selection.\nMaxFrequency = 85.0\nMaxModeCount = 200\n\n#  Let surfmap determine scaling factors\nAutomaticScaling = true\n\n#  Algorithm options for projection method\nExcludePID = 37 38 39 42 77 78 79 87 88 89 90 12 4 14 91\nWriteProjectionSurface = false\nPostSmoothing = -1\nSmoothingRadius = 0.01\nSmoothingRing = 1  In the following sections, all available configuration parameters for surfmap are listed with a short explanation.", 
            "title": "Command-Line Tool"
        }, 
        {
            "location": "/mapping/index.html#common-options", 
            "text": "Case  The case name is optional. If given, output files will be named with the case\n   name as prefix. Without a case name, the default output file name is  mapped \n   plus a corresponding suffix.  Method  Select interpolation method, options are  RBF , a radial basis function \n   interpolation, or  Projection , meaning projection on shell elements.\n   Setting this entry to  ApplyH  loads a previously generated H-matrix from \n   a file and re-applies that matrix to the meshes a specified below. Naturally,\n   the file containing the matrix must be specified with  HMapFile  described \n   below.  OutputFormat  Optionally, select format for the output. zml means that one native format\n   file is written for visualization in scope; bdis means that one surface\n   displacement file is written for each mode, for use with the EDGE \n   aeroelastic toolchain. Multiple formats can be given.  StructuralMesh  File containing the structural mesh and modal displacement data. This can \n   be a zml file written by (e.g.) scope or a NASTRAN punch data file for a modal \n   solution (SOL 103).  AeroMesh :  File containing the aerodynamic mesh.  This can be either a zml file written by scope or sumo, or a bmesh file for \n   use with EDGE. If a bmesh file is given, then bdis output is \n   enabled automatically.  MovingBoundaries:  A list of names of moving mesh boundaries.  The boundaries named below are treated as lying on surfaces which should move\n   in accordance to structural displacements. Nodes on these boundaries will \n   be displaced. If this list is not provided, then all boundaries marked with \n   wall boundary conditions are selected automatically. Since bmesh files do not\n   contain boundary condition specifications, this entry is required for bmesh\n   files.  SlidingBoundaries: A list of sliding boundaries.  Nodes on these boundaries are restricted to move in the plane defined by the \n   first element of each boundary. Hence, listing a sliding boundary is only \n   useful for boundaries which are entirely plane, making it useful only for\n   symmetry planes.  MaxModeCount, MinFrequency, MaxFrequency  If the displacement mapping is to be performed for a subset of modes only,\n   this subset can be defined by specifying a frequency interval and a maximum\n   number of eigenmodes to use. If not given, then all eigenmodes present in \n   the structural input will be processed.  AutomaticScaling  When switched on, surfmap attempts to determine displacement scaling factors\n   so that the deformed aerodynamic surface mesh does not contain any degenerate\n   (badly rotated, inverted) triangles. Due to the algorithm used in this test,\n   only triangular aerodynamic surface elements are considered. Note that the\n   factors found in this way are not a guarantee that a volume mesh deformation\n   procedure will successfully complete.\n   Default is  false .", 
            "title": "Common options"
        }, 
        {
            "location": "/mapping/index.html#options-for-the-projection-method", 
            "text": "IncludePID:  List of shell PIDs to include.  Elements with these shell property IDs will be used as the set of elements on\n   which to project aerodynamic nodes for interpolation. Often, it is more useful\n   to specify the opposite, namely PIDs to exclude from the projection set. If \n   this option is not given, then projection on all shell elements in the \n   structural model is permitted.   ExcludePID  Elements with any of these property IDs will  not  be used to define the \n   projection surface. This list can be employed to address problems occurring\n   when aerodynamic nodes happen to be projected on shell elements which are \n   part of some internal structure or reinforcement. The use of the\n   options ExcludePID and IncludePID is mutually exclusive.  WriteProjectionSurface : Write the projection surface to file.  Setting this to true will generate a file (for use in scope) which contains\n   only the structural shell elements used to define the projection surface. It \n   is a good idea to enable this option when the PID-based selection described \n   above is active, so that the list of active shell elements can be verified.  HMapFile : Store/load mapping from file  When  Method  is set to  ApplyH , then the H-matrix to be used is loaded\n   from the file named here. If  Method  is  Projection , then the H-matrix\n   is computed and stored in this file.", 
            "title": "Options for the projection method"
        }, 
        {
            "location": "/mapping/index.html#handling-of-discontinuities", 
            "text": "PostSmoothing  Setting PostSmoothing to  zero  disables any postprocessing of interpolated \n   deformation, which is useful when surface deformations for transpiration \n   boundary conditions are needed. \n   A positive number for PostSmoothing enables approximate smoothing by means of\n   a number of discrete Jacobi iterations, where the value of PostSmoothing \n   (say 4 to 30) indicates the number of iterations to perform. Note that this\n   method is most appropriate if the size of aerodynamic elements in the vicinity\n   of discontinuities is approximately equal.\n   Set PostSmoothing to -1 to replace the iterative smoothing method with the \n   exact solution of a diffusion problem, where the deformations for all elements\n   recognised as being near a discontinuity are determined from interpolated \n   deformations in the region around those elements. This approach works well \n   even with significant size differences between aerodynamic elements in the \n   discontinuous displacement region.     SmoothingRadius : Catch radius around discontinuities.  First, all aerodynamic elements which stretch across structural component\n   boundaries (where structural deformations can be non-smooth) are found. It is,\n   however, possible that some of these elements, e.g. at the leading edge, are \n   very small. Smoothing deformations over just these few small elements may \n   therefore still generate undesirable mesh irregularities. Setting the \n   smoothing radius to non-zero values includes all aerodynamic nodes which are\n   within this distance from any of the already identified candidate nodes in the\n   set of nodes to which the smoothing defined by PostSmoothing is applied.  SmoothingRing : Topological ring around discontinuities.  An alternative way of including more aerodynamic elements in the smoothed set\n   is to specify a topological neighbourhood. Setting this option to 0 disables,\n   1 means all neighbour elements, 2 neighbours-of-neighbours and so on.", 
            "title": "Handling of discontinuities."
        }, 
        {
            "location": "/mapping/index.html#options-used-for-rbf-interpolation-only", 
            "text": "UsePoints, UseBeams, UseShells : Structural node selection options.  These three options allow to specify which structural nodes are to be \n   used to define center points for the radial basis functions. Structural \n   displacements will be interpolated exactly at these center points. The \n   computational work required to define the RBF basis increases very quickly \n   with the number of centers, so that more than a few thousand centers should\n   usually be avoided. In particular, the RBF method is not suitable for use\n   with detailed shell models with many nodes. The default is to collect only \n   nodes on beam elements.  MergeThreshold : Center merge tolerance.  The RBF method can fail for models which contain multiple nodes at the same\n   geometric location, which is common in structural models with mechanisms. This\n   option can be used to merge closely spaced RBF centers so as to improve the\n   robustness of the method. The default value is 1e-12.", 
            "title": "Options used for RBF interpolation only"
        }, 
        {
            "location": "/loads/index.html", 
            "text": "Generating Flight Loads\n\n\nScope can be used to generate structural loads from aerodynamic or aeroelastic solutions. In the simplest case, this process entails just \nintegration of pressures\n over mesh sections. A more useful feature is \n\nmapping of pressure\n data to a a structural mesh.\n\n\n\n\nNote\n\n\nThe documentation presently only covers simple applications for steady \nflight loads. More complex (unsteady) loads can be generated, but these options are not properly documented yet.\n\n\n\n\nForce Integration\n\n\nTo support simple, approximate or preliminary flight load analyses, the entry \nIntegrate pressure\n in the \nView\n menu allows to select an arbitrary scalar field (usually relative pressures or pressure coefficients) and perform an integration over the surface of each mesh section. This process yields total forces and moments acting on each of the mesh sections assuming reference pressure (the value against which the relative pressure field is offset) on the inside face of the section. \n\n\n\n\nSome CFD codes report absolute pressures, that is, they use vaccum as the reference pressure for the output. In that case, mesh sections which are open to one side - such as the \nCanopy\n section in the table above - will appear to sustain very large forces. Many times, integrating a pressure coefficient yields more useful results, since the reference pressure is non-zero.\n\n\n\n\nTip\n\n\nIn the general case, a file containing imported CFD results will include\nexternal boundaries such as far-field or wind-tunnel walls. The total of \nforces and moments reported in the last row of the table \nincludes\n any \nforces acting on these boundaries. The mesh used for the screenshot shown \nabove was reduced by \neliminating\n all\nfar-field mesh boundaries. \n\n\n\n\nPressure Mapping\n\n\nIn order to generate forces and moments acting on a structural model, scope will attempt to integrate a pressure field over each of the selected structural elements. To do so, a number of integration points are created inside each structural shell element. Pressure values for each integration point are determined by looking up the nearest aerodynamic surface element and linearly interpolating the pressure value at the integration point from the nodal values of the aerodynamic element. Surface-integrated pressure loads on the structural element are then expressed as a set of nodal forces and moments which are statically equivalent. These nodal forces are hence not necessarily strictly (Galerkin) consistent. Creating fully consistent loads would require detailed knowledge of the exact shape functions used for each element type by the targeted finite-element solvers.\n\n\nOften, the structural model will comprise both external shell elements on the wetted surface and internal elements which make up reinforcements, bulkheads and similar structures. Clearly, no pressure integration should be performed on such internal elements. Therefore, it is possible to \nexclude\n the property IDs (PIDs) of such elements from the pressure integration in the configuration dialog. For the case of a very complex internal structure, it is also possible to instead prescribe the set of PIDs to \ninclude\n.\n\n\n\n\nAdditional configuration options can be used to control which aerodynamic elements will be found when searching for the pressure values in integration points. This is sometimes necessary when the aerodynamic wetted surface does not exactly match the modelled structural surface, which can happen when, e.g. a structural model is designed to approximate the mean surface of a sandwich structure while the aerodynamic model naturally discretises the outer mold line.\n\n\n\n\nNormal deviation tolerance\n\n\nIn order to determine pressure from the correct aerodynamic element, only a moderate deviation between the surface normal vector of aerodynamic and structural elements is permitted.\n\n\nElement catch radius\n\n\nOnly aerodynamic elements within this distance from the structural integration point will be considered.\n\n\nStructural shell element normal points inward\n\n\nIn the case that the structural elements are ordered such that their normal vector direction points into the aircraft interior, this option should be enabled. Note that the structural model must consistently use one convention (all normals pointing either inward or outward) in order for the force integration to provide meaningful results. Elements belonging to excluded PIDs are not used and do not need to comply with that rule.\n\n\nLoad/store settings\n\n\nThe content of the entire dialog can be saved to and later reloaded from a plain configuration file that may also be edited manually. When moving such configuration files between computers, be aware that the settings even contain file names which may need to be adapted.\n\n\nStore load visualization mesh\n\n\nWhen this box is checked, scope will open a file dialog where you can enter the name of a file to write force visualisation results.\n\n\n\n\nVisualisation\n\n\nThe file written for visualisation contains the structural mesh and one or more nodal force vector fields. Use the \nhedgehog vector plot\n option to check orientation and relative force vector magnitudes.\n\n\n\n\nCoverage\n\n\nThe pressure integration approach implies that any components which are not represented as shell elements in the structural model will not carry any pressure loads either. When, for example, an externally carried sensor pod is only modelled as a concentrated inertia or using a beam simplification, scope will not compute any aerodynamic forces for the pod. If such a part is included in the aerodynamic model, it is recommended to determine an approximate force and moment pair for the entire body from the mesh section \nforce integration\n described above and explicitly add a point load to the structural model.\n\n\n\n\nNote\n\n\nIntegration of aerodynamic pressure over structural elements is meant to generate a\nload set which yields accurate local deformations, e.g. the change of chord-wise \nairfoil sections due to pressure loading. The approach is hence built upon the \nassumption that the aerodynamic and structural mesh are, in some sense, close to each \nother. Using aerodynamic and structural configurations with, for example, different \naileron deflections will very likely fail to generate useful load sets.\n\n\n\n\nAccuracy\n\n\nSometimes, the mesh density of a structural model is selected from purely structural considerations without regard to the possible variability of an external pressure field. In rare cases with very large structural elements in regions where the pressure changes very rapidly over short distances, this can lead to under-sampling, in which case the sum of structural forces differs substantially from integrated aerodynamic loads. \n\n\n\n\nTip\n\n\nWhen the structural model is suspected to contain regions with elements that \nmay be too coarse to resolve expected pressure loads, perform additional checks: Use\nthe \nforce integration\n feature to compute \nintegrated forces on the aerodynamic model and compare the sum with the\nforce total reported by the structural solver.\n\n\n\n\nForce Agglomeration for Beam Models\n\n\nStructural models made up of beam elements can naturally not be used in the pressure integration approach described above, since there is no geometric representation of the wetted surface. Selecting the \nAgglomerate loads\n option in the configuration dialog shown above will switch to a different algorithm.\n\n\nEvery aerodynamic surface element is assigned to the geometrically nearest beam element node. The forces and moments generated by the selected pressure field acting on every aerodynamic element are then applied to the corresponding beam node as if the aerodynamic element was attached to that node through a rigid connection.  \n\n\nIn contrast to the \nintegration approach\n, the agglomeration method will always automatically account for all aerodynamic loads. However, the location of load introduction will frequently not be accurate as aerodynamic pressure loads are in reality often not transferred to the \nnearest\n structural member. This inaccuracy can sometimes lead to large local deformations when weak secondary structures are erroneously subjected to accumulated pressure loads.\n\n\nFor very approximate structural models that do not match the aerodynamic surface well, and containing different elements topologies which need all be loaded, it is possible to abuse this algorithm in order to obtain a coarse load approximation. Note that only beam element nodes will be used as load introduction points in this case.\n\n\nHandling Multiple Cases\n\n\nIt is common that a large number of flight conditions need to be evaluated. Scope simplifies this process by allowing the efficient handling of multiple aerodynamic solutions and \nreduction\n of large CFD meshes to extract wetted surface data. Using a file containing multiple aerodynamic solutions, the pressure integration of force agglomeration method can be automatically applied to all load cases where the pressure field to use in the mapping has a certain name (such as \npressure\n or \nCoefPressure\n). \n\n\n\n\nTo define a sequence of dissimilar load cases from multiple aerodynamic solutions, two different approaches can be taken. First, it is possible to define a single flight condition or dynamic pressure when setting up the load mapping. This would then be combined with the selection of a field which contains the coefficient of pressure to be multiplied with the given dynamic pressure to yield differential pressures. Second, the dynamic pressure can be set to one and differential (or absolute) pressure fields selected to compute nodal forces. In this way, it is possible to handle many different flight conditions using just one file.\n\n\nLoad Output\n\n\nAt the time of writing, scope is limited to writing output files for NASTRAN. These are plain-text bulk data files which contain nodal force and moment values for each of the load sets defined in the procedure described above. the beginning and end of a single bulk data file with 64 load sets will look similar to this example:\n\n\nFORCE, 1, 3001, 0, 1., 0.023789, -0.11727, -0.09527\nMOMENT, 1, 3001, 0, 1., -3.10E-3, 0.00371, -0.49E-2\nFORCE, 1, 3002, 0, 1., 0.016238, -0.08964, -0.0995\nMOMENT, 1, 3002, 0, 1., -0.50E-2, 0.004862, -0.46E-2\n...\nFORCE, 64, 210255, 0, 1., 0.112499, -0.53E-3, -1.0393\nMOMENT, 64, 210255, 0, 1., 0.835E-4, -0.50E-2, 1.213E-6\nFORCE, 64, 210256, 0, 1., 0.022947, 0.002875, 0.81012\nMOMENT, 64, 210256, 0, 1., 0.388E-3, 0.003237, -2.47E-5\n\n\n\n\nLimitation\n\n\nSometimes, thin shell structures are modelled as a single element layer. The force integration procedure in scope is not designed for this kind of simplified model and will fail to produce reasonable structural loads. It is, however, still possible to use such models for the mapping of displacements from the structural to the aerodynamic surface. Since some methods use the transpose of the displacement mapping for the purpose of transferring loads, such methods may still be feasible. There is, however, no support for this approach in the user interface.", 
            "title": "Load Analysis"
        }, 
        {
            "location": "/loads/index.html#generating-flight-loads", 
            "text": "Scope can be used to generate structural loads from aerodynamic or aeroelastic solutions. In the simplest case, this process entails just  integration of pressures  over mesh sections. A more useful feature is  mapping of pressure  data to a a structural mesh.   Note  The documentation presently only covers simple applications for steady \nflight loads. More complex (unsteady) loads can be generated, but these options are not properly documented yet.", 
            "title": "Generating Flight Loads"
        }, 
        {
            "location": "/loads/index.html#force-integration", 
            "text": "To support simple, approximate or preliminary flight load analyses, the entry  Integrate pressure  in the  View  menu allows to select an arbitrary scalar field (usually relative pressures or pressure coefficients) and perform an integration over the surface of each mesh section. This process yields total forces and moments acting on each of the mesh sections assuming reference pressure (the value against which the relative pressure field is offset) on the inside face of the section.    Some CFD codes report absolute pressures, that is, they use vaccum as the reference pressure for the output. In that case, mesh sections which are open to one side - such as the  Canopy  section in the table above - will appear to sustain very large forces. Many times, integrating a pressure coefficient yields more useful results, since the reference pressure is non-zero.   Tip  In the general case, a file containing imported CFD results will include\nexternal boundaries such as far-field or wind-tunnel walls. The total of \nforces and moments reported in the last row of the table  includes  any \nforces acting on these boundaries. The mesh used for the screenshot shown \nabove was reduced by  eliminating  all\nfar-field mesh boundaries.", 
            "title": "Force Integration"
        }, 
        {
            "location": "/loads/index.html#pressure-mapping", 
            "text": "In order to generate forces and moments acting on a structural model, scope will attempt to integrate a pressure field over each of the selected structural elements. To do so, a number of integration points are created inside each structural shell element. Pressure values for each integration point are determined by looking up the nearest aerodynamic surface element and linearly interpolating the pressure value at the integration point from the nodal values of the aerodynamic element. Surface-integrated pressure loads on the structural element are then expressed as a set of nodal forces and moments which are statically equivalent. These nodal forces are hence not necessarily strictly (Galerkin) consistent. Creating fully consistent loads would require detailed knowledge of the exact shape functions used for each element type by the targeted finite-element solvers.  Often, the structural model will comprise both external shell elements on the wetted surface and internal elements which make up reinforcements, bulkheads and similar structures. Clearly, no pressure integration should be performed on such internal elements. Therefore, it is possible to  exclude  the property IDs (PIDs) of such elements from the pressure integration in the configuration dialog. For the case of a very complex internal structure, it is also possible to instead prescribe the set of PIDs to  include .   Additional configuration options can be used to control which aerodynamic elements will be found when searching for the pressure values in integration points. This is sometimes necessary when the aerodynamic wetted surface does not exactly match the modelled structural surface, which can happen when, e.g. a structural model is designed to approximate the mean surface of a sandwich structure while the aerodynamic model naturally discretises the outer mold line.   Normal deviation tolerance  In order to determine pressure from the correct aerodynamic element, only a moderate deviation between the surface normal vector of aerodynamic and structural elements is permitted.  Element catch radius  Only aerodynamic elements within this distance from the structural integration point will be considered.  Structural shell element normal points inward  In the case that the structural elements are ordered such that their normal vector direction points into the aircraft interior, this option should be enabled. Note that the structural model must consistently use one convention (all normals pointing either inward or outward) in order for the force integration to provide meaningful results. Elements belonging to excluded PIDs are not used and do not need to comply with that rule.  Load/store settings  The content of the entire dialog can be saved to and later reloaded from a plain configuration file that may also be edited manually. When moving such configuration files between computers, be aware that the settings even contain file names which may need to be adapted.  Store load visualization mesh  When this box is checked, scope will open a file dialog where you can enter the name of a file to write force visualisation results.", 
            "title": "Pressure Mapping"
        }, 
        {
            "location": "/loads/index.html#visualisation", 
            "text": "The file written for visualisation contains the structural mesh and one or more nodal force vector fields. Use the  hedgehog vector plot  option to check orientation and relative force vector magnitudes.", 
            "title": "Visualisation"
        }, 
        {
            "location": "/loads/index.html#coverage", 
            "text": "The pressure integration approach implies that any components which are not represented as shell elements in the structural model will not carry any pressure loads either. When, for example, an externally carried sensor pod is only modelled as a concentrated inertia or using a beam simplification, scope will not compute any aerodynamic forces for the pod. If such a part is included in the aerodynamic model, it is recommended to determine an approximate force and moment pair for the entire body from the mesh section  force integration  described above and explicitly add a point load to the structural model.   Note  Integration of aerodynamic pressure over structural elements is meant to generate a\nload set which yields accurate local deformations, e.g. the change of chord-wise \nairfoil sections due to pressure loading. The approach is hence built upon the \nassumption that the aerodynamic and structural mesh are, in some sense, close to each \nother. Using aerodynamic and structural configurations with, for example, different \naileron deflections will very likely fail to generate useful load sets.", 
            "title": "Coverage"
        }, 
        {
            "location": "/loads/index.html#accuracy", 
            "text": "Sometimes, the mesh density of a structural model is selected from purely structural considerations without regard to the possible variability of an external pressure field. In rare cases with very large structural elements in regions where the pressure changes very rapidly over short distances, this can lead to under-sampling, in which case the sum of structural forces differs substantially from integrated aerodynamic loads.    Tip  When the structural model is suspected to contain regions with elements that \nmay be too coarse to resolve expected pressure loads, perform additional checks: Use\nthe  force integration  feature to compute \nintegrated forces on the aerodynamic model and compare the sum with the\nforce total reported by the structural solver.", 
            "title": "Accuracy"
        }, 
        {
            "location": "/loads/index.html#force-agglomeration-for-beam-models", 
            "text": "Structural models made up of beam elements can naturally not be used in the pressure integration approach described above, since there is no geometric representation of the wetted surface. Selecting the  Agglomerate loads  option in the configuration dialog shown above will switch to a different algorithm.  Every aerodynamic surface element is assigned to the geometrically nearest beam element node. The forces and moments generated by the selected pressure field acting on every aerodynamic element are then applied to the corresponding beam node as if the aerodynamic element was attached to that node through a rigid connection.    In contrast to the  integration approach , the agglomeration method will always automatically account for all aerodynamic loads. However, the location of load introduction will frequently not be accurate as aerodynamic pressure loads are in reality often not transferred to the  nearest  structural member. This inaccuracy can sometimes lead to large local deformations when weak secondary structures are erroneously subjected to accumulated pressure loads.  For very approximate structural models that do not match the aerodynamic surface well, and containing different elements topologies which need all be loaded, it is possible to abuse this algorithm in order to obtain a coarse load approximation. Note that only beam element nodes will be used as load introduction points in this case.", 
            "title": "Force Agglomeration for Beam Models"
        }, 
        {
            "location": "/loads/index.html#handling-multiple-cases", 
            "text": "It is common that a large number of flight conditions need to be evaluated. Scope simplifies this process by allowing the efficient handling of multiple aerodynamic solutions and  reduction  of large CFD meshes to extract wetted surface data. Using a file containing multiple aerodynamic solutions, the pressure integration of force agglomeration method can be automatically applied to all load cases where the pressure field to use in the mapping has a certain name (such as  pressure  or  CoefPressure ).    To define a sequence of dissimilar load cases from multiple aerodynamic solutions, two different approaches can be taken. First, it is possible to define a single flight condition or dynamic pressure when setting up the load mapping. This would then be combined with the selection of a field which contains the coefficient of pressure to be multiplied with the given dynamic pressure to yield differential pressures. Second, the dynamic pressure can be set to one and differential (or absolute) pressure fields selected to compute nodal forces. In this way, it is possible to handle many different flight conditions using just one file.", 
            "title": "Handling Multiple Cases"
        }, 
        {
            "location": "/loads/index.html#load-output", 
            "text": "At the time of writing, scope is limited to writing output files for NASTRAN. These are plain-text bulk data files which contain nodal force and moment values for each of the load sets defined in the procedure described above. the beginning and end of a single bulk data file with 64 load sets will look similar to this example:  FORCE, 1, 3001, 0, 1., 0.023789, -0.11727, -0.09527\nMOMENT, 1, 3001, 0, 1., -3.10E-3, 0.00371, -0.49E-2\nFORCE, 1, 3002, 0, 1., 0.016238, -0.08964, -0.0995\nMOMENT, 1, 3002, 0, 1., -0.50E-2, 0.004862, -0.46E-2\n...\nFORCE, 64, 210255, 0, 1., 0.112499, -0.53E-3, -1.0393\nMOMENT, 64, 210255, 0, 1., 0.835E-4, -0.50E-2, 1.213E-6\nFORCE, 64, 210256, 0, 1., 0.022947, 0.002875, 0.81012\nMOMENT, 64, 210256, 0, 1., 0.388E-3, 0.003237, -2.47E-5", 
            "title": "Load Output"
        }, 
        {
            "location": "/loads/index.html#limitation", 
            "text": "Sometimes, thin shell structures are modelled as a single element layer. The force integration procedure in scope is not designed for this kind of simplified model and will fail to produce reasonable structural loads. It is, however, still possible to use such models for the mapping of displacements from the structural to the aerodynamic surface. Since some methods use the transpose of the displacement mapping for the purpose of transferring loads, such methods may still be feasible. There is, however, no support for this approach in the user interface.", 
            "title": "Limitation"
        }
    ]
}