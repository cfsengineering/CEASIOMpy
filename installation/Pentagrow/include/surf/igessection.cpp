
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 
#include <float.h>
#include <cstring>
#include <cstdio>
#include <iomanip>
#include <genua/xcept.h>
#include <genua/defines.h>
#include <genua/sysinfo.h>

#include "igesdirentry.h"
#include "igessection.h"

using namespace std;

// -------------------- Base class for IGES sections --------------------------

void IgesSection::changeType(SecType t)
{
  lines.clear();
  type = t;
  switch (type) {
    
    case IgesStart:
      sectionChar = 'S';
      break;
      
    case IgesGlobal:
      sectionChar = 'G';
      break;
      
    case IgesDirectory:
      sectionChar = 'D';
      break;
      
    case IgesParameter:
      sectionChar = 'P';
      break;
      
    case IgesTerminate:
      sectionChar = 'T';
      break;
      
    default:
      assert(!"Impossible section type.");
  }
}

void IgesSection::flush(int nuse)
{
  // put the contents of the current buffer into a line 
  string s(sbuf.str());
  const char *cpos = s.c_str();

  // write 72 byte chunks
  IgesLine line;
  int nc, nremain(s.size());
  while (nremain > nuse-1) {
    
    // find last parameter limit 
    const char *lpos = cpos + nuse - 1;
    while (lpos > cpos and *lpos != parDelim)
      --lpos;
    
    // which may fail 
    if (lpos == cpos)
      throw Error("String too long in IGES section: "+s);
    
    // add a line
    ++lpos;
    nc = lpos - cpos;
    nremain -= nc;
    memcpy(line.content(), cpos, nc);
    addLine( line );
    line.erase();
    cpos = lpos;
  }
  
  // remaining chunk is below nuse bytes 
  if (nremain > 0) {
    memcpy(line.content(), cpos, nremain);
    addLine(line);
  }

#if defined(_MSC_VER) &&  _MSC_VER >= 1600

  // Resetting streams did work earlier, but stops to work with MSVC 2010,
  // so we need to reassign to a new stream buffer. This, however,
  // is not possible on Unix, where stream assignment is private.
  sbuf = std::stringstream();

#else

  sbuf.str("");
  sbuf.seekp(0);
  sbuf.seekg(0);
  sbuf.clear();

#endif
}

void IgesSection::write(std::ostream & os) const
{
  if (lines.empty())
    return;
  
  // experimental: try to write the whole block at once 
  //size_t nbytes = 81*lines.size();
  //os.write((const char *) &lines[0], nbytes);

  const int n(lines.size());
  for (int i=0; i<n; ++i)
    lines[i].write(os);
}

uint IgesSection::parse(const IgesLineArray & file, uint first)
{
  lines.clear();
  const uint n = file.size();
  for (uint i=first; i<n; ++i) {
    if (file[i].section() == sectionChar)
      lines.push_back(file[i]);
    else
      return i;
  }
  return n;
}

// ----------------- start section --------------------------------------------

IgesStartSection::IgesStartSection() : IgesSection( IgesStart )
{ 
  static const string txt( "IGES 5.3 generated by libsurf, "
                            "http://www.larosterna.com" );
  setContent(txt);  
}

void IgesStartSection::setContent(const std::string & sin)
{
  string s(sin);
  const int len = s.size();
  for (int i=0; i<len; ++i) {
    if (s[i] == '\n' or s[i] == '\t')
      s[i] = ' ';
  }
  
  const char *pos = s.c_str();
  int cpos(0), nc;
  
  clear();
  IgesLine line;
  while (cpos < len) {
    
    // use 72 characters or up to the length of s  
    nc = min(72, len-cpos);
    
    // but do not end at non-blank 
    if (nc == 72) {
      const char *clast = &pos[cpos+nc-1];
      while (*clast != ' ' and nc > 0) {
        --nc;
        --clast;
      }
    }
    
    // handle blank lines 
    if (nc == 0)
      nc = min(72, len-cpos);
    
    if (nc > 0) {
      line.erase();
      line.copyContent(nc, &pos[cpos]);
      addLine(line);
      cpos += nc;
    } else {
      break;
    }
  }
}

// ----------------- global section -------------------------------------------

IgesGlobalSection::IgesGlobalSection() : IgesSection( IgesGlobal )
{
  parDelim = ',';
  recDelim = ';';
  
  sndrproduct = "(unspecified)";
  filename = "(unspecified)";
  natsys = "libsurf";
  ppversion = "libsurf v1.6";
  recvproduct = "(unspecified)";
  unitnames = "M";
  author = "(unspecified)";
  organiz = "(unspecified)";
  
  scale = 1.0;
  unitflag = 6;
  nlwgrad = 1;
  maxlinewidth = 1e-3;
  modeltol = gmepsilon;
  maxcoord = 0.0;
}

void IgesGlobalSection::assemble()
{
  addCharParameter( parDelim );  // 0
  addCharParameter( recDelim );  // 1
  
  addParameter( sndrproduct ); // 2
  addParameter( filename ); // 3
  addParameter( natsys ); // 4
  addParameter( ppversion ); // 5
  addIntParameter( 8*sizeof(int) );
  addIntParameter( FLT_MAX_10_EXP );
  addIntParameter( FLT_DIG );
  addIntParameter( DBL_MAX_10_EXP );
  addIntParameter( DBL_DIG );
  addParameter( recvproduct ); // 11
  addFloatParameter( scale ); // 12
  addIntParameter( unitflag ); // 13
  addParameter( unitnames ); // 14
  addIntParameter( nlwgrad ); // 15
  addFloatParameter( maxlinewidth ); // 16
  
  // assemble time parameter
  int year, month, day, hour, minu, sec;
  SysInfo::localTime(year, month, day, hour, minu, sec); 
//  char dt[21];
//  snprintf(dt, sizeof(dt), "%4d%02d%02d.%02d%02d%02d",
//           year, month, day, hour, minu, sec);
//  addParameter(dt);

  char dt[] = "00000000.000000";
  iges_insert(&dt[0], 8, year*10000 + month*100 + day);
  iges_insert(&dt[9], 6, hour*10000 + minu*100 + sec);
  addParameter(dt); // 17

  addFloatParameter( modeltol );
  addFloatParameter( maxcoord );
  addParameter( author );
  addParameter( organiz );
  addIntParameter( 11 );
  addIntParameter( 0 );
  addParameter( "NULL" );
  addParameter( "NULL" );
  endRecord();
  
  flush();
}

uint IgesGlobalSection::parse(const IgesLineArray & file, uint first)
{
  uint last = IgesSection::parse(file, first);

  // merge global section content into a single string
  string c;
  const int nlines = lines.size();
  for (int i=0; i<nlines; ++i) {
    const char *s = lines[i].content();
    c.insert(c.end(), s, s+72);
  }

  // first parameter is the parameter separator
  string pds, rds;
  fromHollerith(c, pds);
  parDelim = pds[0];
  StringArray words = split(c, pds);
  const int nw = words.size();

  fromHollerith(words[1], rds);
  recDelim = rds[0];

  if (nw > 2)
    fromHollerith(words[2], sndrproduct);
  if (nw > 3)
    fromHollerith(words[3], filename);
  if (nw > 4)
    fromHollerith(words[4], natsys);
  if (nw > 5)
    fromHollerith(words[5], ppversion);

  if (nw > 14)
    fromHollerith(words[14], unitnames);

  return last;
}

// ----------------- directory section -----------------------------------------

uint IgesDirectorySection::addEntry(const IgesDirEntry & e)
{
  if (not e.valid())
    return 0;

  IgesLine line;
  line.fixedNumber(0, e.etype);
  line.fixedNumber(1, e.pdata);
  line.fixedNumber(2, e.strct);
  line.fixedNumber(3, e.lpattern);
  line.fixedNumber(4, e.level);
  line.fixedNumber(5, e.view);
  line.fixedNumber(6, e.trafm);
  line.fixedNumber(7, e.lbdisp);
  line.statusCode( e.blank, e.subswitch, e.useflag, e.hierarchy );
  int dix = addLine(line);
  
  line.erase();
  line.fixedNumber(0, e.etype);
  line.fixedNumber(1, e.lweight);
  line.fixedNumber(2, e.color);
  line.fixedNumber(3, e.plines);
  line.fixedNumber(4, e.form);
  line.fixedNumber(8, e.esubscript);
  
  // set label 
  char *c = line.content();
  memcpy(&c[56], e.elabel, 8);
  
  addLine(line);

  return dix;
}

void IgesDirectorySection::fillEntry(uint iline, IgesDirEntry & e) const
{
  e.invalidate();
  if (iline+1 >= lines.size())
    return;

  const IgesLine & ln1(lines[iline]);
  const IgesLine & ln2(lines[iline+1]);

  e.etype = ln1.fixedInteger(0);
  e.pdata = ln1.fixedInteger(1);
  e.strct = ln1.fixedInteger(2);
  e.lpattern = ln1.fixedInteger(3);
  e.level = ln1.fixedInteger(4);
  e.view = ln1.fixedInteger(5);
  e.trafm = ln1.fixedInteger(6);
  e.lbdisp = ln1.fixedInteger(7);

  // TODO : Parse status codes

  e.etype = ln2.fixedInteger(0);
  e.lweight = ln2.fixedInteger(1);
  e.color = ln2.fixedInteger(2);
  e.plines = ln2.fixedInteger(3);
  e.form = ln2.fixedInteger(4);
  e.esubscript = ln2.fixedInteger(5);

  memcpy( e.elabel, ln2.content()+56, 8 );
}

bool IgesDirectorySection::changeEntry(uint idx, const IgesDirEntry &e)
{
  if (idx >= lines.size())
    return false;

  IgesLine & ln1(lines[idx]);
  IgesLine & ln2(lines[idx+1]);

  ln1.fixedNumber(0, e.etype);
  ln1.fixedNumber(1, e.pdata);
  ln1.fixedNumber(2, e.strct);
  ln1.fixedNumber(3, e.lpattern);
  ln1.fixedNumber(4, e.level);
  ln1.fixedNumber(5, e.view);
  ln1.fixedNumber(6, e.trafm);
  ln1.fixedNumber(7, e.lbdisp);
  ln1.statusCode( e.blank, e.subswitch, e.useflag, e.hierarchy );

  ln2.fixedNumber(0, e.etype);
  ln2.fixedNumber(1, e.lweight);
  ln2.fixedNumber(2, e.color);
  ln2.fixedNumber(3, e.plines);
  ln2.fixedNumber(4, e.form);
  ln2.fixedNumber(8, e.esubscript);

  return true;
}

