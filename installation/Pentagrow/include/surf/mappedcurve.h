/* Copyright (C) 2017 David Eller <david@larosterna.com>
 *
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */

#ifndef SURF_MAPPEDCURVE_H
#define SURF_MAPPEDCURVE_H

#include "abstractcurve.h"

/** Curve generated by linearly mapping the parameter space.
 *
 * This class reprents a curve C(offset + scale*t) based on an original curve
 * C. There are no other transformations applied, and the only member functions
 * affected are evaluation and deriviative computations. Any curve can be
 * reversed using this class by means of offset=1 and scale=-1.
 *
 * Note that objects of the type can not be directly exported to IGES; for that,
 * it is necessary to work with a lower-level implementation (such as
 * PolySplineCurve).
 *
 * \ingroup geometry
 * \sa AbstractCurve
 */
class MappedCurve : public AbstractCurve
{
public:

  /// empty default constructor
  MappedCurve(const std::string &s = "") : AbstractCurve(s) {}

  /// initialize directly
  explicit MappedCurve(const AbstractCurvePtr &acp, Real scale, Real offset=0.0);

  /// virtual destruction (can be base class)
  virtual ~MappedCurve() = default;

  /// assign base curve, scaling and offset coefficients
  virtual void init(const AbstractCurvePtr &acp, Real scale, Real offset=0.0);

  /// create a clone
  virtual MappedCurve *clone() const;

  /// evaluate spline curve
  virtual Vct3 eval(Real t) const;

  /// compute kth derivative
  virtual Vct3 derive(Real t, uint k) const;

  /// apply hard transformation
  virtual void apply();

  /// compute point and first derivative in one sweep
  virtual void tgline(Real t, Vct3 & c, Vct3 & dc) const;

  /// XML output
  virtual XmlElement toXml(bool share = false) const;

  /// XML input
  virtual void fromXml(const XmlElement & xe);

private:

  /// offset coefficient a in t = a + b*s
  Real m_offset = 0.0;

  /// scale coefficient b in in t = a + b*s
  Real m_scale = 1.0;

  /// base curve C(t) to be mapped
  AbstractCurvePtr m_base;
};

#endif // MAPPEDCURVE_H
