
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 
#ifndef SURF_NSTREADER_H
#define SURF_NSTREADER_H

#include "nstmesh.h"
#include "nstelements.h"
#include "nstrecord.h"
#include "nstcoordsys.h"
#include <genua/csrmatrix.h>
#include <genua/logger.h>

/** Reads nastran files.

  This is a helper class for internal use. It is used to read Nastran bulk
  or result files and extract nodes (grid points), elements, and modal analysis
  results. Not all element types will be read at the current state.

  When reading modal analysis results, the mesh must be contained in the same
  file in 'unsorted' form, i.e. you need to specify 'ECHO = UNSORT' in the
  nastran control section.

  The static function readOp4Ascii() can be used to import system matrices
  exported by NASTRAN to formatted (plain text) files in 'sparse bigmat' format.
  This type of output is generated by the following example NASTRAN input:
  \verbatim
$
$ Write g-set mass matrix to unit 12 and stiffness to unit 17
ASSIGN OUTPUT4='mgg.dat' status=unknown unit=12 form=formated
ASSIGN OUTPUT4='kgg.dat' status=unknown unit=17 form=formated
$
ID MATRIX EXPORT EXAMPLE
SOL 103
$ Option string //-1/-UNIT/2/TRUE/16 selects 'sparse double-precision bigmat'
COMPILE SEMODES SOUIN=MSCSOU NOLIST
ALTER 'STRAIN ENERGY'
OUTPUT4 MGG//-1/-12/2/TRUE/16 $ OUTPUT MGG TO UNIT=12 IN mgg.dat
OUTPUT4 KGG//-1/-17/2/TRUE/16 $ OUTPUT KGG TO UNIT=17 IN kgg.dat
ENDALTER
CEND
  \endverbatim

  \ingroup structures
  \sa NstMesh, NstRecord, NstStressField
  */
class NstReader : public Logger
{
public:

  /// initialize with mesh object in which data is stored
  NstReader(NstMesh & m) : msh(m), solSequence(0) {}

  /// mesh to which elements are attached
  const NstMesh & mesh() const {return msh;}

  /// mesh to which elements are attached
  NstMesh & mesh() {return msh;}

  /// access line with index i
  const std::string & line(uint i) const {
    assert(i < lines.size());
    return lines[i];
  }

  /// add grid point to mesh
  uint addNode(const Vct3 & p, uint gid, uint cid = 0, uint cd = 0) {
    uint inpos = msh.addVertex(p, gid);
    if (cid != 0)
      insert_once( cid2gid[cid], gid );
    if (cd != 0)
      insert_once( cid2def[cd], gid );
    return inpos;
  }

  /// add element to mesh
  void addElement(Element *ep) {
    msh.addElement(ep);
  }

  /// add coordinate system
  void addCoordSys(uint cid, const NstCoordSys & cs) {
    crdsys[cid] = cs;
  }

  /// interface for NstRecord: transform modeshape to global
  void transformMode(Matrix & z) const;

  /// read file
  void read(const std::string & fname);

  /// static utility to read NASTRAN system matrices
  static void readOp4Ascii(const std::string & fname, CsrMatrix<Real> & mtx);

private:

  /// read file line-by line
  void readLines(std::istream & in);

  /// filter lines and create records for topology elements
  void parseTopo();

  /// filter lines and read eigenmode shapes
  uint parseEvec();

  /// filter lines and read flutter modes in modal subspace
  uint parsePkz();

  /// filter lines and read displacements
  uint parseDisp();

  /// filter lines and read element stress data (limited subset supported)
  uint parseElmStress();

  /// transform points not in default coordinates
  void transformPoints();

private:

  typedef std::map<uint, Indices> Cid2GidsMap;
  typedef std::map<uint, NstCoordSys> CidMap;

  /// mesh where data is stored
  NstMesh & msh;

  /// buffer for lines stored
  StringArray lines;

  /// buffer for string records
  NstRecordArray toprec, evrec, pkzrec, dsprec, estressrec;

  /// remember coordinate system indices for grid points
  Cid2GidsMap cid2gid, cid2def;

  /// stores coordinate systems
  CidMap crdsys;

  /// solution type (SOL = ...), if identified, else zero
  int solSequence;

  /// true if file is .f06 output (determined from extension...)
  bool isf06Output;

  /// true if file is a punch file (.pch)
  bool ispunch;
};

#endif
