
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 
#ifndef SURF_STEPFILE_H
#define SURF_STEPFILE_H

#include "forward.h"
#include "stepentity.h"

/** STEP File.

  This class represents a file containing data in the STEP (ISO-10303-21)
  format. Currently, only a small subset of the entities in AP-203 is read from
  plain text (P21) format files, which are the only commonly encountered
  manifestation.

  Due to the horrific complexity of the standard, the C++ code to read and
  write all of the STEP entities is automatically generated by a python script
  which dumps the step_ap203 interfaces. In this way, all of STEP AP203
  is supported in the sense that the file contents are read into an in-memory
  C++ representation. However, not all entities which exist in AP203 have a
  correponding representation in libsurf.

  Apart from the entities defined by AP203, the standard also permits to
  create new, compound entities. These are not parsed by the current
  implementation.

  \todo How to handle compound entities?

  \ingroup interop
  \sa IgesFile, StepEntity
*/
class StepFile
{
public:

  typedef StepEntitySet::iterator iterator;
  typedef StepEntitySet::const_iterator const_iterator;

  /// create empty file
  StepFile() {}

  /// number of entities in file
  uint size() const {return entities.size();}

  /// allow iteration over entities
  iterator begin() {return entities.begin();}

  /// allow iteration over entities
  iterator end() {return entities.end();}

  /// allow iteration over entities
  const_iterator begin() const {return entities.begin();}

  /// allow iteration over entities
  const_iterator end() const {return entities.end();}

  /// access entity by entity id
  StepEntityPtr operator[] (StepID eid) const {
    StepEntitySet::const_iterator itr;
    StepEntity dmy(eid);
    itr = entities.find( StepEntityPtr(&dmy, null_deleter()) );
    if (itr != entities.end())
      return *itr;
    else
      return StepEntityPtr();
  }

  /// access as a certain entity type
  template <class Entity>
  bool as(StepID eid, const Entity **p) const {
    *p = dynamic_cast<const Entity*>( ((*this)[eid]).get() );
    return *p != 0;
  }

  /// determine whether a file could be a step file by looking at the header
  static bool isStepFile(const std::string & fname);

  /// read file from disk
  void read(const std::string & fname);

  /// write file to stream
  void write(std::ostream & os) const;

private:

  /// reading : process data section line
  void processLine(const std::string & line);

public:

  /// header: description, filename, author
  std::string hdDescription, hdFileName, hdAuthor;

  /// header: organisation, version, originating system, authorization
  std::string hdOrg, hdPpVersion, hdOrigSystem, hdAuth;

private:

  /// geometry and topology entities
  StepEntitySet entities;
};

#endif // STEPFILE_H
