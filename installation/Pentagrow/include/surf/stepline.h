
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 
#ifndef SURF_STEPFILELINE_H
#define SURF_STEPFILELINE_H

#include "steplistrep.h"
#include "step.h"

/** Single line in STEP file. */
class StepFileLine
{
public:

  /// initialize with pointer to first character
  explicit StepFileLine(const char *s) : cursor(s) {}

  /// increment cursor
  StepFileLine & operator++ () {++cursor; return *this;}

  /// current cursor location
  const char *current() const {return cursor;}

  /// place cursor at pos
  void move(const char *pos) {cursor = pos;}

  /// retrieve entity ID and place cursor on content after "=("
  uint entityId();

  /// skip one attribute
  bool skipAttr();

  /// locate entity type
  const char *entityType();

  /// copy entity type to buffer
  uint entityType(std::string & etype);

  /// check whether an optional attribute is present
  bool option() const {
    assert(cursor);
    return *cursor != '$';
  }

  /// parse a boolean value
  bool parseBool(bool & x);

  /// parse a single entity id
  bool parseId(StepID & x);

  /// parse single integer value
  bool parseInt(int & x);

  /// parse single float value
  bool parseFloat(double & x);

  /// parse a string attribute
  bool parseString(std::string & attr);

  /// parse an enum string
  bool parseEnum(const char **beg, const char **end);

  /// parse a select string
  bool parseSelect(const char **beg, const char **end);

  /// retrieve a list of IDs
  bool parseIdArray(StepIDArray & x);

  /// retrieve a list of IDs
  bool parseIntArray(StepIntArray & x);

  /// retrieve a list of real values
  bool parseFloatArray(StepRealArray & x);

  /// retrieve a list of strings
  bool parseStringArray(StepStringArray & x);

  /// retrieve a matrix of IDs
  bool parseIDMatrix(StepIDMatrix & x);

  /// retrieve a matrix of real values
  bool parseFloatMatrix(StepRealMatrix & x);

  /// retrieve a fixed-size list of real values
  template <int N>
  bool parseFloats(double val[]) {
    StepListRep list = nextList();
    bool ok = list.parseFloats<N>(val);
    cursor = list.end();
    return ok;
  }

  /// retrieve a fixed-size list of integer values
  template <int N>
  bool parseInts(int val[]) {
    StepListRep list = nextList();
    bool ok = list.parseInts<N>(val);
    cursor = list.end();
    return ok;
  }

  /// retrieve a fixed-size list of integer values
  template <int N>
  bool parseIds(StepID val[]) {
    StepListRep list = nextList();
    bool ok = list.parseIds<N>(val);
    cursor = list.end();
    return ok;
  }

  // overloads for autogenerated code

  bool readAttr(bool & x) { return parseBool(x); }
  bool readAttr(int & x) { return parseInt(x); }
  bool readAttr(StepID & x) { return parseId(x); }
  bool readAttr(double & x) { return parseFloat(x); }
  bool readAttr(std::string & x) { return parseString(x); }
  bool readAttr(StepIntArray & x) { return parseIntArray(x); }
  bool readAttr(StepIDArray & x) { return parseIdArray(x); }
  bool readAttr(StepStringArray & x) { return parseStringArray(x); }
  bool readAttr(StepRealArray & x) { return parseFloatArray(x); }
  bool readAttr(StepIDMatrix & x) { return parseIDMatrix(x); }
  bool readAttr(StepRealMatrix & x) { return parseFloatMatrix(x); }

  template <int N>
  bool readArrayAttr(int x[]) {return parseInts<N>(x);}

  template <int N>
  bool readArrayAttr(StepID x[]) {return parseIds<N>(x);}

  template <int N>
  bool readArrayAttr(double x[]) {return parseFloats<N>(x);}

  template <class EnumType>
  bool readEnumArray(std::vector<EnumType> & ev) {
    StepListRep list = nextList();
    if (not list.valid())
      return false;
    const int n = list.nelements();
    ev.resize(n);
    cursor = list.begin() + 1;
    bool ok = true;
    for (int i=0; i<n; ++i) {
      ok &= ev[i].read(*this);
    }
    cursor = list.end();
    return ok;
  }

  template <int N, class EnumType>
  bool readEnumArray(EnumType ev[]) {
    if (cursor == 0)
      return false;
    const char *s = strchr(cursor, '(');
    if (s == 0)
      return false;
    cursor = s+1;
    bool ok = true;
    for (int i=0; i<N; ++i) {
      ok &= ev[i].read(*this);
    }
    while (*cursor == ')' or *cursor == ',' or isspace(*cursor))
      ++cursor;
    return ok;
  }

  template <class EnumType>
  bool readSelectArray(std::vector<EnumType> & ev) {
    return readEnumArray(ev);
  }

  template <int N, class EnumType>
  bool readSelectArray(EnumType ev[]) {
    StepListRep list = nextList();
    if (not list.valid())
      return false;
    const int ne = list.nelements();
    const int m = std::min(N,ne);
    cursor = list.begin() + 1;
    bool ok = true;
    for (int i=0; i<m; ++i) {
      ok &= ev[i].read(*this);
    }
    cursor = list.end();
    return ok;
  }

  /// write attribute
  static void writeAttr(std::ostream & os, bool x) {
    os << (x ? ".T." : ".F.");
  }

  /// write attribute
  static void writeAttr(std::ostream & os, int x) {os << x;}

  /// write attribute
  static void writeAttr(std::ostream & os, StepID x, char cundef='*') {
    if (x == 0)
      os << cundef;
    else
      os << '#' << x;
  }

  /// write attribute
  static void writeAttr(std::ostream & os, double x) {os << x;}

  /// write attribute
  static void writeAttr(std::ostream & os, const std::string & x) {
    os << '\'' << x << '\'';
  }

  /// write attribute array
  static void writeAttr(std::ostream & os, const StepIntArray & x);

  /// write attribute array
  static void writeAttr(std::ostream & os, const StepIDArray & x);

  /// write attribute array
  static void writeAttr(std::ostream & os, const StepRealArray & x);

  /// write attribute array
  static void writeAttr(std::ostream & os, const StepStringArray & x);

  /// write attribute array
  static void writeAttr(std::ostream & os, const StepIDMatrix & x);

  /// write attribute array
  static void writeAttr(std::ostream & os, const StepRealMatrix & x);

  template <int N>
  static void writeArrayAttr(std::ostream & os, const int x[]) {
    for (int i=0; i<N-1; ++i)
      os << x[i] << ',';
    os << x[N-1];
  }

  template <int N>
  static void writeArrayAttr(std::ostream & os, const StepID x[]) {
    for (int i=0; i<N-1; ++i)
      os << '#' << x[i] << ',';
    os << '#' << x[N-1];
  }

  template <int N>
  static void writeArrayAttr(std::ostream & os, const double x[]) {
    for (int i=0; i<N-1; ++i)
      os << x[i] << ',';
    os << x[N-1];
  }

  template <class EnumType>
  static void writeEnumArray(std::ostream & os,
                             const std::vector<EnumType> & ev)
  {
    os << '(';
    const int n = ev.size();
    for (int i=0; i<n-1; ++i) {
      ev[i].write(os);
      os << ',';
    }
    ev.back().write(os);
    os << ')';
  }

  template <int N, class EnumType>
  static void writeEnumArray(std::ostream & os, const EnumType ev[])
  {
    os << '(';
    for (int i=0; i<N-1; ++i) {
      ev[i].write(os);
      os << ',';
    }
    ev[N-1].write(os);
    os << ')';
  }

  template <class EnumType>
  static void writeSelectArray(std::ostream & os,
                               const std::vector<EnumType> & ev)
  {
    os << '(';
    const int n = ev.size();
    int nvalid(0);
    for (int i=0; i<n; ++i) {
      if (ev[i].valid()) {
        if (nvalid > 0)
          os << ',';
        ev[i].write(os);
        ++nvalid;
      }
    }
    os << ')';
  }

  template <int N, class EnumType>
  static void writeSelectArray(std::ostream & os, const EnumType ev[])
  {
    os << '(';
    int nvalid(0);
    for (int i=0; i<N; ++i) {
      if (ev[i].valid()) {
        if (nvalid > 0)
          os << ',';
        ev[i].write(os);
      }
    }
    os << ')';
  }

  /// low-level access : extract a list, set cursor to its end
  StepListRep parseList() {
    StepListRep list = StepListRep(cursor);
    if (list.valid())
      cursor = list.end();
    return list;
  }

private:

  /// extract list
  StepListRep nextList() {
    StepListRep list = StepListRep(cursor);
    if (list.valid())
      cursor = list.begin();
    return list;
  }

private:

  /// start of the line
  // const char *line;

  /// cursor position
  const char *cursor;
};

#endif // StepFileLine_H
