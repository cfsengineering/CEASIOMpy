
/* Copyright (C) 2015 David Eller <david@larosterna.com>
 * 
 * Commercial License Usage
 * Licensees holding valid commercial licenses may use this file in accordance
 * with the terms contained in their respective non-exclusive license agreement.
 * For further information contact david@larosterna.com .
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation and
 * appearing in the file gpl.txt included in the packaging of this file.
 */
 
#ifndef SURF_TOPOISECSEGMENT_H
#define SURF_TOPOISECSEGMENT_H

#include "forward.h"
#include <genua/point.h>
#include <deque>

/** Intersection segment.
 *
 * Representation of a straight intersection segment compatible with
 * class Topology.
 *
 * \ingroup meshgen
 * \sa Topology
 */
class TopoIsecSegment
{
public:

  /// create undefined segment
  TopoIsecSegment() { m_pix[0] = m_pix[1] = NotFound; }

  /// initialize from intersection results
  TopoIsecSegment(uint fa, uint fb, const IndexPairArray &pairs,
                  const PointList<3> &pts, uint ip);

  /// compute (u,v) space coordinates for segment end points
  void uvMap(const Topology &topo);

  /// access source point
  const Vct3 & psource() const {return m_pts[0];}

  /// access target point
  const Vct3 & ptarget() const {return m_pts[1];}

  /// (u,v) source on a
  const Vct2 & asource() const {return m_uva[0];}

  /// (u,v) target on a
  const Vct2 & atarget() const {return m_uva[1];}

  /// (u,v) source on b
  const Vct2 & bsource() const {return m_uvb[0];}

  /// (u,v) target on b
  const Vct2 & btarget() const {return m_uvb[1];}

  /// assign vertex indices
  void assign(uint si, uint ti) {
    m_pix[0] = si;
    m_pix[1] = ti;
  }

  /// access source vertex index
  uint source() const {return m_pix[0];}

  /// access source vertex index
  uint target() const {return m_pix[1];}

  /// the other vertex of this
  uint opposed(uint k) const {
    if (k == source())
      return target();
    else if (k == target())
      return source();
    return NotFound;
  }

  /// access face index
  uint aface() const {return m_iface[0];}

  /// access face index
  uint bface() const {return m_iface[1];}

  /// return pair of faces on which this intersection lies
  IndexPair facePair() const {
    return std::make_pair( m_iface[0], m_iface[1] );
  }

  /// test whether this is an intersection of faces (a,b)
  bool onFaces(const IndexPair &pair) const {
    return (m_iface[0] == pair.first) and (m_iface[1] == pair.second);
  }

  /// continue construction of a chain
  bool enchain(std::deque<uint> & chain) const {
    const uint front = chain.front();
    if (source() == front) {
      chain.push_front( target() );
      return true;
    } else if (target() == front) {
      chain.push_front( source() );
      return true;
    }
    const uint tail = chain.back();
    if (source() == tail) {
      chain.push_back( target() );
      return true;
    } else if (target() == tail) {
      chain.push_back( source() );
      return true;
    }
    return false;
  }

  /// utility interface for data generated by LasyIsecTree
  static void append(uint fa, uint fb, const IndexPairArray &pairs,
                     const PointList<3> &pts, TopoIsecArray &segm);

  /// generate line representation for visualization
  static uint asLines(const TopoIsecArray &segm, MxMesh &mx);

private:

  /// raw intersection points
  Vct3 m_pts[2];

  /// source and target point in (u,v) space of first face
  Vct2 m_uva[2];

  /// source and target point in (u,v) space of second face
  Vct2 m_uvb[2];

  /// point indices (assigned after point merging)
  uint m_pix[2];

  /// triangle indices
  uint m_tri[2];

  /// face indices (referencing Topology)
  uint m_iface[2];
};

#endif // TOPOISECSEGMENT_H
