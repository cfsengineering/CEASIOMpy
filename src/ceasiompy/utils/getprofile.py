"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Functions used to get profile as list of point, either directly from
the list point in the CPACS file or from the CPACS CST2D curve.
"""

# =================================================================================================
#   IMPORTS
# =================================================================================================

import numpy as np

from cpacspy.cpacsfunctions import get_float_vector
from math import (
    cos,
    factorial,
)

from tixi3.tixi3wrapper import Tixi3

from math import pi
from ceasiompy import log

# =================================================================================================
#   CLASSES
# =================================================================================================


class CST_shape(object):
    """
    Description : Create a set of airfoil coordinates using CST parametrization method

    Input  : wl = CST weight of lower surface
            wu = CST weight of upper surface
            dz = trailing edge thickness

    Output : coord = set of x-y coordinates of airfoil generated by CST

    Adapted from:   Kulfan_CST/kulfan_to_coord.py
                    by Ryan Barrett 'ryanbarr'
                    https://github.com/Ry10/Kulfan_CST

    Adapted from:   Airfoil generation using CST parameterization method
                    by Pramudita Satria Palar
                    http://www.mathworks.com/matlabcentral/fileexchange/42239-airfoil-generation-using-cst-parameterization-method
    """
    def __init__(self, wl=None, wu=None, dz=0, N=200):

        if wl is None:
            self.wl = [-1, -1, -1]
        else:
            self.wl = wl

        if wu is None:
            self.wu = [1, 1, 1]
        else:
            self.wu = wu

        self.dz = dz
        self.N = N
        self.x_list = []
        self.y_list = []
        self.coordinate = np.zeros(N)

    def airfoil_coor(self):
        wl = self.wl
        wu = self.wu
        dz = self.dz
        N = self.N

        # Create x coordinate
        x = np.ones((N, 1))
        y = np.zeros((N, 1))
        zeta = np.zeros((N, 1))

        for i in range(0, N):
            zeta[i] = 2 * pi / N * i
            x[i] = 0.5 * (cos(zeta[i][0]) + 1)

        # N1 and N2 parameters (N1 = 0.5 and N2 = 1 for airfoil shape)
        N1 = 0.5
        N2 = 1

        # Used to separate upper and lower surfaces
        center_loc = np.where(x == 0)
        center_loc = center_loc[0][0]

        xl = np.zeros(center_loc)
        xu = np.zeros(N - center_loc)

        # Lower surface x-coordinates
        for i, _ in enumerate(xl):
            xl[i] = x[i][0]

        # Upper surface x-coordinates
        for i, _ in enumerate(xu):
            xu[i] = x[i + center_loc][0]

        # Call ClassShape function to determine lower and upper surface y-coordinates
        yl = self.__ClassShape(wl, xl, N1, N2, -dz)
        yu = self.__ClassShape(wu, xu, N1, N2, dz)

        # Combine upper and lower y coordinates
        y = np.concatenate([yl, yu])

        self.coord = [x, y]

        self.x_list = x.ravel().tolist()
        self.y_list = y.ravel().tolist()

        # self.plotting()
        return self.coord

    @staticmethod
    def __ClassShape(w, x, N1, N2, dz):

        # Class function; taking input of N1 and N2
        C = np.zeros(len(x))
        for i in range(len(x)):
            C[i] = x[i] ** N1 * ((1 - x[i]) ** N2)

        # Shape function; using Bernstein Polynomials
        n = len(w) - 1  # Order of Bernstein polynomials

        K = np.zeros(n + 1)
        for i in range(0, n + 1):
            K[i] = factorial(n) / (factorial(i) * (factorial((n) - (i))))

        S = np.zeros(len(x))
        for i in range(len(x)):
            S[i] = 0
            for j in range(0, n + 1):
                S[i] += w[j] * K[j] * x[i] ** (j) * ((1 - x[i]) ** (n - (j)))

        # Calculate y output
        y = np.zeros(len(x))
        for i, _ in enumerate(y):
            y[i] = C[i] * S[i] + x[i] * dz

        return y


# =================================================================================================
#   FUNCTIONS
# =================================================================================================


def get_profile_coord(tixi: Tixi3, prof_uid: str) -> tuple[list, list, list]:
    """
    Get profile coordinate points.

    Args:
        tixi (handles): TIXI Handle.
        prof_uid (str): uID of the airfoil/profile to get.

    Returns:
         (tuple[list, list, list]): list of x, y, z coordinate points.
            - list[float]: list of x-th coordinate points.
            - list[float]: list of y-th coordinate points.
            - list[float]: list of z-th coordinate points.

    """

    prof_xpath = tixi.uIDGetXPath(prof_uid)

    prof_vect_x = []
    prof_vect_y = []
    prof_vect_z = []

    if tixi.checkElement(prof_xpath + "/pointlist"):

        try:
            prof_vect_x = get_float_vector(tixi, prof_xpath + "/pointlist/x")
        except ValueError:
            log.warning("No point list in x coordinate has been found!")

        try:
            prof_vect_y = get_float_vector(tixi, prof_xpath + "/pointlist/y")
        except ValueError:
            log.warning("No point list in y coordinate has been found!")

        try:
            prof_vect_z = get_float_vector(tixi, prof_xpath + "/pointlist/z")
        except ValueError:
            log.warning("No point list in z coordinate has been found!")

    elif tixi.checkElement(prof_xpath + "/cst2D"):

        # psi = get_float_vector(tixi, prof_xpath + "/cst2D/psi")

        # upperN1 = tixi.getTextElement(prof_xpath + "/cst2D/upperN1")
        # upperN2 = tixi.getTextElement(prof_xpath + "/cst2D/upperN2")
        upperB = get_float_vector(tixi, prof_xpath + "/cst2D/upperB")

        # lowerN1 = tixi.getTextElement(prof_xpath + "/cst2D/lowerN1")
        # lowerN2 = tixi.getTextElement(prof_xpath + "/cst2D/lowerN2")
        lowerB = get_float_vector(tixi, prof_xpath + "/cst2D/lowerB")

        if tixi.checkElement(prof_xpath + "/cst2D/trailingEdgeThickness"):
            TEThickness = tixi.getTextElement(prof_xpath + "/cst2D/trailingEdgeThickness")
        else:
            TEThickness = 0.0

        wl = [-k for k in lowerB]
        wu = upperB
        dz = TEThickness
        N = 200  # number of points

        airfoil_CST = CST_shape(wl, wu, dz, N)
        airfoil_CST.airfoil_coor()
        # airfoil_CST.plotting()

        prof_vect_x = airfoil_CST.x_list
        prof_vect_z = airfoil_CST.y_list

    else:
        # TODO: add standardProfile (CPACS 3.3)
        log.error('The profile "' + prof_uid + '" contains no "pointlist" or "cst2d" definition.')

    if not prof_vect_x and not prof_vect_y and not prof_vect_z:
        raise ValueError("Profile coordinates have not been found!")

    # Add the third coordinate (with 0's) if not exists
    if not prof_vect_x:
        prof_vect_x = [0] * len(prof_vect_y)

    elif not prof_vect_y:
        prof_vect_y = [0] * len(prof_vect_x)

    elif not prof_vect_z:
        prof_vect_z = [0] * len(prof_vect_x)

    if sum(prof_vect_z[0 : len(prof_vect_z) // 2]) < sum(prof_vect_z[len(prof_vect_z) // 2 : -1]):

        # reverse airfoil's points
        prof_vect_x.reverse()
        prof_vect_y.reverse()
        prof_vect_z.reverse()

    return prof_vect_x, prof_vect_y, prof_vect_z
